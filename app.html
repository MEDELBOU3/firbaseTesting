<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Plateforme d'Apprentissage FPN — Université Mohamed Premier</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" />
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet" />
    <link href="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.min.css" rel="stylesheet" />
    <link href="https://cdn.jsdelivr.net/npm/quill@2.0.0/dist/quill.snow.css" rel="stylesheet" />
    <script src="https://cdn.jsdelivr.net/npm/quill@2.0.0/dist/quill.js"></script>

    <!-- Quill CSS -->
    <link href="https://cdn.quilljs.com/1.3.7/quill.snow.css" rel="stylesheet">

    <!-- Highlight.js CSS (for syntax highlighting in code blocks) -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css" rel="stylesheet">
    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/monokai-sublime.min.css" />

    <!-- Quill JS -->
    <script src="https://cdn.quilljs.com/1.3.7/quill.min.js"></script>

    <!-- Highlight.js JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>



    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/emoji-mart@latest/dist/emoji-mart.css" />
    <script src="https://cdn.jsdelivr.net/npm/emoji-mart@latest/dist/browser/emoji-mart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.11/index.global.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@fullcalendar/bootstrap5@6.1.11/index.global.min.js"></script>

    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dompurify@3.0.6/dist/purify.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">

    <link rel="stylesheet" href="thems.css">
    <link rel="stylesheet" href="css/style.css" />


</head>

<body data-theme="light">
    <!-- Thème par défaut -->

    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg sticky-top">
        <div class="container-fluid">
            <!-- Sidebar Toggle -->
            <button class="btn btn-link me-2 d-lg-none" id="sidebarToggle">
                <i class="bi bi-list fs-4"></i>
            </button>

            <!-- Logo -->
            <a class="navbar-brand d-flex gap-3 align-items-center" href="#">
                <img src="https://espace-fpn.ump.ma/src/logo.svg" alt="logo" height="44" />
                <div class="d-none d-md-block">
                    <div style="font-weight: 700; color: var(--brand); font-size: 14px">
                        Université Mohamed Premier
                    </div>
                    <div style="font-size: 11px; color: var(--muted)">
                        Faculté des Sciences - Plateforme d'Apprentissage
                    </div>
                </div>
            </a>

            <!-- Right Side -->
            <div class="d-flex ms-auto gap-3 align-items-center">
                <!-- Search Box -->
                <div class="search-box d-none d-md-block">
                    <i class="bi bi-search"></i>
                    <input type="text" class="form-control" placeholder="Rechercher des cours, matériaux..."
                        id="searchInput" />
                </div>

                <!-- Notifications -->
                <div class="dropdown">
                    <button class="btn btn-link position-relative" id="notifBtn" data-bs-toggle="dropdown"
                        aria-expanded="false">
                        <i class="bi bi-bell fs-5"></i>
                        <!-- Unread count badge (will be managed by JS) -->
                        <span class="notification-badge d-none" id="notifCount">0</span>
                    </button>
                    <div class="dropdown-menu dropdown-menu-end shadow-lg border-0 p-2" id="notifDropdown"
                        style="width: 350px">
                        <div class="px-3 py-2 d-flex justify-content-between align-items-center">
                            <h6 class="dropdown-header p-0">Notifications</h6>
                            <button class="btn btn-sm btn-link" id="markAllAsReadBtn">
                                Tout marquer comme lu
                            </button>
                        </div>
                        <div id="notifListContainer" class="list-group list-group-flush">
                            <!-- Notifications will be loaded here -->
                            <div class="text-center text-muted p-4">Chargement...</div>
                        </div>
                        <div class="text-center mt-2">
                            <a class="dropdown-item text-center" href="#" data-view="notifications">
                                Voir toutes les notifications
                            </a>
                        </div>
                    </div>
                </div>
                <!-- Profile Dropdown -->
                <div class="dropdown" id="profileDropdown" style="display: none">
                    <a href="#" class="d-flex align-items-center gap-2 text-decoration-none dropdown-toggle"
                        id="profileMenu" data-bs-toggle="dropdown" aria-expanded="false">
                        <img id="userPhoto" src="" alt="Avatar" style="
                  width: 40px;
                  height: 40px;
                  border-radius: 50%;
                  object-fit: cover;
                  border: 2px solid var(--accent);
                " />
                        <span id="userName" class="fw-semibold d-none d-md-inline"></span>
                    </a>
                    <ul class="dropdown-menu dropdown-menu-end shadow-sm border-0 p-2" aria-labelledby="profileMenu">
                        <li class="px-3 pb-2 border-bottom">
                            <small class="text-muted" id="userEmail"></small>
                        </li>
                        <li>
                            <a class="dropdown-item" href="#" data-view="settings"><i
                                    class="bi bi-gear me-2"></i>Paramètres</a>
                        </li>
                        <li>
                            <button class="dropdown-item text-danger" id="btnLogout">
                                <i class="bi bi-box-arrow-right me-2"></i>Déconnexion
                            </button>
                        </li>
                    </ul>
                </div>

                <!-- Login Button -->
                <button id="btnLogin" class="btn btn-primary">Se connecter</button>
            </div>
        </div>
    </nav>

    <!-- Sidebar -->
    <aside class="sidebar" id="sidebar">
        <div class="p-3">
            <h6 class="text-muted text-uppercase" style="font-size: 11px; letter-spacing: 1px">
                Navigation
            </h6>
        </div>

        <a class="sidebar-item active" data-view="dashboard">
            <i class="bi bi-speedometer2"></i>
            <span>Tableau de bord</span>
        </a>
        <a class="sidebar-item" data-view="courses">
            <i class="bi bi-collection"></i>
            <span>Tous les cours</span>
        </a>
        <a class="sidebar-item" data-view="videos">
            <i class="bi bi-play-circle"></i>
            <span>Tutoriels vidéo</span>
        </a>
        <a class="sidebar-item" data-view="contributed">
            <i class="bi bi-people"></i>
            <span>Contenu contribué</span>
        </a>
        <a class="sidebar-item" data-view="documents">
            <i class="bi bi-file-earmark-text"></i>
            <span>Documents</span>
        </a>
        <!-- NOUVEL ÉLÉMENT -->
        <a class="sidebar-item" data-view="library">
            <i class="bi bi-book-half"></i>
            <span>Bibliothèque FPN</span>
        </a>
        <!-- FIN NOUVEL ÉLÉMENT -->

        <a class="sidebar-item" data-view="assignments">
            <i class="bi bi-clipboard-check"></i>
            <span>Devoirs</span>
        </a>

        <div class="p-3">
            <h6 class="text-muted text-uppercase" style="font-size: 11px; letter-spacing: 1px">
                Personnalisé
            </h6>
        </div>

        <a class="sidebar-item" data-view="calendar">
            <i class="bi bi-calendar-event"></i>
            <span>Calendrier</span>
        </a>

        <a class="sidebar-item" data-view="inbox">
            <i class="bi bi-inbox"></i>
            <span>Messagerie</span>
            <!-- Badge pour les messages non lus (géré par JS) -->
            <span class="badge rounded-pill bg-danger ms-auto d-none" id="inboxCount">0</span>
        </a>

        <a class="sidebar-item" data-view="discussions">
            <i class="bi bi-chat-square-dots"></i>
            <span>Discussions</span>
        </a>
        <a class="sidebar-item" data-view="ai-chats">
            <i class="bi bi-robot"></i>
            <span>Chat with Fpn Ai</span>
        </a>
        <a class="sidebar-item" data-view="notifications">
            <i class="bi bi-bell"></i>
            <span>Notifications</span>
        </a>
        <div class="p-3">
            <h6 class="text-muted text-uppercase" style="font-size: 11px; letter-spacing: 1px">
                Divertissement
            </h6>
        </div>
        <a class="sidebar-item" data-view="edu-media">
            <i class="bi bi-film"></i>
            <span>Éducation & Médias</span>
        </a>
        <a class="sidebar-item" data-view="music">
            <i class="bi bi-music-note-beamed"></i>
            <span>Musique</span>
        </a>

        <div class="p-3 mt-3">
            <h6 class="text-muted text-uppercase" style="font-size: 11px; letter-spacing: 1px">
                Outils
            </h6>
        </div>

        <a class="sidebar-item" data-view="notes">
            <i class="bi bi-journal-text"></i>
            <span>Mes notes</span>
        </a>

        <!-- ANCIEN : <a class="sidebar-item" data-view="codeeditor"> ... -->
        <a class="sidebar-item" data-view="codeeditor-guide">
            <i class="bi bi-code-slash"></i>
            <span title="Code  Éditeur & UML  Éditeur">Outils d'application</span>
        </a>
        <a class="sidebar-item" data-view="progress">
            <i class="bi bi-graph-up"></i>
            <span>Suivi des progrès</span>
        </a>
        <a class="sidebar-item" data-view="settings">
            <i class="bi bi-gear"></i>
            <span>Paramètres</span>
        </a>
    </aside>

    <!-- Main Content -->
    <main class="main-content" id="mainContent">
        <!-- Tableau de bord View -->
        <div id="dashboardView" class="view-content">
            <div class="d-flex justify-content-between align-items-center mb-4">
                <div>
                    <h2 style="color: var(--brand); font-weight: 700">
                        Bienvenue de retour,
                        <span id="welcomeUserName" style="color: var(--accent)"></span> !
                    </h2>

                    <p class="text-muted">Continuez votre parcours d'apprentissage</p>
                </div>
                <div class="d-flex gap-2">
                    <select class="form-select" id="semesterFilter">
                        <option>Tous les semestres</option>
                        <option>Semestre 1</option>
                        <option>Semestre 2</option>
                    </select>
                </div>
            </div>

            <!-- Stats -->
            <div class="row g-4 mb-4">
                <div class="col-md-3">
                    <div class="stat-card">
                        <i class="bi bi-book"></i>
                        <div style="position: relative; z-index: 1">
                            <small style="opacity: 0.9">Total des cours</small>
                            <h3 id="totalCourses">0</h3>
                        </div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="stat-card" style="
                background: linear-gradient(135deg, var(--success), #20c997);
              ">
                        <i class="bi bi-check-circle"></i>
                        <div style="position: relative; z-index: 1">
                            <small style="opacity: 0.9">Complétés</small>
                            <h3 id="completedCourses">0</h3>
                        </div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="stat-card" style="
                background: linear-gradient(135deg, var(--accent), #e6c84f);
              ">
                        <i class="bi bi-clock-history"></i>
                        <div style="position: relative; z-index: 1">
                            <small style="opacity: 0.9">En cours</small>
                            <h3 id="inProgressCourses">0</h3>
                        </div>
                    </div>
                </div>
                <div class="col-md-3">
                    <div class="stat-card" style="background: linear-gradient(135deg, #6f42c1, #8b5cf6)">
                        <i class="bi bi-trophy"></i>
                        <div style="position: relative; z-index: 1">
                            <small style="opacity: 0.9">Score d'accomplissement</small>
                            <h3>85%</h3>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Continuer l'apprentissage -->
            <div class="card card-modern mb-4">
                <div class="card-body">
                    <h5 class="mb-3">
                        <i class="bi bi-play-circle me-2"></i>Continuer l'apprentissage
                    </h5>
                    <div class="row g-3" id="continueSection">
                        <div class="col-12 text-center text-muted py-4">
                            <i class="bi bi-folder2-open fs-1"></i>
                            <p class="mt-2">Chargement de vos cours...</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Activité récente -->
            <div class="row g-4">
                <div class="col-lg-8">
                    <div class="card card-modern">
                        <div class="card-body">
                            <h5 class="mb-4">
                                <i class="bi bi-clock-history me-2"></i>Activité récente
                            </h5>
                            <div id="activityTimeline">
                                <div class="timeline-item">
                                    <div class="timeline-dot"><i class="bi bi-check"></i></div>
                                    <div>
                                        <strong>Complété : Module de conception d'algorithmes</strong>
                                        <p class="text-muted small mb-0">Il y a 2 heures</p>
                                    </div>
                                </div>
                                <div class="timeline-item">
                                    <div class="timeline-dot">
                                        <i class="bi bi-file-earmark"></i>
                                    </div>
                                    <div>
                                        <strong>Téléchargé : Notes de cours sur les structures de
                                            données</strong>
                                        <p class="text-muted small mb-0">Hier</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="col-lg-4">
                    <div class="card card-modern">
                        <div class="card-body">
                            <h5 class="mb-4">
                                <i class="bi bi-calendar-event me-2"></i>À venir
                            </h5>
                            <div class="d-flex flex-column gap-3">
                                <div class="d-flex gap-3 align-items-center">
                                    <div class="bg-primary text-white p-2 rounded"
                                        style="min-width: 48px; text-align: center">
                                        <div style="font-size: 20px; font-weight: 700">18</div>
                                        <div style="font-size: 10px">OCT</div>
                                    </div>
                                    <div>
                                        <strong style="font-size: 14px">Examen de base de données</strong>
                                        <p class="text-muted small mb-0">10:00</p>
                                    </div>
                                </div>
                                <div class="d-flex gap-3 align-items-center">
                                    <div class="bg-warning text-white p-2 rounded"
                                        style="min-width: 48px; text-align: center">
                                        <div style="font-size: 20px; font-weight: 700">20</div>
                                        <div style="font-size: 10px">OCT</div>
                                    </div>
                                    <div>
                                        <strong style="font-size: 14px">Soumission de projet</strong>
                                        <p class="text-muted small mb-0">23:59</p>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Tous les cours View -->
        <div id="coursesView" class="view-content d-none">
            <div id="breadcrumb" class="mb-3"></div>
            <div class="d-flex justify-content-between align-items-center mb-4">
                <h2 style="color: var(--brand); font-weight: 700">Tous les cours</h2>
                <div class="d-flex gap-2">
                    <select class="form-select" id="categoryFilter">
                        <option value="all">Toutes les catégories</option>
                        <option value="video">Vidéos</option>
                        <option value="document">Documents</option>
                        <option value="folder">Dossiers</option>
                    </select>
                    <select class="form-select" id="sortBy">
                        <option>Trier par nom</option>
                        <option>Trier par date</option>
                        <option>Trier par type</option>
                    </select>
                </div>
            </div>

            <div id="loader" class="py-5 text-center">
                <div class="loader"></div>
                <div class="mt-3 text-muted">
                    Chargement des cours depuis Drive...
                </div>
            </div>

            <div class="row g-4" id="coursesGrid"></div>
            <div class="card card-modern mt-4 d-none" id="folderContributedSection">
                <div class="card-body">
                    <h5 class="mb-3">Tutoriels contribués pour ce cours</h5>
                    <div class="row g-4" id="folderContributedGrid"></div>
                </div>
            </div>
        </div>

        <!-- Tutoriels vidéo View -->
        <div id="videosView" class="view-content d-none">
            <h2 class="mb-4" style="color: var(--brand); font-weight: 700">
                Tutoriels vidéo
            </h2>
            <div class="row g-4" id="videosGrid"></div>
            <div class="card card-modern mt-4">
                <div class="card-body">
                    <h5 class="mb-3">Tutoriels YouTube recommandés</h5>
                    <div class="row g-4" id="youtubeVideosGrid"></div>
                </div>
            </div>
            <div class="card card-modern mt-4">
                <div class="card-body">
                    <h5 class="mb-3">Tutoriels contribués</h5>
                    <div class="row g-4" id="contributedVideosGrid"></div>
                </div>
            </div>
        </div>

        <!-- Contenu contribué View -->
        <div id="contributedView" class="view-content d-none">
            <h2 class="mb-4" style="color: var(--brand); font-weight: 700">
                Contenu contribué
            </h2>
            <!-- In #contributedView -->
            <form id="addContentForm" class="card card-modern mb-4">
                <div class="card-body">
                    <h5 class="card-title mb-3">Partager une ressource</h5>
                    <div class="row g-3">
                        <div class="col-md-6">
                            <label for="contentUrl" class="form-label">URL de la ressource</label>
                            <input id="contentUrl" class="form-control" placeholder="Collez l'URL ici..." required />
                        </div>
                        <div class="col-md-6">
                            <label for="contentType" class="form-label">Type de contenu</label>
                            <select id="contentType" class="form-select" required>
                                <option value="youtube" selected>
                                    Vidéo / Playlist YouTube
                                </option>
                                <option value="gdrive_video">Vidéo Google Drive</option>
                                <option value="gdrive_doc">
                                    Document Google Drive (PDF, Livre)
                                </option>
                                <option value="link">Lien Web / Article</option>
                            </select>
                        </div>
                        <div class="col-md-6">
                            <label for="contentTitle" class="form-label">Titre (optionnel)</label>
                            <input id="contentTitle" class="form-control" placeholder="Titre personnalisé..." />
                        </div>
                        <div class="col-md-6">
                            <label for="contentCourse" class="form-label">Associer à un cours (optionnel)</label>
                            <select id="contentCourse" class="form-select">
                                <option value="">Aucun cours spécifique</option>
                            </select>
                        </div>
                    </div>
                    <button class="btn btn-primary mt-3" type="submit">
                        Ajouter le contenu
                    </button>
                </div>
            </form>
            <div class="row g-4" id="contributedGrid"></div>
        </div>

        <!-- Documents View -->
        <div id="documentsView" class="view-content d-none">
            <div class="d-flex justify-content-between align-items-center mb-4">
                <h2 style="color: var(--brand); font-weight: 700">
                    Documents & Matériaux
                </h2>

                <!-- START: NEW LAYOUT TOGGLE -->
                <div class="btn-group" role="group" aria-label="Layout Toggle">
                    <button type="button" class="btn btn-outline-primary active" id="btnGridDocuments">
                        <i class="bi bi-grid-3x3-gap-fill"></i> Grille
                    </button>
                    <button type="button" class="btn btn-outline-primary" id="btnListDocuments">
                        <i class="bi bi-list"></i> Liste
                    </button>
                </div>
                <!-- END: NEW LAYOUT TOGGLE -->
            </div>
            <div class="row g-4" id="documentsGrid"></div>
        </div>

        <!-- Bibliothèque FPN View -->
        <div id="libraryView" class="view-content d-none">

            <!-- Sous-vue 1: Liste des Résultats et Recherche -->
            <div id="libraryList">
                <h2 class="mb-4" style="color:var(--brand); font-weight:700">Bibliothèque FPN</h2>

                <div class="row g-4 mb-4">
                    <div class="col-md-12">
                        <div class="card card-modern p-3">
                            <form id="librarySearchForm" class="d-flex gap-2">
                                <input type="text" id="librarySearchInput" class="form-control"
                                    placeholder="Rechercher par titre, auteur ou sujet (Ex: Algorithmes, Chimie, Einstein)..."
                                    required>
                                <button type="submit" class="btn btn-primary" id="librarySearchBtn">
                                    <i class="bi bi-search me-1"></i> Rechercher
                                </button>
                            </form>
                        </div>
                    </div>
                </div>

                <!-- Statistiques / Filtres Avancés (Laissé vide) -->
                <div class="row g-4 mb-4" id="libraryStats"></div>

                <!-- Résultats de la Recherche -->
                <h5 class="mb-3 mt-4">
                    Résultats (<span id="libraryResultCount">0</span> trouvés)
                    <span id="libraryShowingCount" class="text-muted small"></span>
                </h5>
                <div id="libraryResultsGrid" class="row g-4">
                    <div class="col-12 text-center text-muted py-5" id="libraryInitialMessage">
                        <i class="bi bi-book fs-1"></i>
                        <p class="mt-2">Chargement des livres populaires...</p>
                    </div>
                </div>

                <!-- CORRIGÉ: Bouton Charger Plus avec onclick -->
                <div id="loadMoreContainer" class="d-flex justify-content-center mt-4 d-none">
                    <button class="btn btn-outline-primary" id="loadMoreBtn" onclick="loadMoreBooks()">Charger plus de
                        résultats</button>

                </div>

            </div>

            <!-- Sous-vue 2: Détails du Livre -->
            <div id="bookDetailView" class="d-none">
                <div id="bookDetailContent">
                    <!-- Le contenu sera injecté ici par JavaScript -->
                </div>
            </div>

        </div>

        <!-- Devoirs View -->
        <div id="assignmentsView" class="view-content d-none">
            <h2 class="mb-4" style="color: var(--brand); font-weight: 700">
                Devoirs
            </h2>
            <div class="row g-4" id="assignmentsGrid"></div>
        </div>

        <!-- Calendrier View -->
        <div id="calendarView" class="view-content d-none">
            <div class="d-flex justify-content-between align-items-center mb-4">
                <h2 style="color: var(--brand); font-weight: 700">Calendrier</h2>
                <button id="addEventButton" class="btn btn-primary">
                    <i class="bi bi-plus-circle me-2"></i>Ajouter un événement
                </button>
            </div>
            <div class="card card-modern">
                <div class="card-body">
                    <!-- FullCalendar will be rendered here -->
                    <div id="calendar"></div>
                </div>
            </div>
        </div>

        <!-- Event Modal -->
        <div class="modal fade" id="eventModal" tabindex="-1" aria-labelledby="eventModalLabel" aria-hidden="true">
            <div class="modal-dialog modal-dialog-centered">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="eventModalLabel">
                            Ajouter/Modifier un événement
                        </h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <form id="eventForm">
                            <!-- Hidden input to store event ID for updates -->
                            <input type="hidden" id="eventId" />
                            <div class="mb-3">
                                <label for="eventTitle" class="form-label">Titre de l'événement</label>
                                <input type="text" class="form-control" id="eventTitle" required />
                            </div>
                            <div class="row">
                                <div class="col-md-6 mb-3">
                                    <label for="eventStart" class="form-label">Début</label>
                                    <input type="datetime-local" class="form-control" id="eventStart" required />
                                </div>
                                <div class="col-md-6 mb-3">
                                    <label for="eventEnd" class="form-label">Fin</label>
                                    <input type="datetime-local" class="form-control" id="eventEnd" required />
                                </div>
                            </div>
                            <div class="form-check mb-3">
                                <input class="form-check-input" type="checkbox" id="eventAllDay" />
                                <label class="form-check-label" for="eventAllDay">Toute la journée</label>
                                <div class="mb-3">
                                    <label for="eventColor" class="form-label"><i
                                            class="bi bi-palette-fill me-2"></i>Couleur de
                                        l'événement</label>
                                    <input type="color" class="form-control form-control-color" id="eventColor"
                                        value="#0b3b61" title="Choisissez une couleur" />
                                </div>
                            </div>

                            <!-- START: NEW ALARM SECTION -->
                            <div class="border-top pt-3">
                                <div class="row g-3">
                                    <div class="col-md-6">
                                        <label for="eventAlarm" class="form-label"><i
                                                class="bi bi-alarm me-2"></i>Rappel / Alarme</label>
                                        <select id="eventAlarm" class="form-select">
                                            <option value="none" selected>Aucun</option>
                                            <option value="5">5 minutes avant</option>
                                            <option value="15">15 minutes avant</option>
                                            <option value="30">30 minutes avant</option>
                                            <option value="60">1 heure avant</option>
                                        </select>
                                    </div>
                                    <div class="col-md-6">
                                        <label for="eventSound" class="form-label"><i
                                                class="bi bi-music-note-beamed me-2"></i>Son de
                                            l'alarme</label>
                                        <select id="eventSound" class="form-select">
                                            <option value="chime" selected>Carillon</option>
                                            <option value="notification">Notification</option>
                                            <option value="digital">Digital</option>
                                        </select>
                                    </div>
                                </div>
                            </div>
                            <!-- END: NEW ALARM SECTION -->
                        </form>
                    </div>
                    <div class="modal-footer justify-content-between">
                        <button type="button" class="btn btn-danger" id="deleteEventButton" style="display: none">
                            Supprimer
                        </button>
                        <div>
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                                Annuler
                            </button>
                            <button type="submit" form="eventForm" class="btn btn-primary">
                                Enregistrer
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Discussions View -->
        <div id="discussionsView" class="view-content d-none">
            <!-- Sub-view: List of all discussion threads -->

            <div id="discussionsList">
                <div class="d-flex justify-content-between align-items-center mb-4">
                    <h2 style="color: var(--brand); font-weight: 700">Discussions</h2>
                    <div class="d-flex gap-2">
                        <!-- NOUVEAU FILTRE -->
                        <select id="discussionFilter" class="form-select">
                            <option value="recent">Plus récent (par défaut)</option>
                            <option value="popular">Plus populaire (Likes)</option>
                            <option value="replies">Plus de réponses</option>
                            <option value="admin">Réponses Admin</option>
                        </select>
                        <!-- FIN NOUVEAU FILTRE -->
                        <button class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#newDiscussionModal">
                            <i class="bi bi-plus-circle me-2"></i>Démarrer une nouvelle discussion
                        </button>
                    </div>
                </div>
                <div id="threadsContainer" class="d-flex flex-column gap-3">
                    <!-- Discussion threads will be loaded here -->
                    <div class="text-center p-5">
                        <div class="loader"></div>
                    </div>
                </div>
            </div>

            <!-- Sub-view: A single discussion thread with replies -->
            <div id="discussionDetail" class="d-none">
                <div class="mb-4">
                    <button class="btn btn-outline-secondary" id="backToDiscussions">
                        <i class="bi bi-arrow-left me-2"></i>Retour aux discussions
                    </button>
                </div>

                <!-- Original Post -->
                <div class="card card-modern mb-4">
                    <div class="card-body">
                        <h3 id="threadTitle" style="color: var(--brand)"></h3>
                        <p class="text-muted border-bottom pb-2 mb-3">
                            <!-- ID pour le Popover de profil -->
                            Par <strong id="threadAuthor"></strong> le
                            <span id="threadDate"></span>
                        </p>
                        <div id="threadContent" class="ql-snow">
                            <div class="ql-editor"></div>
                        </div>
                    </div>
                </div>

                <!-- Replies Section -->
                <h4 class="mb-3">Réponses</h4>
                <div id="repliesContainer" class="d-flex flex-column gap-3 mb-4">
                    <!-- Replies will be loaded here -->
                </div>

                <!-- Reply Editor -->
                <div class="card card-modern">
                    <div class="card-body">
                        <h5 class="mb-3">Votre réponse</h5>
                        <form id="replyForm">
                            <!-- Quill editor for the reply -->
                            <div id="replyEditor" style="min-height: 150px"></div>
                            <button type="submit" class="btn btn-primary mt-3">
                                Publier la réponse
                            </button>
                        </form>
                    </div>
                </div>
            </div>
        </div>


        <!--
        <div id="aiConversationsSection" class="d-none view-content">
            <div class="ai-conversations-wrapper d-flex">
                <div class="ai-conversations-sidebar p-3 border-end">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h6 class="mb-0"><i class="bi bi-chat-square-text"></i> Conversations</h6>
                        <button id="newAIConversationBtn" class="btn btn-sm btn-primary">
                            <i class="bi bi-plus"></i> New
                        </button>
                    </div>
                    <div id="aiConversationList" class="list-group small overflow-auto" style="max-height: 75vh;">
                    
                    </div>
                </div>
                <div class="ai-conversation-main flex-grow-1 p-4">
                    <div id="aiConversationContent" class="overflow-auto" style="height:75vh;">
                        <p class="text-muted">Select or start a new AI conversation from the sidebar.</p>
                    </div>
                </div>
            </div>
        </div>-->

        <div id="ai-chatsSection" class="d-none view-content">
            <div class="ai-conversations-wrapper d-flex">
                <!-- Sidebar -->
                <div class="ai-conversations-sidebar p-3 border-end">
                    <div class="d-flex justify-content-between align-items-center mb-3">
                        <h6 class="mb-0"><i class="bi bi-chat-dots"></i> Conversations</h6>
                        <button id="newAIConversationBtn" class="btn btn-sm btn-primary">
                            <i class="bi bi-plus-lg"></i>
                        </button>
                    </div>
                    <div id="aiConversationList" class="list-group small overflow-auto" style="max-height: 75vh;">
                        <!-- Loaded dynamically -->
                    </div>
                </div>

                <!-- Chat area -->
                <div class="ai-conversation-main flex-grow-1 d-flex flex-column">
                    <div id="aiConversationContent" class="flex-grow-1 overflow-auto p-4" style="height: 75vh;">
                        <p class="text-muted text-center mt-5">Select or start a new conversation to chat with FPN AI.
                        </p>
                    </div>

                    <!-- Input box -->
                    <div class="ai-chat-input border-top p-3 bg-light">
                        <div class="input-group">
                            <input id="aiMessageInput" type="text" class="form-control"
                                placeholder="Type a message..." />
                            <button id="sendAIMessageBtn" class="btn btn-success">
                                <span class="send-text">Send</span>
                                <span class="thinking-text d-none">
                                    <span class="spinner-border spinner-border-sm me-1" role="status"></span>
                                    AI Writing...
                                </span>
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>


        <!-- ============================================ -->
        <!-- INBOX / MESSAGERIE UNIFIÉE (PRIVÉ + GROUPES) -->
        <!-- ============================================ -->

        <div id="inboxView" class="view-content d-none">
            <!-- ================== Header avec onglets ================== -->
            <div class="d-flex justify-content-between align-items-center mb-4">
                <h2 style="color: var(--brand); font-weight: 700">
                    <i class="bi bi-chat-dots-fill me-2"></i>Messagerie
                </h2>
                <div class="d-flex gap-2">
                    <button class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#newMessageModal">
                        <i class="bi bi-chat-left-text me-2"></i>Nouveau message
                    </button>
                    <button class="btn btn-success" data-bs-toggle="modal" data-bs-target="#createGroupModal">
                        <i class="bi bi-people-fill me-2"></i>Créer un groupe
                    </button>
                </div>
            </div>

            <!-- ================== Onglets Messages/Groupes ================== -->
            <ul class="nav nav-tabs mb-4" id="messagingTabs" role="tablist">
                <li class="nav-item" role="presentation">
                    <button class="nav-link active" id="private-tab" data-bs-toggle="tab"
                        data-bs-target="#privateMessages" type="button" role="tab">
                        <i class="bi bi-chat-left-text me-2"></i>Messages privés
                        <span id="privateMessagesBadge" class="badge bg-danger ms-2 d-none">0</span>
                    </button>
                </li>
                <li class="nav-item" role="presentation">
                    <button class="nav-link" id="groups-tab" data-bs-toggle="tab" data-bs-target="#groupMessages"
                        type="button" role="tab">
                        <i class="bi bi-people-fill me-2"></i>Groupes
                        <span id="groupMessagesBadge" class="badge bg-success ms-2 d-none">0</span>
                    </button>
                </li>
            </ul>

            <!-- ================== Contenu des onglets ================== -->
            <div class="tab-content" id="messagingTabContent">

                <!-- ========== ONGLET MESSAGES PRIVÉS ========== -->
                <div class="tab-pane fade show active" id="privateMessages" role="tabpanel">
                    <div id="inboxList">
                        <div id="inboxThreadsContainer" class="d-flex flex-column gap-3">
                            <div class="text-center p-5">
                                <div class="spinner-border text-primary"></div>
                                <p class="mt-3">Chargement des conversations...</p>
                            </div>
                        </div>
                    </div>

                    <!-- Sous-vue: Détail du message privé -->
                    <div id="inboxDetailView" class="d-none">
                        <button class="btn btn-outline-secondary mb-4" id="backToInboxList">
                            <i class="bi bi-arrow-left me-2"></i>Retour aux messages
                        </button>

                        <div class="card card-modern">
                            <!-- Header avec présence -->
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <div class="d-flex align-items-center">
                                    <div class="position-relative me-2">
                                        <img id="recipientAvatar" src="" alt="Avatar" class="rounded-circle"
                                            style="width: 40px; height: 40px; object-fit: cover;">
                                        <span class="presence-indicator presence-offline" id="recipientPresence"></span>
                                    </div>
                                    <div>
                                        <h5 class="card-title mb-0" id="inboxThreadTitle">Conversation</h5>
                                        <small class="text-muted" id="inboxRecipientName"></small>
                                        <div id="recipientStatus" class="text-muted" style="font-size: 0.75rem;"></div>
                                    </div>
                                </div>
                                <button class="btn btn-sm btn-outline-primary" id="toggleSearchBtn">
                                    <i class="bi bi-search"></i> Rechercher
                                </button>
                            </div>

                            <!-- Barre de recherche -->
                            <div class="search-container d-none" id="searchContainer">
                                <div class="search-input-wrapper">
                                    <input type="text" id="messageSearchInput"
                                        placeholder="Rechercher dans la conversation..." class="form-control">
                                    <i class="bi bi-search search-icon"></i>
                                </div>
                                <div class="search-nav">
                                    <button onclick="navigateToSearchResult(-1)" title="Précédent">
                                        <i class="bi bi-chevron-up"></i>
                                    </button>
                                    <button onclick="navigateToSearchResult(1)" title="Suivant">
                                        <i class="bi bi-chevron-down"></i>
                                    </button>
                                </div>
                                <span id="searchResultsCount" class="text-muted small"></span>
                                <button class="btn btn-sm btn-outline-secondary" onclick="closeSearch()">
                                    <i class="bi bi-x"></i>
                                </button>
                            </div>

                            <!-- Messages épinglés -->
                            <div id="pinnedMessagesContainer" class="d-none"></div>

                            <!-- Zone de messages -->
                            <div class="card-body chat-container grid-pattern"
                                style="max-height: 50vh; overflow-y: auto; position: relative;">
                                <div id="typingIndicator" class="typing-indicator d-none">
                                    <span id="typingUserName"></span> est en train d'écrire
                                    <span class="typing-dot"></span>
                                    <span class="typing-dot"></span>
                                    <span class="typing-dot"></span>
                                </div>
                                <div id="messageLogContainer" class="d-flex flex-column gap-3"></div>
                            </div>

                            <!-- Formulaire de réponse -->
                            <div class="card-footer">
                                <form id="replyMessageForm" class="d-flex gap-2">
                                    <input type="text" id="messageInput" class="form-control"
                                        placeholder="Écrire un message..." autocomplete="off" required>
                                    <button type="submit" class="btn btn-primary">
                                        <i class="bi bi-send-fill"></i>
                                    </button>
                                </form>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- ========== ONGLET GROUPES ========== -->
                <div class="tab-pane fade" id="groupMessages" role="tabpanel">
                    <div id="groupsList">
                        <div id="groupsListContainer" class="d-flex flex-column gap-3">
                            <div class="text-center p-5">
                                <div class="spinner-border text-success"></div>
                                <p class="mt-3">Chargement des groupes...</p>
                            </div>
                        </div>
                    </div>

                    <!-- Sous-vue: Chat de groupe -->
                    <div id="groupChatView" class="d-none">
                        <button class="btn btn-outline-secondary mb-4" id="backToGroupsList">
                            <i class="bi bi-arrow-left me-2"></i>Retour aux groupes
                        </button>

                        <div class="card card-modern">
                            <!-- Header du groupe -->
                            <div class="card-header d-flex justify-content-between align-items-center">
                                <div class="d-flex align-items-center">
                                    <div class="me-3">
                                        <h5 class="card-title mb-0" id="groupChatTitle">Groupe</h5>
                                        <small class="text-muted" id="groupMemberCount">0 membres</small>
                                    </div>
                                </div>
                                <div class="d-flex gap-2">
                                    <button class="btn btn-sm btn-outline-secondary" id="groupSettingsBtn">
                                        <i class="bi bi-gear-fill"></i> Paramètres
                                    </button>
                                    <button class="btn btn-sm btn-outline-success" data-bs-toggle="modal"
                                        data-bs-target="#inviteMembersModal">
                                        <i class="bi bi-person-plus-fill"></i> Inviter
                                    </button>
                                </div>
                            </div>

                            <!-- Zone de messages du groupe -->
                            <div class="card-body chat-container grid-pattern"
                                style="max-height: 60vh; overflow-y: auto; position: relative;">
                                <div id="groupMessagesContainer" class="d-flex flex-column gap-3"></div>
                            </div>

                            <!-- Formulaire d'envoi -->
                            <div class="card-footer">
                                <form id="groupMessageForm" class="d-flex gap-2">
                                    <input type="text" id="groupMessageInput" class="form-control"
                                        placeholder="Écrire un message au groupe..." autocomplete="off" required>
                                    <button type="submit" class="btn btn-success">
                                        <i class="bi bi-send-fill"></i>
                                    </button>
                                </form>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- ============================================ -->
        <!-- MODAL: NOUVEAU MESSAGE PRIVÉ -->
        <!-- ============================================ -->
        <div class="modal fade" id="newMessageModal" tabindex="-1">
            <div class="modal-dialog modal-dialog-centered">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">
                            <i class="bi bi-chat-left-text me-2"></i>Démarrer une conversation
                        </h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                    </div>
                    <form id="newMessageForm">
                        <div class="modal-body">
                            <div class="mb-3">
                                <label for="recipientSearch" class="form-label">Destinataire</label>
                                <input type="text" id="recipientSearch" class="form-control"
                                    placeholder="Rechercher par nom ou email" required autocomplete="off">
                                <input type="hidden" id="recipientId" required>
                                <div id="recipientSearchResults" class="list-group mt-2 shadow-sm position-absolute"
                                    style="z-index: 99999; display: none; max-height: 200px; overflow-y: auto;"></div>
                            </div>
                            <div class="mb-3">
                                <label for="messageSubject" class="form-label">Sujet</label>
                                <input type="text" id="messageSubject" class="form-control"
                                    placeholder="Ex: Question sur le cours" required>
                            </div>
                            <div class="mb-3">
                                <label for="initialMessageContent" class="form-label">Message</label>
                                <textarea id="initialMessageContent" class="form-control" rows="3"
                                    placeholder="Votre message..." required></textarea>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Annuler</button>
                            <button type="submit" class="btn btn-primary" id="sendMessageButton" disabled>
                                <i class="bi bi-send-fill me-2"></i>Envoyer
                            </button>
                        </div>
                    </form>
                </div>
            </div>
        </div>

        <!-- ============================================ -->
        <!-- MODAL: CRÉER UN GROUPE -->
        <!-- ============================================ -->
        <div class="modal fade" id="createGroupModal" tabindex="-1">
            <div class="modal-dialog modal-dialog-centered">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">
                            <i class="bi bi-people-fill me-2"></i>Créer un nouveau groupe
                        </h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                    </div>
                    <form id="createGroupForm">
                        <div class="modal-body">
                            <div class="mb-3">
                                <label for="groupName" class="form-label">Nom du groupe *</label>
                                <input type="text" id="groupName" class="form-control" placeholder="Ex: Projet ML 2025"
                                    required>
                            </div>
                            <div class="mb-3">
                                <label for="groupDescription" class="form-label">Description</label>
                                <textarea id="groupDescription" class="form-control" rows="3"
                                    placeholder="Décrivez l'objectif de ce groupe..."></textarea>
                            </div>
                            <div class="alert alert-info mb-0">
                                <i class="bi bi-info-circle me-2"></i>
                                <small>Vous pourrez inviter des membres après la création.</small>
                            </div>
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Annuler</button>
                            <button type="submit" class="btn btn-success">
                                <i class="bi bi-plus-circle me-2"></i>Créer
                            </button>
                        </div>
                    </form>
                </div>
            </div>
        </div>

        <!-- ============================================ -->
        <!-- MODAL: INVITER DES MEMBRES -->
        <!-- ============================================ -->
        <div class="modal fade" id="inviteMembersModal" tabindex="-1">
            <div class="modal-dialog modal-dialog-centered">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">
                            <i class="bi bi-person-plus-fill me-2"></i>Inviter des membres
                        </h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                    </div>
                    <form id="inviteMembersForm">
                        <div class="modal-body">
                            <div class="mb-3">
                                <label for="memberSearch" class="form-label">Rechercher un utilisateur</label>
                                <input type="text" id="memberSearch" class="form-control" placeholder="Nom ou email..."
                                    autocomplete="off">
                                <div id="memberSearchResults" class="list-group mt-2"
                                    style="display: none; max-height: 200px; overflow-y: auto;"></div>
                            </div>

                            <div id="selectedMemberDisplay" class="alert alert-success d-none mb-3">
                                <strong>Sélectionné:</strong> <span id="selectedMemberName"></span>
                            </div>

                            <div class="mb-3">
                                <label for="invitationMessage" class="form-label">Message d'invitation</label>
                                <textarea id="invitationMessage" class="form-control" rows="2"
                                    placeholder="Rejoignez notre groupe !"></textarea>
                            </div>

                            <input type="hidden" id="selectedMemberId">
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Annuler</button>
                            <button type="submit" class="btn btn-success" id="sendInviteBtn" disabled>
                                <i class="bi bi-send-fill me-2"></i>Envoyer l'invitation
                            </button>
                        </div>
                    </form>
                </div>
            </div>
        </div>

        <!-- ============================================ -->
        <!-- MODAL: PARAMÈTRES DU GROUPE -->
        <!-- ============================================ -->
        <div class="modal fade" id="groupSettingsModal" tabindex="-1">
            <div class="modal-dialog modal-dialog-centered modal-lg">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">
                            <i class="bi bi-gear-fill me-2"></i>Paramètres du groupe
                        </h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                    </div>
                    <div class="modal-body">
                        <ul class="nav nav-tabs mb-3" id="groupSettingsTabs" role="tablist">
                            <li class="nav-item" role="presentation">
                                <button class="nav-link active" id="general-tab" data-bs-toggle="tab"
                                    data-bs-target="#general" type="button">
                                    <i class="bi bi-info-circle me-1"></i>Général
                                </button>
                            </li>
                            <li class="nav-item" role="presentation">
                                <button class="nav-link" id="members-tab" data-bs-toggle="tab" data-bs-target="#members"
                                    type="button">
                                    <i class="bi bi-people me-1"></i>Membres
                                </button>
                            </li>
                        </ul>

                        <div class="tab-content">
                            <!-- Onglet Général -->
                            <div class="tab-pane fade show active" id="general" role="tabpanel">
                                <div class="mb-3">
                                    <label for="settingsGroupName" class="form-label">Nom du groupe</label>
                                    <input type="text" id="settingsGroupName" class="form-control">
                                </div>
                                <div class="mb-3">
                                    <label for="settingsGroupDescription" class="form-label">Description</label>
                                    <textarea id="settingsGroupDescription" class="form-control" rows="3"></textarea>
                                </div>
                                <div class="d-flex gap-2">
                                    <button type="button" class="btn btn-danger btn-sm" onclick="deleteCurrentGroup()">
                                        <i class="bi bi-trash me-1"></i>Supprimer le groupe
                                    </button>
                                </div>
                            </div>

                            <!-- Onglet Membres -->
                            <div class="tab-pane fade" id="members" role="tabpanel">
                                <div id="groupMembersList" class="list-group">
                                    <div class="text-center p-3">
                                        <div class="spinner-border spinner-border-sm"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Fermer</button>
                        <button type="button" class="btn btn-success" id="saveGroupSettingsBtn">
                            <i class="bi bi-check-circle me-2"></i>Sauvegarder
                        </button>
                    </div>
                </div>
            </div>
        </div>



        <!-- Notifications View (Full Page) -->
        <div id="notificationsView" class="view-content d-none">
            <div class="d-flex justify-content-between align-items-center mb-4">
                <h2 style="color: var(--brand); font-weight: 700">
                    Toutes les notifications
                </h2>
            </div>
            <div class="card card-modern">
                <div class="card-body">
                    <div id="fullNotifList" class="list-group list-group-flush">
                        <!-- Full notification history will be loaded here -->
                    </div>
                </div>
            </div>
        </div>


        <!-- ==== ÉDUCATION & MÉDIAS VIEW (TMDB-Enhanced Advanced) ==== -->
        <div id="edu-mediaView" class="view-content d-none">
            <div class="container-fluid py-4">
                <!-- Advanced Header with Stats -->
                <div class="row mb-4">
                    <div class="col-md-8">
                        <div class="d-flex align-items-center gap-3 mb-3">
                            <div class="edu-media-icon-wrapper">
                                <i class="bi bi-film"></i>
                            </div>
                            <div>
                                <h2 class="h3 mb-1 fw-bold">Éducation & Médias</h2>
                                <p class="text-muted mb-0">Découvrez des contenus éducatifs adaptés à vos besoins</p>
                            </div>
                        </div>

                        <!-- Quick Stats -->
                        <div class="d-flex gap-4 edu-media-stats">
                            <div class="stat-item">
                                <div class="stat-value" id="totalMediaCount">0</div>
                                <div class="stat-label">Médias disponibles</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="activeFilterCount">0</div>
                                <div class="stat-label">Filtre actif</div>
                            </div>
                            <div class="stat-item">
                                <div class="stat-value" id="lastUpdated">-</div>
                                <div class="stat-label">Dernière mise à jour</div>
                            </div>
                        </div>
                    </div>
                    <div class="col-md-4">
                        <div class="d-flex flex-column gap-3">
                            <!-- Advanced Filter Row -->
                            <div class="d-flex gap-2 flex-wrap">
                                <select class="form-select edu-media-filter" id="eduMediaFilter">
                                    <option value="">Tous les sujets</option>
                                    <option value="history">📜 Histoire & Civilisation</option>
                                    <option value="science">🔬 Sciences & Découverte</option>
                                    <option value="lang">🌍 Langues & Culture</option>
                                    <option value="tech">💻 Technologie & Innovation</option>
                                    <option value="art">🎨 Arts & Création</option>
                                    <option value="nature">🌿 Nature & Environnement</option>
                                </select>

                                <select class="form-select edu-media-sort" id="eduMediaSort" style="max-width: 160px;">
                                    <option value="popularity">Popularité</option>
                                    <option value="release_date">Date de sortie</option>
                                    <option value="vote_average">Meilleures notes</option>
                                    <option value="title">Ordre alphabétique</option>
                                </select>
                            </div>

                            <!-- Action Buttons -->
                            <div class="d-flex gap-2">
                                <button class="btn btn-primary flex-fill" id="eduMediaRefresh">
                                    <i class="bi bi-arrow-clockwise"></i>
                                    <span class="d-none d-md-inline">Actualiser</span>
                                </button>
                                <button class="btn btn-outline-primary" id="eduMediaShuffle"
                                    title="Découvrir aléatoirement">
                                    <i class="bi bi-shuffle"></i>
                                </button>
                                <button class="btn btn-outline-secondary" id="eduMediaViewToggle"
                                    title="Changer la vue">
                                    <i class="bi bi-grid-3x3-gap"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Search Bar -->
                <div class="row mb-4">
                    <div class="col-12">
                        <div class="edu-media-search-wrapper">
                            <i class="bi bi-search"></i>
                            <input type="text" class="form-control edu-media-search" id="eduMediaSearch"
                                placeholder="Rechercher un film, série ou documentaire...">
                            <div class="search-actions">
                                <button class="btn btn-sm btn-outline-secondary" id="clearSearch"
                                    style="display: none;">
                                    <i class="bi bi-x"></i>
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- View Toggle & Progress -->
                <div class="d-flex justify-content-between align-items-center mb-3">
                    <div class="view-toggle-buttons">
                        <button class="btn btn-sm btn-outline-primary active" data-view="grid">
                            <i class="bi bi-grid-3x3-gap"></i> Grille
                        </button>
                        <button class="btn btn-sm btn-outline-primary" data-view="list">
                            <i class="bi bi-list-ul"></i> Liste
                        </button>
                        <button class="btn btn-sm btn-outline-primary" data-view="cards">
                            <i class="bi bi-card-image"></i> Cartes
                        </button>
                    </div>

                    <div class="d-flex align-items-center gap-3">
                        <div class="progress edu-media-progress" style="width: 120px; height: 6px;">
                            <div class="progress-bar" id="loadProgress"></div>
                        </div>
                        <small class="text-muted" id="mediaCountText">Chargement...</small>
                    </div>
                </div>

                <!-- Loader with Skeleton -->
                <div class="d-none" id="eduMediaLoader">
                    <div class="text-center py-5">
                        <div class="spinner-border text-primary mb-3"></div>
                        <p class="text-muted mb-4">Chargement des médias éducatifs...</p>

                        <!-- Skeleton Grid -->
                        <div class="row g-4" id="skeletonGrid">
                            ${Array.from({length: 8}, () => `
                            <div class="col-xl-3 col-lg-4 col-md-6">
                                <div class="edu-media-skeleton">
                                    <div class="edu-media-skeleton-poster"></div>
                                    <div class="edu-media-skeleton-content">
                                        <div class="edu-media-skeleton-line long"></div>
                                        <div class="edu-media-skeleton-line short"></div>
                                        <div class="edu-media-skeleton-line medium"></div>
                                        <div class="d-flex gap-2 mt-2">
                                            <div class="edu-media-skeleton-tag"></div>
                                            <div class="edu-media-skeleton-tag"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            `).join('')}
                        </div>
                    </div>
                </div>

                <!-- Main Content Grid -->
                <div class="edu-media-content">
                    <!-- Grid View -->
                    <div class="row g-4 edu-media-grid view-active" id="eduMediaGrid"></div>

                    <!-- List View -->
                    <div class="edu-media-list d-none" id="eduMediaList"></div>

                    <!-- Card View -->
                    <div class="row g-4 edu-media-cards d-none" id="eduMediaCards"></div>
                </div>

                <!-- Empty State -->
                <div class="text-center py-5 d-none" id="eduMediaEmpty">
                    <div class="empty-state-icon">
                        <i class="bi bi-film"></i>
                    </div>
                    <h4 class="mt-3">Aucun média trouvé</h4>
                    <p class="text-muted mb-4">Essayez de modifier vos filtres ou votre recherche.</p>
                    <button class="btn btn-primary" id="resetFilters">
                        <i class="bi bi-arrow-counterclockwise"></i> Réinitialiser les filtres
                    </button>
                </div>

                <!-- Load More -->
                <div class="text-center mt-5 d-none" id="loadMoreContainer">
                    <button class="btn btn-outline-primary" id="loadMoreMedia">
                        <i class="bi bi-plus-circle"></i> Charger plus de médias
                    </button>
                </div>
            </div>
        </div>

        <!-- Musique View (index.html) -->
        <div id="musicView" class="view-content d-none">
            <div class="music-header d-flex justify-content-between align-items-center mb-4">
                <div>
                    <h2 class="fw-bold" style="color: var(--brand)">🎶 Musique & Média Personnel</h2>
                    <p class="text-muted">Gérez et écoutez vos playlists YouTube et votre historique.</p>
                </div>
                <button class="btn btn-primary" id="connectYouTubeBtn">
                    <i class="bi bi-youtube me-2"></i> Connecter mon compte YouTube
                </button>
            </div>

            <!-- Barre de recherche -->
            <div class="input-group mb-4">
                <input type="text" class="form-control" id="musicSearchInput"
                    placeholder="Rechercher des playlists, artistes ou vidéos..." />
                <button class="btn btn-outline-secondary" id="musicSearchBtn">
                    <i class="bi bi-search"></i>
                </button>
            </div>

            <div id="musicContent" class="row g-4">
                <!-- Contenu initial/playlists -->
                <div class="col-12 text-center py-5" id="musicInitialMessage">
                    <i class="bi bi-music-note-beamed fs-1 text-muted d-block mb-3"></i>
                    <p class="text-muted">Chargement du contenu populaire...</p>
                </div>
            </div>

            <!-- Zone pour l'historique de lecture ou les détails de la playlist -->
            <div id="playlistDetail" class="mt-5 d-none">
                <button class="btn btn-outline-secondary mb-4" id="backToMusicList"><i
                        class="bi bi-arrow-left me-2"></i> Retour aux playlists</button>
                <h3 class="fw-bold mb-4" id="playlistTitle"></h3>
                <div id="playlistVideosGrid" class="row g-4">
                    <!-- Les vidéos de la playlist seront affichées ici -->
                </div>
            </div>
        </div>


        <!-- La balise du lecteur doit être placée en dehors de #mainContent pour la fixation -->
        <div id="musicPlayerFixed" class="music-player-fixed" style="display: none;">
            <!-- Conteneur invisible pour l'API YouTube IFrame Player -->
            <div id="playerEmbed"
                style="width: 1px; height: 1px; overflow: hidden; position: absolute; top: 0; left: 0;"></div>

            <div class="player-left d-flex align-items-center gap-3">
                <img id="trackThumbnail" src="" class="rounded-3 shadow" width="60" height="60" alt=""
                    onerror="this.style.display='none'">
                <div>
                    <div id="trackTitle" class="fw-semibold text-truncate" style="max-width: 150px;">Aucun média chargé
                    </div>
                    <div id="trackArtist" class="text-muted small text-truncate" style="max-width: 150px;">...</div>
                </div>
            </div>

            <div class="player-center d-flex flex-column align-items-center">
                <div class="player-controls d-flex align-items-center gap-3">
                    <button class="btn-player" id="btnPrev" title="Piste précédente"><i
                            class="bi bi-skip-start-fill"></i></button>
                    <button class="btn-player play" id="btnPlay" title="Lecture / Pause"><i
                            class="bi bi-play-circle-fill"></i></button>
                    <button class="btn-player" id="btnNext" title="Piste suivante"><i
                            class="bi bi-skip-end-fill"></i></button>
                </div>
                <div class="progress-container d-flex align-items-center gap-2 mt-2">
                    <small id="currentTime">0:00</small>
                    <input type="range" id="progressBar" min="0" max="100" value="0">
                    <small id="totalTime">0:00</small>
                </div>
            </div>

            <div class="player-right d-flex align-items-center gap-2">
                <button class="btn-player" id="btnVolumeToggle" title="Muet">
                    <i class="bi bi-volume-up"></i>
                </button>
                <input type="range" id="volumeControl" min="0" max="1" step="0.01" value="0.8" style="width: 80px;">
            </div>
        </div>

        <style>
            /* ======================================= */
            /* Styles pour le Lecteur Fixe (Spotify-like) */
            /* ======================================= */

            .music-player-fixed {
                /* Fixation au bas de la page */
                position: fixed;
                bottom: 0;
                left: 0;
                right: 0;
                width: 100%;
                /* Look & Feel (Light/Dark Theme) */
                background: var(--surface);
                /* Fond clair par défaut */
                color: var(--text);
                border-top: 2px solid var(--border);
                box-shadow: 0 -5px 20px rgba(0, 0, 0, 0.15);

                /* Layout */
                display: flex;
                justify-content: space-between;
                align-items: center;
                padding: 10px 25px;
                z-index: 1050;
                /* Au-dessus de tous les autres éléments (modals, etc.) */
                min-height: 80px;
                transition: background 0.3s, color 0.3s;
            }

            [data-theme='dark'] .music-player-fixed {
                background: #121212;
                color: #fff;
                border-top: 1px solid #222;
                box-shadow: 0 -3px 10px rgba(0, 0, 0, 0.4);
            }

            /* Assurer que le contenu principal laisse de la place */
            .main-content {
                padding-bottom: 90px;
                /* Plus grand que la hauteur du lecteur */
            }

            /* Boutons de contrôle */
            .player-controls .btn-player {
                background: none;
                border: none;
                color: var(--text);
                font-size: 1.4rem;
                padding: 0 8px;
                transition: color 0.2s, transform 0.2s;
            }

            [data-theme='dark'] .player-controls .btn-player {
                color: #ccc;
            }

            .player-controls .btn-player:hover {
                color: var(--accent);
                transform: scale(1.1);
            }

            .player-controls .btn-player.play i {
                font-size: 2.2rem;
                color: var(--accent);
            }

            /* Barre de progression et volume */
            .progress-container {
                width: 300px;
            }

            .music-player-fixed #progressBar,
            .music-player-fixed #volumeControl {
                -webkit-appearance: none;
                appearance: none;
                height: 6px;
                background: var(--border);
                border-radius: 3px;
                cursor: pointer;
                flex-grow: 1;
                margin: 0;
            }

            .music-player-fixed #progressBar::-webkit-slider-thumb,
            .music-player-fixed #volumeControl::-webkit-slider-thumb {
                -webkit-appearance: none;
                appearance: none;
                width: 12px;
                height: 12px;
                border-radius: 50%;
                background: var(--accent);
                cursor: pointer;
                box-shadow: 0 0 2px rgba(0, 0, 0, 0.5);
            }

            /* Surcharge de la couleur d'accentuation pour la barre de progression (Chrome/Edge/FF) */
            .music-player-fixed input[type="range"] {
                accent-color: var(--accent);
            }

            /* Le conteneur de l'image pour le player YT */
            #trackThumbnail {
                object-fit: cover;
                border: 1px solid var(--border);
            }

            /* Styles pour les cartes de playlist */
            .playlist-card {
                cursor: pointer;
                transition: transform 0.2s;
            }

            .playlist-card:hover {
                transform: translateY(-5px);
                box-shadow: 0 10px 20px rgba(0, 0, 0, 0.1);
            }

            .playlist-card .card-title {
                min-height: 40px;
            }

            .playlist-card .card-body {
                padding: 1rem;
            }

            /* Vidéo de la playlist */
            .playlist-video-item {
                cursor: pointer;
                padding: 10px;
                border-radius: 8px;
                transition: background-color 0.2s;
            }

            .playlist-video-item:hover {
                background-color: var(--soft);
            }

            .playlist-video-item.active {
                background-color: var(--accent-light);
                border: 1px solid var(--accent);
            }
        </style>
        <!-- Advanced Video/Trailer Modal -->
        <div class="modal fade edu-media-modal" id="eduMediaModal" tabindex="-1">
            <div class="modal-dialog modal-xl modal-dialog-centered">
                <div class="modal-content">
                    <div class="modal-header">
                        <div class="modal-title-wrapper">
                            <h5 class="modal-title" id="eduMediaTitle"></h5>
                            <div class="modal-subtitle">
                                <span id="eduMediaYear"></span>
                                <span class="mx-2">•</span>
                                <span id="eduMediaRating"></span>
                                <span class="mx-2">•</span>
                                <span id="eduMediaDuration"></span>
                            </div>
                        </div>
                        <div class="modal-actions">
                            <button class="btn btn-sm btn-outline-secondary" id="addToFavorites"
                                title="Ajouter aux favoris">
                                <i class="bi bi-heart"></i>
                            </button>
                            <button class="btn btn-sm btn-outline-secondary" id="shareMedia" title="Partager">
                                <i class="bi bi-share"></i>
                            </button>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                    </div>
                    <div class="modal-body p-0">
                        <!-- Video Player Section -->
                        <div id="eduMediaPlayer" class="ratio ratio-16x9 bg-dark">
                            <div class="player-placeholder">
                                <i class="bi bi-play-circle-fill"></i>
                                <p>Chargement de la bande-annonce...</p>
                            </div>
                        </div>

                        <!-- Media Info Section -->
                        <div class="modal-info-section">
                            <div class="row">
                                <div class="col-md-8">
                                    <div class="info-content">
                                        <h6>Synopsis</h6>
                                        <p id="eduMediaDesc" class="mb-3"></p>

                                        <h6>Détails</h6>
                                        <div class="media-details" id="eduMediaDetails"></div>

                                        <div class="ai-section mt-4">
                                            <h6>Assistant Éducatif IA</h6>
                                            <div class="ai-actions">
                                                <button class="btn btn-primary btn-sm" data-ai-action="explain">
                                                    <i class="bi bi-robot"></i> Expliquer le contexte
                                                </button>
                                                <button class="btn btn-outline-primary btn-sm" data-ai-action="quiz">
                                                    <i class="bi bi-question-circle"></i> Créer un quiz
                                                </button>
                                                <button class="btn btn-outline-primary btn-sm"
                                                    data-ai-action="resources">
                                                    <i class="bi bi-journal-text"></i> Ressources complémentaires
                                                </button>
                                            </div>
                                        </div>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="sidebar-info">
                                        <div class="info-card">
                                            <h6>Informations</h6>
                                            <div class="info-item">
                                                <span class="label">Genre:</span>
                                                <span id="eduMediaGenres"></span>
                                            </div>
                                            <div class="info-item">
                                                <span class="label">Langue:</span>
                                                <span id="eduMediaLanguage"></span>
                                            </div>
                                            <div class="info-item">
                                                <span class="label">Note:</span>
                                                <span id="eduMediaVotes"></span>
                                            </div>
                                        </div>

                                        <div class="similar-media mt-3">
                                            <h6>Contenus similaires</h6>
                                            <div id="similarMedia" class="similar-list"></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Quick View Modal -->
        <div class="modal fade" id="quickViewModal" tabindex="-1">
            <div class="modal-dialog modal-lg">
                <div class="modal-content">
                    <div class="modal-body p-4">
                        <div class="row">
                            <div class="col-md-4">
                                <img id="quickViewPoster" src="" alt="" class="img-fluid rounded">
                            </div>
                            <div class="col-md-8">
                                <h4 id="quickViewTitle"></h4>
                                <p id="quickViewOverview" class="text-muted"></p>
                                <div class="quick-actions">
                                    <button class="btn btn-primary btn-sm" onclick="openFullModalFromQuick()">
                                        <i class="bi bi-play-fill"></i> Voir la bande-annonce
                                    </button>
                                    <button class="btn btn-outline-primary btn-sm" onclick="addToWatchlist()">
                                        <i class="bi bi-bookmark"></i> Watchlist
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        <!-- Modal for Creating a New Discussion -->
        <div class="modal fade" id="newDiscussionModal" tabindex="-1" aria-labelledby="newDiscussionModalLabel"
            aria-hidden="true">
            <div class="modal-dialog modal-lg modal-dialog-centered">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="newDiscussionModalLabel">
                            Démarrer une nouvelle discussion
                        </h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <form id="newDiscussionForm">
                            <div class="mb-3">
                                <label for="newDiscussionTitle" class="form-label">Titre du sujet</label>
                                <input type="text" class="form-control" id="newDiscussionTitle" required />
                            </div>
                            <div class="mb-3">
                                <label class="form-label">Votre question ou sujet</label>
                                <!-- Quill editor will be mounted here -->
                                <div id="newDiscussionEditor" style="min-height: 200px"></div>
                            </div>
                        </form>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                            Annuler
                        </button>
                        <button type="submit" form="newDiscussionForm" class="btn btn-primary">
                            Publier
                        </button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Mes notes View -->
        <div id="notesView" class="view-content d-none">
            <h2 class="mb-4" style="color: var(--brand); font-weight: 700">
                Mes notes
            </h2>
            <form id="noteForm" class="mb-4">
                <div class="mb-3">
                    <input id="noteTitle" class="form-control" placeholder="Titre de la note" required />
                </div>
                <div class="mb-3">
                    <textarea id="noteContent" class="form-control" rows="4" placeholder="Contenu de la note"
                        required></textarea>
                </div>
                <button class="btn btn-primary" type="submit">
                    Ajouter une note
                </button>
            </form>
            <div id="notesList" class="row g-4"></div>
        </div>

        <!-- NOUVELLE Vue: Guide de l'Éditeur de Code -->
        <!-- NOUVELLE Vue: Guide des Éditeurs -->
        <div id="codeeditor-guideView" class="view-content d-none">
            <h2 class="mb-4" style="color: var(--brand); font-weight: 700">
                Centre de Guides des Éditeurs
            </h2>

            <div class="row g-4">
                <!-- Bloc: Guide Sandbox -->
                <div class="col-md-6">
                    <div class="card card-modern p-5 text-center h-100">
                        <i class="bi bi-robot fs-1 mb-3" style="color: var(--brand);"></i>
                        <h4 class="mb-3">Éditeur de Code Sandbox</h4>
                        <p class="text-muted">
                            Testez rapidement du code <strong>HTML, CSS, JavaScript</strong> dans un environnement isolé
                            basé sur le moteur
                            <strong>VS Code (Monaco Editor)</strong>.
                        </p>
                        <p>
                            ⚠️ <strong>Attention :</strong> En cliquant sur le bouton ci-dessous, vous quitterez la
                            fenêtre principale pour
                            un environnement en plein écran.
                        </p>
                        <button id="openSandboxBtn" class="btn btn-primary btn-lg mt-3" onclick="openFullSandbox()">
                            <i class="bi bi-box-arrow-up-right me-2"></i> Ouvrir l'Éditeur Complet
                        </button>
                    </div>
                </div>

                <!-- Bloc: Guide UML -->
                <div class="col-md-6">
                    <div class="card card-modern p-5 text-center h-100">
                        <i class="bi bi-diagram-3 fs-1 mb-3" style="color: var(--brand);"></i>
                        <h4 class="mb-3">Éditeur UML Professionnel</h4>
                        <p class="text-muted">
                            Créez des <strong>diagrammes UML</strong> avancés : classes, interfaces, héritages,
                            agrégations et dépendances.
                            Personnalisez les couleurs, images, attributs et opérations, avec un historique complet.
                        </p>
                        <p>
                            Profitez d'une interface fluide, d'une <strong>sauvegarde automatique</strong>, d'un
                            mini-map, et
                            d'exports en <strong>JSON/PNG</strong>.
                        </p>
                        <button id="openUmlEditorBtn" class="btn btn-primary btn-lg mt-3" onclick="openFullUmlEditor()">
                            <i class="bi bi-diagram-3 me-2"></i> Ouvrir l'Éditeur UML
                        </button>
                    </div>
                </div>
            </div>
        </div>


        <!-- NOUVELLE Vue: Conteneur du Sandbox Isolée (pour la page vide) -->
        <div id="codeEditorSandboxView" class="view-content d-none">
            <!-- L'iframe chargera la page sandbox.html -->
        </div>

        <div id="umlEditorFullView" class="view-content d-none">
            <!-- L'iframe chargera la page sandbox.html -->
        </div>

        <!-- Suivi des progrès View -->
        <div id="progressView" class="view-content d-none">
            <h2 class="mb-4" style="color: var(--brand); font-weight: 700">
                Votre progression
            </h2>

            <div class="row g-4">
                <!-- Main Progress Donut and KPIs -->
                <div class="col-xl-5">
                    <div class="card card-modern h-100">
                        <div class="card-body d-flex flex-column">
                            <h5 class="card-title mb-3">Progression globale</h5>
                            <div class="flex-grow-1 d-flex align-items-center justify-content-center"
                                style="min-height: 250px">
                                <canvas id="progressDonutChart"></canvas>
                            </div>
                            <div class="row text-center mt-3 pt-3 border-top">
                                <div class="col-6">
                                    <h4 id="kpiCompleted" class="mb-0">0</h4>
                                    <small class="text-muted">Cours terminés</small>
                                </div>
                                <div class="col-6">
                                    <h4 id="kpiInProgress" class="mb-0">0</h4>
                                    <small class="text-muted">En cours</small>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Progress by Course -->
                <div class="col-xl-7">
                    <div class="card card-modern h-100">
                        <div class="card-body">
                            <h5 class="card-title mb-3">Progression par cours</h5>
                            <div style="min-height: 400px">
                                <canvas id="progressByCourseChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Recent Activity -->
                <div class="col-12">
                    <div class="card card-modern">
                        <div class="card-body">
                            <h5 class="card-title mb-3">Activité des 7 derniers jours</h5>
                            <div style="min-height: 250px">
                                <canvas id="activityLineChart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Paramètres View -->
        <div id="settingsView" class="view-content d-none">
            <h2 class="mb-4" style="color: var(--brand); font-weight: 700">
                Paramètres
            </h2>

            <!-- Theme Settings -->
            <div class="card card-modern">
                <div class="card-body">
                    <h5 class="card-title mb-3">Préférences d'affichage</h5>
                    <div class="mb-3">
                        <label for="themeSelect" class="form-label">Thème</label>
                        <select id="themeSelect" class="form-select">
                            <option value="light">Clair</option>
                            <option value="dark">Sombre</option>
                            <option value="modern">Moderne</option>
                            <option value="pastel">Pastel</option>
                            <option value="forest">Forêt</option>
                            <option value="ocean">Océan</option>
                            <option value="midnight">Minuit</option>
                            <option value="system">Système</option>
                        </select>
                    </div>
                </div>
            </div>

            <div id="chatSoundSettings" class="mt-4"></div>
            <div class="chatSettingsPanel" id="chatSettingsPanel">
                <h6>Chat Background Pattern</h6>
                <button id="patternGridBtn" class="btn btn-sm btn-outline-primary">Grid Pattern</button>
                <button id="patternWaveBtn" class="btn btn-sm btn-outline-primary">Wave Pattern</button>
            </div>

            <!-- START: NEW BACKGROUND IMAGE SETTINGS -->
            <div class="card card-modern mt-4">
                <div class="card-body">
                    <h5 class="card-title mb-3">Image de fond</h5>
                    <p class="text-muted small">
                        Sélectionnez un fond d'écran pour personnaliser l'interface
                        (visible derrière la barre latérale).
                    </p>
                    <div id="backgroundSelectorGrid" class="row g-2">
                        <!-- Images options will be rendered here by JS -->
                    </div>
                </div>
            </div>

            <!-- START: NEW ACCOUNT SETTINGS SECTION -->
            <div id="accountSettingsWrapper">
                <!-- Account Profile Settings -->
                <div class="card card-modern mt-4">
                    <div class="card-body">
                        <h5 class="card-title mb-4">Profil du compte</h5>

                        <!-- NOUVEAU: Saisie de l'URL de Photo de Profil -->
                        <div class="d-flex align-items-center mb-4 gap-4">
                            <img id="profilePhotoPreview" src="" alt="Photo de profil"
                                style="width:96px;height:96px;border-radius:50%;object-fit:cover;border:4px solid var(--accent)">
                            <div>
                                <label for="photoUrlInput" class="form-label">URL de la photo de profil</label>
                                <input type="url" class="form-control mb-2" id="photoUrlInput"
                                    placeholder="Collez ici l'URL de votre avatar (ex: Gravatar, Imgur, CDN)" />
                                <div class="form-text">
                                    Utilisez une URL HTTPS pour votre photo (PNG, JPG).
                                </div>
                            </div>
                        </div>
                        <!-- FIN NOUVEAU: Saisie de l'URL de Photo de Profil -->

                        <form id="profileSettingsForm">
                            <div class="mb-3">
                                <label for="accountName" class="form-label">Nom complet</label>
                                <input type="text" class="form-control" id="accountName"
                                    placeholder="Votre nom complet" />
                            </div>
                            <div class="mb-3">
                                <label for="accountEmail" class="form-label">Adresse e-mail</label>
                                <input type="email" class="form-control" id="accountEmail"
                                    placeholder="Votre adresse e-mail" disabled />
                                <div class="form-text">
                                    L'adresse e-mail ne peut pas être modifiée.
                                </div>
                            </div>
                            <button type="submit" class="btn btn-primary">
                                Enregistrer les modifications
                            </button>
                        </form>
                    </div>
                </div>
                <!-- Password Settings -->
                <div class="card card-modern mt-4" id="passwordSettingsCard" style="display: none">
                    <div class="card-body">
                        <h5 class="card-title mb-4">Changer le mot de passe</h5>
                        <form id="passwordChangeForm">
                            <div class="mb-3">
                                <label for="newPassword" class="form-label">Nouveau mot de passe</label>
                                <input type="password" class="form-control" id="newPassword" required />
                            </div>
                            <button type="submit" class="btn btn-primary">
                                Mettre à jour le mot de passe
                            </button>
                        </form>
                    </div>
                </div>

                <!-- Danger Zone -->
                <div class="card card-modern mt-4">
                    <div class="card-body">
                        <h5 class="card-title mb-3 text-danger">Zone de danger</h5>
                        <p class="text-muted">
                            Cette action est irréversible. Toutes vos données, y compris vos
                            progrès et vos notes, seront définitivement supprimées.
                        </p>
                        <button class="btn btn-outline-danger" id="btnDeleteAccount">
                            Supprimer mon compte
                        </button>
                    </div>
                </div>
            </div>
            <!-- END: NEW ACCOUNT SETTINGS SECTION -->
        </div>
    </main>

    <!-- Vidéo Modal (Upgraded for Playlists) -->
    <div class="modal fade video-modal" id="videoModal" tabindex="-1">
        <!-- Ajout d'ID pour le plein écran -->
        <div class="modal-dialog modal-fullscreen-lg-down modal-dialog-centered" id="videoModalDialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="videoTitle">Tutoriel vidéo</h5>

                    <!-- NOUVEAU BOUTON PLEIN ÉCRAN VIDEO -->
                    <button class="btn btn-sm btn-outline-secondary me-2 fullscreen-toggle-btn"
                        data-target-dialog="videoModalDialog" title="Plein écran">
                        <i class="bi bi-arrows-fullscreen"></i>
                    </button>
                    <!-- FIN NOUVEAU BOUTON -->

                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body p-2">
                    <div class="row g-2 h-100">
                        <!-- Main Video Player Column (80%) -->
                        <div class="col-lg-9 h-100">
                            <div class="video-container" id="videoContainer"
                                style="padding-bottom: 0; min-height: 0; height: 100%">
                                <!-- Iframe will be inserted here -->
                            </div>
                        </div>
                        <!-- History Panel Column (20%) -->
                        <div class="col-lg-3 h-100 d-none flex-column" id="playlistPanel">
                            <div class="card h-100">
                                <div class="card-body d-flex flex-column p-2">
                                    <!-- START: NEW HEADER -->
                                    <div class="d-flex justify-content-between align-items-center px-2 pt-1 mb-2">
                                        <h6 class="card-title mb-0">Historique</h6>
                                        <button class="btn btn-sm btn-outline-danger" id="clearHistoryBtn"
                                            title="Effacer l'historique">
                                            <i class="bi bi-trash"></i>
                                        </button>
                                    </div>
                                    <!-- END: NEW HEADER -->
                                    <div id="historyQueue" class="list-group list-group-flush flex-grow-1">
                                        <!-- History items will be loaded here -->
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Document Modal -->
    <div class="modal fade document-modal" id="documentModal" tabindex="-1">
        <!-- Ajout d'ID et de modal-xl pour le plein écran -->
        <div class="modal-dialog modal-dialog-centered modal-xl" id="documentModalDialog">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="documentTitle">Document</h5>

                    <!-- NOUVEAU BOUTON PLEIN ÉCRAN DOCUMENT -->
                    <button class="btn btn-sm btn-outline-secondary me-2 fullscreen-toggle-btn"
                        data-target-dialog="documentModalDialog" title="Plein écran">
                        <i class="bi bi-arrows-fullscreen"></i>
                    </button>
                    <!-- FIN NOUVEAU BOUTON -->

                    <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                </div>
                <div class="modal-body p-0">
                    <div class="document-container" id="documentContainer"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Auth Modal -->
    <div class="modal fade" id="modalAuth" tabindex="-1">
        <div class="modal-dialog modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <ul class="nav nav-tabs nav-tabs-modern w-100">
                        <li class="nav-item">
                            <button class="nav-link active" id="signinTab" data-bs-toggle="tab"
                                data-bs-target="#signin">
                                Se connecter
                            </button>
                        </li>
                        <li class="nav-item">
                            <button class="nav-link" id="signupTab" data-bs-toggle="tab" data-bs-target="#signup">
                                Créer un compte
                            </button>
                        </li>
                    </ul>
                </div>
                <div class="modal-body p-4">
                    <div class="tab-content">
                        <div class="tab-pane fade show active" id="signin">
                            <h4 class="text-center mb-4" style="color: var(--brand)">
                                Connectez-vous à votre compte
                            </h4>

                            <button id="googleSignIn" class="btn btn-outline-dark w-100 mb-3 py-2">
                                <i class="bi bi-google me-2"></i> Continuer avec Google
                            </button>

                            <div class="text-center my-3 text-muted">ou</div>

                            <form id="signinForm">
                                <div class="mb-3">
                                    <input id="signinEmail" type="email" class="form-control"
                                        placeholder="Adresse email" required />
                                </div>
                                <div class="mb-3">
                                    <input id="signinPassword" type="password" class="form-control"
                                        placeholder="Mot de passe" required />
                                </div>
                                <button class="btn btn-primary w-100 py-2" type="submit">
                                    Se connecter
                                </button>
                            </form>
                        </div>

                        <div class="tab-pane fade" id="signup">
                            <h4 class="text-center mb-4" style="color: var(--brand)">
                                Créer un nouveau compte
                            </h4>

                            <button id="googleSignup" class="btn btn-outline-dark w-100 mb-3 py-2">
                                <i class="bi bi-google me-2"></i> S'inscrire avec Google
                            </button>

                            <div class="text-center my-3 text-muted">ou</div>

                            <form id="signupForm">
                                <div class="mb-3">
                                    <input id="signupName" type="text" class="form-control" placeholder="Nom complet"
                                        required />
                                </div>
                                <div class="mb-3">
                                    <input id="signupEmail" type="email" class="form-control"
                                        placeholder="Adresse email" required />
                                </div>
                                <div class="mb-3">
                                    <input id="signupPassword" type="password" class="form-control"
                                        placeholder="Mot de passe" required />
                                </div>
                                <button class="btn btn-primary w-100 py-2" type="submit">
                                    Créer un compte
                                </button>
                            </form>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="modal fade" id="editReplyModal" tabindex="-1" aria-labelledby="editReplyModalLabel" aria-hidden="true">
        <div class="modal-dialog modal-lg modal-dialog-centered">
            <div class="modal-content">
                <div class="modal-header">
                    <h5 class="modal-title" id="editReplyModalLabel">
                        Modifier la réponse
                    </h5>
                    <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                </div>
                <div class="modal-body">
                    <form id="editReplyForm">
                        <!-- Hidden input to store the reply's ID -->
                        <input type="hidden" id="editReplyId" />

                        <label class="form-label">Votre réponse</label>
                        <!-- Quill editor for editing the reply -->
                        <div id="editReplyEditor" style="min-height: 200px"></div>
                    </form>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                        Annuler
                    </button>
                    <button type="submit" form="editReplyForm" class="btn btn-primary">
                        Enregistrer les modifications
                    </button>
                </div>
            </div>
        </div>
    </div>
    <!-- END: NEW Edit Reply Modal -->

    <div id="toastContainer" class="position-fixed top-0 end-0 p-3" style="z-index: 1100"></div>

    <!-- Core CodeMirror 6 -->
    <script type="module">
        // Import all CodeMirror dependencies
        import { EditorView, basicSetup } from "https://cdn.jsdelivr.net/npm/codemirror@6.0.1/dist/index.js";
        import { EditorState } from "https://cdn.jsdelivr.net/npm/@codemirror/state@6.4.1/dist/index.js";
        import { javascript } from "https://cdn.jsdelivr.net/npm/@codemirror/lang-javascript@6.2.2/dist/index.js";
        import { html } from "https://cdn.jsdelivr.net/npm/@codemirror/lang-html@6.4.8/dist/index.js";
        import { css } from "https://cdn.jsdelivr.net/npm/@codemirror/lang-css@6.2.1/dist/index.js";
        import { oneDark } from "https://cdn.jsdelivr.net/npm/@codemirror/theme-one-dark@6.1.2/dist/index.js";
        import { keymap } from "https://cdn.jsdelivr.net/npm/@codemirror/view@6.26.3/dist/index.js";
        import { defaultKeymap } from "https://cdn.jsdelivr.net/npm/@codemirror/commands@6.3.3/dist/index.js";
        import { autocompletion } from "https://cdn.jsdelivr.net/npm/@codemirror/autocomplete@6.15.0/dist/index.js";

        // Expose to window for global access
        window.CodeMirror = {
            view: { EditorView, EditorState, keymap, basicSetup },
            langJavascript: { javascript },
            langHtml: { html },
            langCss: { css },
            themeOneDark: { oneDark },
            commands: { defaultKeymap },
            autocomplete: { autocompletion }
        };

        console.log("CodeMirror 6 chargé avec succès");
    </script>


    <script type="module">

        //deepSeek R1 api: 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

        const DRIVE_API_KEY = "AIzaSyAFXqNypTEWBX7Wbs7hVr_FFvuItxB1fGI"
        const DRIVE_FOLDER_ID = "1rWQnAn8e2fLPpGa-8_GXYHmb0NeTLNH2";
        const YOUTUBE_API_KEY = "AIzaSyBRGvHeOTNPQYhgahGVSeuvsvH2rnUnDF0"; // Remplacer par une clé valide
        const ADMIN_UID = "bM2XwcfzMhXJdzExxFMBJ8mo2612";

        const baseUrl = 'https://www.googleapis.com/youtube/v3';



        const ADMIN_VERIFIED_ICON =
            '<i class="bi bi-patch-check-fill admin-verified" title="Administrateur vérifié"></i>';

        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-app.js";
        import {
            getAuth,
            GoogleAuthProvider,
            signInWithPopup,
            signInWithEmailAndPassword,
            createUserWithEmailAndPassword,
            signOut,
            onAuthStateChanged,
            updateProfile,
            updatePassword,
            deleteUser,
        } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-auth.js";

        import {
            getStorage,
            ref,
            uploadBytes,
            getDownloadURL,
            deleteObject
        } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-storage.js";

        import {
            getFirestore, collection, addDoc, getDocs, getDoc,
            query, where, doc, setDoc, updateDoc, deleteDoc,
            Timestamp, onSnapshot, orderBy, limit, writeBatch,
            runTransaction, deleteField, increment // <- Ajout de increment
        } from "https://www.gstatic.com/firebasejs/10.14.0/firebase-firestore.js";


        const firebaseConfig = {
            apiKey: "AIzaSyCEWWnD_36oOe5zUPh7A968hNI8t3LTUJ8",
            authDomain: "fpn-info-et-ia.firebaseapp.com",
            databaseURL: "https://fpn-info-et-ia-default-rtdb.firebaseio.com",
            projectId: "fpn-info-et-ia",
            storageBucket: "fpn-info-et-ia.firebasestorage.app",
            messagingSenderId: "746733727875",
            appId: "1:746733727875:web:25629c417c9202b22cabb6",
            measurementId: "G-XRJ2DZPKT0"
        };

        const app = initializeApp(firebaseConfig);
        const auth = getAuth(app);
        const db = getFirestore(app);
        const storage = getStorage(app);
        const provider = new GoogleAuthProvider();

        // FIX CRITIQUE: Réactiver la portée Drive pour que googleAccessToken soit fonctionnel
        provider.addScope("https://www.googleapis.com/auth/drive.readonly");

        // === ADD CONTEXT MENU HANDLER HERE ===
        document.addEventListener('contextmenu', (e) => {
            // Allow context menu for specific elements
            const allowedElements = ['input', 'textarea', '[contenteditable="true"]'];
            const isAllowed = allowedElements.some(selector =>
                e.target.closest(selector)
            );

            if (!isAllowed) {
                e.preventDefault();
                // Show custom context menu if needed
                showCustomContextMenu(e);
            }
        });

        function showCustomContextMenu(e) {
            // Implement your custom context menu logic
            console.log('Custom context menu triggered at:', e.clientX, e.clientY);
        }
        // === END CONTEXT MENU HANDLER ===

        let isAdmin = false;

        let allFiles = [];
        let currentFiles = [];
        let userProgress = {};
        let currentFolderId = DRIVE_FOLDER_ID;
        let folderPath = [{ id: DRIVE_FOLDER_ID, name: "Racine" }];
        let notes = JSON.parse(localStorage.getItem("notes") || "[]");
        let contributedContent = [];

        let googleAccessToken = localStorage.getItem("googleAccessToken") || null;

        let newDiscussionQuill, replyQuill; // To hold Quill instances
        let currentDiscussionId = null;
        let progressDonutChart, progressByCourseChart, activityLineChart;
        let unsubscribeNotifications = null; // To manage the real-time listener
        const newDiscussionModal = new bootstrap.Modal(
            document.getElementById("newDiscussionModal")
        );
        // Éléments DOM
        const btnLogin = document.getElementById("btnLogin");
        const btnLogout = document.getElementById("btnLogout");
        const modalAuth = new bootstrap.Modal(
            document.getElementById("modalAuth")
        );
        const videoModal = new bootstrap.Modal(
            document.getElementById("videoModal")
        );
        const documentModal = new bootstrap.Modal(
            document.getElementById("documentModal")
        );
        const videoModalEl = document.getElementById("videoModal");
        const documentModalEl = document.getElementById("documentModal");
        const sidebarToggle = document.getElementById("sidebarToggle");
        const sidebar = document.getElementById("sidebar");
        const mainContent = document.getElementById("mainContent");
        const body = document.body;
        const contentCourseSelect = document.getElementById("contentCourse");

        // 1. Add this constant near your other modal constants
        const playlistPanel = document.getElementById("playlistPanel");
        const playlistQueue = document.getElementById("playlistQueue");


        let editReplyQuill; // To hold the new Quill editor instance
        const editReplyModal = new bootstrap.Modal(
            document.getElementById("editReplyModal")
        );




        const BACKGROUND_IMAGES = [
            { id: "none", name: "Aucun (Défaut)", url: "none" },
            // Ambiance Minimaliste / Naturelle
            {
                id: "bg-image-1",
                name: "Géométrie Bleue (Abstrait)",
                url: "https://picsum.photos/id/1054/1920/1080",
            },
            {
                id: "bg-image-2",
                name: "Coucher de Soleil Doux",
                url: "https://picsum.photos/id/1043/1920/1080",
            },
            {
                id: "bg-image-3",
                name: "Nébuleuse Sombre",
                url: "https://picsum.photos/id/350/1920/1080",
            },
            {
                id: "bg-image-4",
                name: "Bois Minimaliste",
                url: "https://picsum.photos/id/400/1920/1080",
            },

            // NOUVELLES IMAGES : Style Anime / Cyberpunk / Fantasy (utiliser des IDs plus grands)
            {
                id: "bg-image-5",
                name: "Ville Cyberpunk Néon",
                url: "https://t3.ftcdn.net/jpg/05/36/78/84/240_F_536788448_UcOZv30qCQY36To1ygsjmFmVUaeuc7kf.jpg",
            },
            {
                id: "bg-image-6",
                name: "Paysage Manga Nuageux",
                url: "https://img1.wallspic.com/crops/0/5/8/7/6/167850/167850-boardwalk-cloud-water-street_light-purple-3840x2160.png",
            },
            {
                id: "bg-image-7",
                name: "Dragon Fantasy (Sombre/Rouge)",
                url: "https://img1.wallspic.com/crops/3/2/0/0/8/180023/180023-vegeta_dragon_ball-vegeta-goku-dragon_ball-dragon-3840x2160.jpg",
            },
            {
                id: "bg-image-8",
                name: "Planète Sci-Fi (Bleu/Violet)",
                url: "https://img1.wallspic.com/crops/9/8/2/0/5/150289/150289-man_riding_bicycle_under_blue_sky-3840x2160.jpg",
            },
            {
                id: "bg-image-9",
                name: "Naruto",
                url: "https://img1.wallspic.com/previews/8/8/5/8/7/178588/178588-itachi_faithful_night-itachi_uchiha-visual_arts-graphic_design-art-x750.jpg",
            },
            {
                id: "bg-image-10",
                name: "One piece",
                url: "https://img2.wallspic.com/previews/9/8/7/2/7/172789/172789-anime-sleeve-cartoon-animation-shonen_manga-x750.jpg",
            },
            {
                id: "bg-image-11",
                name: "Attack on Titan",
                url: "https://img1.wallspic.com/previews/6/5/6/6/7/176656/176656-attack_on_titan-eren_yeager-mikasa_ackerman-attack_on_titan_2-armin_arlert-x750.jpg",
            },
            {
                id: "bg-image-12",
                name: "Silhouette au Crépuscule",
                url: "https://img1.wallspic.com/previews/9/6/8/6/4/146869/146869-silhouette_of_man_and_woman_standing_on_brown_sand_during_sunset-x750.jpg",
            },
            {
                id: "bg-image-13",
                name: "Rochers au Coucher",
                url: "https://img1.wallspic.com/previews/3/5/5/6/2/126553/126553-sunset-rock-sea-creative_arts-formation-x750.jpg",
            },

            // EXTRA: Scenic / Abstract / Tech / Pastel / High-contrast
            {
                id: "bg-image-14",
                url: "https://images.unsplash.com/photo-1446776811953-b23d57bd21aa?auto=format&fit=crop&w=1920&q=80",
            },
            {
                id: "bg-image-15",
                url: "https://images.unsplash.com/photo-1501785888041-af3ef285b470?auto=format&fit=crop&w=1920&q=80",
            },
            {
                id: "bg-image-16",
                url: "https://images.unsplash.com/photo-1507525428034-b723cf961d3e?auto=format&fit=crop&w=1920&q=80",
            },
            {
                id: "bg-image-17",
                url: "https://images.unsplash.com/photo-1500530855697-b586d89ba3ee?auto=format&fit=crop&w=1920&q=80",
            },
            {
                id: "bg-image-18",
                url: "https://images.unsplash.com/photo-1499346030926-9a72daac6c63?auto=format&fit=crop&w=1920&q=80",
            },
            {
                id: "bg-image-19",
                url: "https://images.unsplash.com/photo-1518770660439-4636190af475?auto=format&fit=crop&w=1920&q=80",
            },
            {
                id: "bg-image-20",
                url: "https://img2.wallspic.com/crops/0/5/3/9/7/179350/179350-art-la_purete_de_la_couleur-purple-azure-violette-2560x1440.jpg",
            },
            {
                id: "bg-image-21",
                url: "https://images.unsplash.com/photo-1503264116251-35a269479413?auto=format&fit=crop&w=1920&q=80",
            },
            {
                id: "bg-image-22",
                url: "https://images.unsplash.com/photo-1469474968028-56623f02e42e?auto=format&fit=crop&w=1920&q=80",
            },
            {
                id: "bg-image-23",
                url: "https://images.unsplash.com/photo-1482192505345-5655af888cc4?auto=format&fit=crop&w=1920&q=80",
            },
            {
                id: "bg-image-24",
                url: "https://img2.wallspic.com/previews/7/7/7/8/7/178777/178777-amoled-atmosphere-lecoregion-nature-afterglow-x750.jpg",
            },
            {
                id: "bg-image-25",
                url: "https://images.unsplash.com/photo-1504639725590-34d0984388bd?auto=format&fit=crop&w=1920&q=80",
            },
            {
                id: "bg-image-26",
                url: "https://images.unsplash.com/photo-1493246507139-91e8fad9978e?auto=format&fit=crop&w=1920&q=80",
            },
            {
                id: "bg-image-27",
                url: "https://img1.wallspic.com/previews/3/5/8/0/40853/40853-matin-jaune-printemps-lac-ciel-x750.jpg",
            },
            {
                id: "bg-image-28",
                url: "https://4kwallpapers.com/images/walls/thumbs_3t/10148.jpg",
            },
        ];

        // Initialisation
        document
            .querySelectorAll(".sidebar-item, .dropdown-item[data-view]")
            .forEach((item) => {
                item.addEventListener("click", (e) => {
                    e.preventDefault();
                    const view = item.dataset.view;

                    document
                        .querySelectorAll(".sidebar-item")
                        .forEach((i) => i.classList.remove("active"));
                    const sidebarItem = document.querySelector(
                        `.sidebar-item[data-view="${view}"]`
                    );
                    if (sidebarItem) sidebarItem.classList.add("active");

                    switchView(view);

                    if (window.innerWidth < 992) sidebar.classList.remove("show");
                });
            });

        loadTheme();

        sidebarToggle?.addEventListener("click", () => {
            sidebar.classList.toggle("show");
        });

        btnLogin.addEventListener("click", () => modalAuth.show());

        document
            .getElementById("googleSignIn")
            .addEventListener("click", async () => {
                try {
                    const result = await signInWithPopup(auth, provider);
                    const credential = GoogleAuthProvider.credentialFromResult(result);
                    googleAccessToken = credential.accessToken;
                    localStorage.setItem("googleAccessToken", googleAccessToken);
                    modalAuth.hide();
                } catch (err) {
                    showToast("Erreur de connexion : " + err.message, "danger");
                }
            });

        document
            .getElementById("googleSignup")
            .addEventListener("click", async () => {
                try {
                    const result = await signInWithPopup(auth, provider);
                    const credential = GoogleAuthProvider.credentialFromResult(result);
                    googleAccessToken = credential.accessToken;
                    localStorage.setItem("googleAccessToken", googleAccessToken);
                    await updateProfile(result.user, {
                        displayName: result.user.displayName,
                    });
                    modalAuth.hide();
                } catch (err) {
                    showToast("Erreur d'inscription : " + err.message, "danger");
                }
            });
        document
            .getElementById("signinForm")
            .addEventListener("submit", async (e) => {
                e.preventDefault();
                const email = document.getElementById("signinEmail").value;
                const password = document.getElementById("signinPassword").value;
                try {
                    await signInWithEmailAndPassword(auth, email, password);
                    modalAuth.hide();
                } catch (err) {
                    showToast("Erreur de connexion : " + err.message, "danger");
                }
            });

        document
            .getElementById("signupForm")
            .addEventListener("submit", async (e) => {
                e.preventDefault();
                const name = document.getElementById("signupName").value;
                const email = document.getElementById("signupEmail").value;
                const password = document.getElementById("signupPassword").value;
                try {
                    const result = await createUserWithEmailAndPassword(
                        auth,
                        email,
                        password
                    );
                    await updateProfile(result.user, { displayName: name });
                    modalAuth.hide();
                } catch (err) {
                    showToast("Erreur d'inscription : " + err.message, "danger");
                }
            });

        btnLogout.addEventListener("click", async () => {
            await signOut(auth);
            localStorage.removeItem("googleAccessToken");
            googleAccessToken = null;
            location.reload();
        });


        // Requêtes client

        onAuthStateChanged(auth, (user) => {
            const profileDropdown = document.getElementById("profileDropdown");
            const btnLogin = document.getElementById("btnLogin");
            const welcomeEl = document.getElementById("welcomeUserName");
            const justLoggedIn = localStorage.getItem('fpn_just_logged_in');
            if (user) {

                if (justLoggedIn === 'true') {
                    localStorage.removeItem('fpn_just_logged_in');
                    // Optionnel: Afficher un toast de bienvenue ou rediriger vers la dernière page consultée
                    showToast(`Bienvenue, ${user.displayName || 'Utilisateur'}!`, "success");
                }
                // --- USER IS LOGGED IN ---
                profileDropdown.style.display = "block";
                btnLogin.classList.add("d-none");
                if (welcomeEl)
                    welcomeEl.textContent = user.displayName || "Utilisateur";

                document.getElementById("userPhoto").src =
                    user.photoURL ||
                    `https://ui-avatars.com/api/?name=${encodeURIComponent(
                        user.displayName || user.email
                    )}`;
                document.getElementById("userName").innerText =
                    user.displayName || "Utilisateur";
                document.getElementById("userEmail").innerText = user.email;

                googleAccessToken = localStorage.getItem("googleAccessToken") || null;

                // --- ADMIN CHECK LOGIC ---
                user.getIdTokenResult().then((idTokenResult) => {
                    // Check for the custom 'admin' claim
                    isAdmin = !!idTokenResult.claims.admin;
                    console.log(`User is admin: ${isAdmin}`);

                    // Re-render any components that might change for an admin
                    if (
                        document
                            .getElementById("discussionsView")
                            .classList.contains("d-none") === false
                    ) {
                        showDiscussionsList();
                    }
                });

                // Assurer l'existence du document utilisateur pour les transactions
                const userDocRef = doc(db, 'users', user.uid);
                setDoc(userDocRef, {
                    name: user.displayName || 'Anonyme',
                    email: user.email,
                    photoURL: user.photoURL,
                    // Initialiser le champ 'reactions' comme un Map vide si non existant
                    reactions: {}
                }, { merge: true })
                    .catch(err => console.error("Erreur de création du doc utilisateur:", err));

                loadUserProgress();
                fetchDriveFolder(currentFolderId);
                loadContributedContent();

                listenForUserGroups(user.uid);
                initializeUserPresence(user.uid);
                listenForNotifications(user.uid);
                listenForInboxMessages(user.uid);
                initializeAlarmSystem();
                renderCalendar();
            } else {
                if (justLoggedIn) {
                    localStorage.removeItem('fpn_just_logged_in');
                }

                // --- USER IS LOGGED OUT ---
                profileDropdown.style.display = "none";
                btnLogin.classList.remove("d-none");
                if (welcomeEl) welcomeEl.textContent = "";

                googleAccessToken = null;
                userProgress = {};
                document.getElementById("coursesGrid").innerHTML =
                    '<div class="col-12 text-center text-muted py-5"><i class="bi bi-lock fs-1"></i><p>Veuillez vous connecter pour accéder aux cours.</p></div>';

                isAdmin = false; // Reset admin status on logout
                if (unsubscribeNotifications) unsubscribeNotifications();
                if (unsubscribeInbox) unsubscribeInbox();
                stopAlarmSystem();
                if (calendar) calendar.destroy();

                if (currentUserPresenceRef) {
                    updateDoc(currentUserPresenceRef, {
                        status: 'offline',
                        lastSeen: Timestamp.now()
                    }).catch(() => { });
                }

                updateNotificationUI([]);
            }

            loadTheme();
        });

        // Recherche
        document.getElementById("searchInput")?.addEventListener("input", (e) => {
            const query = e.target.value.toLowerCase();
            filterCourses(query);
        });

        // Formulaire de notes
        document.getElementById("noteForm")?.addEventListener("submit", (e) => {
            e.preventDefault();
            const title = document.getElementById("noteTitle").value;
            const content = document.getElementById("noteContent").value;
            notes.push({
                title,
                content,
                date: new Date().toLocaleString("fr-FR"),
            });
            localStorage.setItem("notes", JSON.stringify(notes));
            renderNotes();
            e.target.reset();
        });


        function extractGoogleDriveId(url) {
            if (!url) return null;
            // Tente de trouver l'ID dans le format standard /file/d/ID/view
            let match = url.match(/\/file\/d\/([a-zA-Z0-9_-]+)/);
            if (match) return match[1];

            // Tente de trouver l'ID dans les liens d'édition ou de partage ?id=ID
            match = url.match(/id=([a-zA-Z0-9_-]+)/);
            if (match) return match[1];

            // Si l'utilisateur colle un lien direct vers un fichier
            match = url.match(/drive\.google\.com\/open\?id=([a-zA-Z0-9_-]+)/);
            if (match) return match[1];

            // Si c'est juste un ID collé
            if (url.match(/^[a-zA-Z0-9_-]+$/)) return url;

            return null;
        }




        // --- FIX: Stop video/document from playing when modal is closed ---
        videoModalEl.addEventListener("hidden.bs.modal", () => {
            const videoContainer = document.getElementById("videoContainer");
            const iframe = videoContainer.querySelector("iframe");
            if (iframe) {
                iframe.src = "";
            }
            historyQueue.innerHTML = ""; // This line is correct
            playlistPanel.classList.add("d-none");
            playlistPanel.classList.remove("d-flex");
        });

        documentModalEl.addEventListener("hidden.bs.modal", () => {
            const documentContainer = document.getElementById("documentContainer");
            const iframe = documentContainer.querySelector("iframe");
            if (iframe) {
                // This is also good practice for document modals to free up resources
                iframe.src = "";
            }
            // Réinitialiser le bouton plein écran lorsque le modal se ferme
            const toggleBtn = document.querySelector('#documentModalDialog .fullscreen-toggle-btn');
            const dialog = document.getElementById('documentModalDialog');
            if (dialog.classList.contains('modal-fullscreen')) {
                dialog.classList.remove('modal-fullscreen');
                if (toggleBtn) toggleBtn.querySelector('i').className = 'bi bi-arrows-fullscreen';
            }
        });

        // 1. Add this variable at the top with your other global variables
        let documentViewMode = "grid"; // Can be 'grid' or 'list'

        // 2. Add these event listeners for the new buttons in your initialization section
        document
            .getElementById("btnGridDocuments")
            .addEventListener("click", () => {
                documentViewMode = "grid";
                document.getElementById("btnGridDocuments").classList.add("active");
                document
                    .getElementById("btnListDocuments")
                    .classList.remove("active");
                renderDocuments();
            });

        document
            .getElementById("btnListDocuments")
            .addEventListener("click", () => {
                documentViewMode = "list";
                document.getElementById("btnListDocuments").classList.add("active");
                document
                    .getElementById("btnGridDocuments")
                    .classList.remove("active");
                renderDocuments();
            });


        // Fonction utilitaire pour convertir HEX en RGB
        function hexToRgb(hex) {
            const bigint = parseInt(hex.slice(1), 16);
            const r = (bigint >> 16) & 255;
            const g = (bigint >> 8) & 255;
            const b = bigint & 255;
            return { r, g, b };
        }

        // Fonction utilitaire pour déterminer si une couleur est claire ou sombre (luminosité YIQ)
        function isLight(color) {
            const { r, g, b } = hexToRgb(color);
            const yiq = (r * 299 + g * 587 + b * 114) / 1000;
            return yiq >= 180; // Seuil ajusté pour l'interface utilisateur
        }

        /**
         * Analyse une image pour extraire une palette de couleurs.
         */
        function analyzeImageColors(imageUrl) {
            return new Promise((resolve, reject) => {
                if (!imageUrl || imageUrl === "none") {
                    return resolve({
                        dominant: null,
                        accent: null,
                        isDominantLight: false,
                    });
                }

                const img = new Image();
                img.crossOrigin = "Anonymous";
                img.src = imageUrl;

                img.onload = () => {
                    const canvas = document.createElement("canvas");
                    const ctx = canvas.getContext("2d");

                    const width = 100;
                    const height = 100;
                    canvas.width = width;
                    canvas.height = height;
                    ctx.drawImage(img, 0, 0, width, height);

                    try {
                        const imageData = ctx.getImageData(0, 0, width, height).data;
                        const colors = {};
                        const step = 4 * 10;

                        for (let i = 0; i < imageData.length; i += step) {
                            const r = imageData[i];
                            const g = imageData[i + 1];
                            const b = imageData[i + 2];

                            const hex =
                                "#" +
                                ((1 << 24) + (r << 16) + (g << 8) + b)
                                    .toString(16)
                                    .slice(1)
                                    .toUpperCase();
                            colors[hex] = (colors[hex] || 0) + 1;
                        }

                        const sortedColors = Object.entries(colors).sort(
                            ([, a], [, b]) => b - a
                        );

                        if (sortedColors.length === 0) {
                            return resolve({
                                dominant: null,
                                accent: null,
                                isDominantLight: false,
                            });
                        }

                        let dominant = sortedColors[0][0];
                        let accent =
                            sortedColors.length > 1 ? sortedColors[1][0] : dominant;

                        const filterThreshold = 10;

                        const isTooGrayOrSoft = (hex) => {
                            const { r, g, b } = hexToRgb(hex);
                            return (
                                Math.abs(r - g) < filterThreshold &&
                                Math.abs(g - b) < filterThreshold &&
                                isLight(hex)
                            );
                        };

                        let validDominant = dominant;
                        for (let i = 0; i < sortedColors.length && i < 10; i++) {
                            if (!isTooGrayOrSoft(sortedColors[i][0])) {
                                validDominant = sortedColors[i][0];
                                break;
                            }
                        }

                        let validAccent = validDominant;
                        for (let i = 0; i < sortedColors.length && i < 10; i++) {
                            const potentialAccent = sortedColors[i][0];
                            if (
                                potentialAccent !== validDominant &&
                                !isTooGrayOrSoft(potentialAccent)
                            ) {
                                validAccent = potentialAccent;
                                break;
                            }
                        }

                        const isDomLight = isLight(validDominant);

                        resolve({
                            dominant: validDominant,
                            accent: validAccent,
                            isDominantLight: isDomLight,
                        });
                    } catch (error) {
                        console.error(
                            "Erreur lors de l'analyse des couleurs (CORS ou Canvas):",
                            error
                        );
                        resolve({ dominant: null, accent: null, isDominantLight: false });
                    }
                };

                img.onerror = () => {
                    console.warn(
                        "Impossible de charger l'image pour l'analyse des couleurs."
                    );
                    resolve({ dominant: null, accent: null, isDominantLight: false });
                };
            });
        }

        async function setBackgroundImage(imageId) {
            localStorage.setItem("backgroundImage", imageId);
            const main = document.getElementById("mainContent");
            const body = document.body;
            if (!main) return;

            const imageMeta = BACKGROUND_IMAGES.find((i) => i.id === imageId);
            const imageUrl = imageMeta ? imageMeta.url : null;

            // 1. Suppression des classes et variables dynamiques précédentes (CIBLER LE BODY ET MAIN)
            main.removeAttribute("data-bg");
            body.removeAttribute("data-dynamic-text");
            body.removeAttribute("data-dynamic-bg-active");

            // Nettoyer les variables dynamiques du body
            body.style.setProperty("--dynamic-brand", null);
            body.style.setProperty("--dynamic-accent", null);
            body.style.setProperty("--dynamic-text-color", null);
            body.style.setProperty("--dynamic-surface-color", null);

            // Nettoyer le body des anciennes classes pour éviter les fuites
            body.className = body.className
                .split(" ")
                .filter((c) => !c.startsWith("bg-image-"))
                .join(" ");
            main.className = main.className
                .split(" ")
                .filter((c) => !c.startsWith("bg-image-"))
                .join(" ");

            if (imageId && imageId !== "none") {
                // 2. Analyse des couleurs
                const { dominant, accent, isDominantLight } =
                    await analyzeImageColors(imageUrl);

                // 3. Application des classes/attributs sur le BODY (Contrôle Global)
                body.setAttribute("data-dynamic-bg-active", "true");
                body.setAttribute(
                    "data-dynamic-text",
                    isDominantLight ? "dark" : "light"
                );
                body.classList.add(imageId);

                // 4. Application des variables sur le BODY
                if (dominant && accent) {
                    const dynamicTextColor = isDominantLight
                        ? "var(--text)"
                        : "var(--dark-text)";

                    const dynamicSurfaceColor = isDominantLight
                        ? "rgba(255, 255, 255, 0.85)"
                        : "rgba(30, 41, 59, 0.85)";

                    const shadowColor = isDominantLight
                        ? "var(--text)"
                        : "var(--dark-text)";

                    const rgb = hexToRgb(dominant);
                    const rgbString = `${rgb.r}, ${rgb.g}, ${rgb.b}`;

                    body.style.setProperty("--dynamic-brand", dominant);
                    body.style.setProperty("--dynamic-accent", accent);
                    body.style.setProperty("--dynamic-brand-rgb", rgbString);
                    body.style.setProperty("--dynamic-text-color", dynamicTextColor);
                    body.style.setProperty(
                        "--dynamic-surface-color",
                        dynamicSurfaceColor
                    );
                    body.style.setProperty("--dynamic-shadow-color", shadowColor);

                    main.style.setProperty("--dynamic-brand", dominant);
                    main.style.setProperty("--dynamic-accent", accent);
                    main.style.setProperty("--dynamic-text-color", dynamicTextColor);
                    main.style.setProperty(
                        "--dynamic-surface-color",
                        dynamicSurfaceColor
                    );
                    main.style.setProperty("--dynamic-shadow-color", shadowColor);

                    // Appliquer la même image au main content pour le défilement
                    main.setAttribute("data-bg", imageId);
                    main.classList.add(imageId);

                    showToast(`Thème dynamique appliqué !`, "success");
                } else {
                    // Si l'analyse échoue mais que l'image est sélectionnée
                    main.setAttribute("data-bg", imageId);
                    main.classList.add(imageId);
                    showToast(
                        `Image appliquée, mais l'analyse des couleurs a échoué (CORS ou faible contraste).`,
                        "warning"
                    );
                }
            } else {
                // Option 'None'
                main.style.backgroundImage = "none";
                main.style.backgroundColor = "var(--soft)";
            }

            renderBackgroundSelector();
        }

        function loadBackgroundImage() {
            const savedImage = localStorage.getItem("backgroundImage") || "none";
            setBackgroundImage(savedImage);
        }

        function renderBackgroundSelector() {
            const grid = document.getElementById("backgroundSelectorGrid");
            if (!grid) return;
            grid.innerHTML = "";

            const activeImage = localStorage.getItem("backgroundImage") || "none";

            BACKGROUND_IMAGES.forEach((img) => {
                const col = document.createElement("div");
                col.className = "col-6 col-md-3";

                // Handle "None" option separately
                const style =
                    img.id !== "none"
                        ? `background-image: url('${img.url}')`
                        : `background-color: var(--border); display: flex; align-items: center; justify-content: center;`;

                const content =
                    img.id !== "none"
                        ? `<div class="bg-thumb ${img.id === activeImage ? "active" : ""
                        }" style="${style}"></div>`
                        : `<div class="bg-thumb ${img.id === activeImage ? "active" : ""
                        }" style="${style}">
                   <i class="bi bi-x-circle fs-3 text-muted"></i>
               </div>`;

                col.innerHTML = `
            ${content}
            <small class="d-block text-center mt-1 text-muted">${img.name}</small>
        `;

                col.querySelector(".bg-thumb").addEventListener("click", () => {
                    setBackgroundImage(img.id);
                    showToast(`Fond d'écran changé : ${img.name}`, "info");
                });

                grid.appendChild(col);
            });
        }

        // Sélecteur de thème
        document
            .getElementById("themeSelect")
            ?.addEventListener("change", (e) => {
                const theme = e.target.value;
                setTheme(theme);
                renderBackgroundSelector();
            });

        // START: EVENT LISTENERS FOR ACCOUNT SETTINGS
        document
            .getElementById("profileSettingsForm")
            ?.addEventListener("submit", async (e) => {
                e.preventDefault();
                const user = auth.currentUser;
                if (!user) return;

                const newName = document.getElementById("accountName").value;
                if (newName !== user.displayName) {
                    try {
                        await updateProfile(user, { displayName: newName });
                        document.getElementById("userName").innerText = newName;
                        document.getElementById("welcomeUserName").innerText = newName;
                        showToast("Profil mis à jour avec succès !", "success");
                    } catch (error) {
                        showToast("Erreur lors de la mise à jour du profil.", "danger");
                    }
                }
            });

        document
            .getElementById("passwordChangeForm")
            ?.addEventListener("submit", async (e) => {
                e.preventDefault();
                const user = auth.currentUser;
                if (!user) return;

                const newPassword = document.getElementById("newPassword").value;
                try {
                    await updatePassword(user, newPassword);
                    showToast("Mot de passe mis à jour avec succès.", "success");
                    e.target.reset();
                } catch (error) {
                    showToast("Erreur: " + error.message, "danger");
                }
            });

        document
            .getElementById("btnDeleteAccount")
            ?.addEventListener("click", async () => {
                const user = auth.currentUser;
                if (!user) return;

                if (
                    confirm(
                        "Êtes-vous sûr de vouloir supprimer votre compte ? Cette action est irréversible."
                    )
                ) {
                    try {
                        await deleteUser(user);
                        showToast("Compte supprimé avec succès.", "info");
                        // The onAuthStateChanged will handle the UI changes after deletion.
                    } catch (error) {
                        showToast(
                            "Erreur lors de la suppression du compte: " + error.message,
                            "danger"
                        );
                    }
                }
            });
        // END: EVENT LISTENERS FOR ACCOUNT SETTINGS

        // --- NOUVELLE LOGIQUE DE NAVIGATION VERS LE SANDBOX ---
        window.openFullSandbox = function () {
            switchView('codeEditorSandbox'); // Passer à la vue qui contient l'iframe

            // Charger l'iframe vers la page blanche (sandbox.html)
            const sandboxView = document.getElementById('codeEditorSandboxView');
            if (sandboxView) {
                sandboxView.innerHTML = `
            <iframe id="fullSandboxIframe" 
                    src="sandbox.html" 
                     style="border: none; width: 100%; height: 100vh;" allow="autoplay; clipboard-write">
            </iframe>
        `;
            }
        };

        // --- NOUVELLE LOGIQUE DE NAVIGATION VERS L'ÉDITEUR UML ---
        window.openFullUmlEditor = function () {
            // Passer à la vue contenant l'iframe UML
            switchView('umlEditorFull');

            // Charger l'iframe vers la page UML (umlEditor.html)
            const umlView = document.getElementById('umlEditorFullView');
            if (umlView) {
                umlView.innerHTML = `
                <iframe id="fullUmlIframe" 
                    src="umlEditor.html" 
                    style="border: none; width: 100%; height: 100vh;" 
                    allow="clipboard-write; autoplay">
                </iframe>
                `;
            }
        };




        function switchView(view) {
            document.querySelectorAll(".view-content").forEach(v => v.classList.add("d-none"));

            const viewEl = document.getElementById(view + "View") || document.getElementById(view + "Section");

            if (viewEl) viewEl.classList.remove("d-none");

            if (view === "videos") {
                renderVideos();
                fetchYoutubeTutorials();
                renderContributedVideos();
            }
            if (view === "contributed") renderContributed();
            if (view === "documents") renderDocuments();
            if (view === 'library') {
                if (!currentSearchQuery) {
                    searchLibrary('', 1, false);
                } else {
                    document.getElementById("libraryList").classList.remove("d-none");
                    document.getElementById("bookDetailView").classList.add("d-none");
                }
            }
            if (view === "assignments") renderAssignments();
            if (view === "calendar") renderCalendar();
            if (view === "inbox") {
                listenForInboxMessages(auth.currentUser.uid);
            }
            if (view === "discussions") showDiscussionsList();
            if (view === "ai-chats") renderAIConversationsList();
            if (view === "notifications") renderFullNotificationPage();
            //if (view === "edu-mediaView") initEduMedia(); renderEduMedia() Fresh fetch every time
            if (view === "edu-media") {
                // Check for the API object, not the single function
                if (window.EduMediaAPI && typeof window.EduMediaAPI.init === 'function') {
                    // Call the init method via the API
                    window.EduMediaAPI.init();
                } else {
                    console.error('EduMediaAPI or its init method not found! Ensure the script is loaded.');
                }
            }



            // In your switchView function, update the music case:
            // In your switchView function
            if (view === "music") {
                // Clear any previous errors
                const musicContent = document.getElementById('musicContent');
                if (musicContent) {
                    musicContent.innerHTML = ''; // Clear any error messages
                }

                // Initialize music controller
                if (window.YouTubeMusicController) {
                    window.YouTubeMusicController.initMusicView();
                } else {
                    console.error('YouTubeMusicController not loaded');
                    musicContent.innerHTML = `
                        <div class="col-12 text-center py-5">
                            <i class="bi bi-exclamation-triangle fs-1 text-danger"></i>
                            <p class="mt-2">Module musique non chargé</p>
                            <button class="btn btn-primary mt-2" onclick="location.reload()">
                                Recharger la page
                            </button>
                        </div>
                    `;
                }
            }
            if (view === "notes") renderNotes();
            if (view === 'codeeditor-guide') {
                console.log("Vue Guide affichée.");
            }
            if (view === 'codeEditorSandbox') {
                // Optionnel: peut ne rien faire ici si openFullSandbox gère l'iframe
            }
            if (view === "progress") renderProgress();
            if (view === "settings") renderSettings();
            renderBackgroundSelector();
        }


        function loadUserProgress() {
            const saved = localStorage.getItem("userProgress");
            if (saved) userProgress = JSON.parse(saved);
        }

        function saveProgress(fileId, progress) {
            userProgress[fileId] = progress;
            localStorage.setItem("userProgress", JSON.stringify(userProgress));
            updateStats();
        }

        // --- FETCH DRIVE FOLDER (FIXED DRIVE ACCESS LOGIC) ---
        /*async function fetchDriveFolder(folderId) {
            document.getElementById("loader").style.display = "block";
            const coursesGrid = document.getElementById("coursesGrid");

            let param = "";
            if (googleAccessToken) {
                param = `&access_token=${googleAccessToken}`;
            } else if (DRIVE_API_KEY) {
                param = `&key=${DRIVE_API_KEY}`;
            }

            // Vérification essentielle : Si ni token ni clé, on ne peut pas faire l'appel.
            if (!param) {
                document.getElementById("loader").style.display = "none";
                coursesGrid.innerHTML = `<div class="col-12 text-center text-danger py-5">
                    <i class="bi bi-exclamation-triangle fs-1"></i>
                    <p class="mt-2">Erreur: Clé API ou jeton d'accès manquant pour Google Drive.</p>
                </div>`;
                return;
            }

            try {
                const url = `https://www.googleapis.com/drive/v3/files?q='${folderId}'+in+parents&fields=files(id,name,mimeType,webViewLink,thumbnailLink,iconLink,webContentLink,description,createdTime,modifiedTime)&pageSize=200${param}`;

                const res = await fetch(url);

                if (!res.ok) {
                    const errorData = await res.json();
                    let errorMessage = `Erreur HTTP: ${res.status}. ${errorData.error?.message || 'Vérifiez les permissions ou le token.'}`;
                    if (res.status === 401 || res.status === 403) {
                        errorMessage = `Accès refusé. Veuillez vérifier votre connexion ou assurez-vous que les fichiers sont publics.`;
                    }
                    throw new Error(errorMessage);
                }

                const json = await res.json();

                if (json.error) {
                    throw new Error(json.error.message);
                }

                currentFiles = json.files || [];
                if (folderId === DRIVE_FOLDER_ID) allFiles = currentFiles;
                document.getElementById("loader").style.display = "none";

                renderCourses();
                renderFolderContributed();
                renderDashboard();
                updateStats();
                renderBreadcrumb();
                populateCourseSelect();
            } catch (err) {
                console.error("Erreur de fetch Drive:", err);
                document.getElementById("loader").style.display = "none";
                coursesGrid.innerHTML = `<div class="col-12 text-center text-danger py-5"><i
                    class="bi bi-exclamation-triangle fs-1"></i>
                    <p class="mt-2">Erreur de chargement des cours : ${err.message}</p>
                </div>`;
            }
        }
        */

        // Replace the current fetchDriveFolder function with this improved version
        async function fetchDriveFolder(folderId) {
            document.getElementById("loader").style.display = "block";
            const coursesGrid = document.getElementById("coursesGrid");

            try {
                // Multiple fallback methods for Drive access
                let url;

                // Method 1: Try with API key first (most reliable for public files)
                if (DRIVE_API_KEY) {
                    url = `https://www.googleapis.com/drive/v3/files?q='${folderId}'+in+parents&fields=files(id,name,mimeType,webViewLink,thumbnailLink,iconLink,webContentLink,description,createdTime,modifiedTime)&pageSize=200&key=${DRIVE_API_KEY}`;
                }
                // Method 2: Try with access token if available
                else if (googleAccessToken) {
                    url = `https://www.googleapis.com/drive/v3/files?q='${folderId}'+in+parents&fields=files(id,name,mimeType,webViewLink,thumbnailLink,iconLink,webContentLink,description,createdTime,modifiedTime)&pageSize=200&access_token=${googleAccessToken}`;
                } else {
                    throw new Error("No Drive API access configured");
                }

                const res = await fetch(url);

                if (!res.ok) {
                    // If first method fails, try alternative approach for public files
                    if (res.status === 403 || res.status === 401) {
                        url = `https://www.googleapis.com/drive/v3/files?q='${folderId}'+in+parents&fields=files(id,name,mimeType,webViewLink,thumbnailLink,iconLink)&pageSize=100&key=${DRIVE_API_KEY}`;
                        const fallbackRes = await fetch(url);
                        if (!fallbackRes.ok) throw new Error("Drive access denied");
                        const json = await fallbackRes.json();
                        currentFiles = json.files || [];
                    } else {
                        throw new Error(`HTTP ${res.status}: ${res.statusText}`);
                    }
                } else {
                    const json = await res.json();
                    currentFiles = json.files || [];
                }

                document.getElementById("loader").style.display = "none";

                if (currentFiles.length === 0) {
                    coursesGrid.innerHTML = `
                <div class="col-12 text-center text-muted py-5">
                    <i class="bi bi-folder-x fs-1"></i>
                    <p class="mt-2">Aucun contenu trouvé dans ce dossier.</p>
                    <small class="text-muted">Assurez-vous que les fichiers sont partagés publiquement</small>
                </div>
            `;
                    return;
                }

                renderCourses();
                renderFolderContributed();
                renderDashboard();
                updateStats();
                renderBreadcrumb();
                populateCourseSelect();

            } catch (err) {
                console.error("Erreur de fetch Drive:", err);
                document.getElementById("loader").style.display = "none";
                coursesGrid.innerHTML = `
            <div class="col-12 text-center text-danger py-5">
                <i class="bi bi-exclamation-triangle fs-1"></i>
                <p class="mt-2">Erreur de chargement: ${err.message}</p>
                <button class="btn btn-outline-primary mt-2" onclick="fetchDriveFolder('${folderId}')">
                    <i class="bi bi-arrow-clockwise"></i> Réessayer
                </button>
            </div>
        `;
            }
        }
        function populateCourseSelect() {
            contentCourseSelect.innerHTML =
                '<option value="">Associé à aucun cours</option>';
            allFiles
                .filter((f) => f.mimeType === "application/vnd.google-apps.folder")
                .forEach((folder) => {
                    const option = document.createElement("option");
                    option.value = folder.id;
                    option.textContent = folder.name;
                    contentCourseSelect.appendChild(option);
                });
        }

        async function loadContributedContent() {
            contributedContent = [];
            const q = query(collection(db, "contributed"));
            const snapshot = await getDocs(q);
            snapshot.forEach((doc) =>
                contributedContent.push({ id: doc.id, ...doc.data() })
            );
            renderContributed();
        }

        function getFileMeta(mime) {
            if (!mime) return {
                kind: "file",
                icon: "bi-file-earmark-text",
                label: "Fichier",
                color: "#6c757d"
            };

            const mimeTypes = {
                'application/vnd.google-apps.folder': {
                    kind: "folder",
                    icon: "bi-folder-fill",
                    label: "Dossier",
                    color: "#ffc107"
                },
                'video/': {
                    kind: "video",
                    icon: "bi-camera-video-fill",
                    label: "Vidéo",
                    color: "#dc3545"
                },
                'application/pdf': {
                    kind: "document",
                    icon: "bi-file-earmark-pdf-fill",
                    label: "PDF",
                    color: "#0d6efd"
                },
                'application/vnd.google-apps.document': {
                    kind: "document",
                    icon: "bi-file-earmark-text-fill",
                    label: "Document",
                    color: "#0d6efd"
                },
                'application/vnd.google-apps.spreadsheet': {
                    kind: "document",
                    icon: "bi-file-earmark-spreadsheet",
                    label: "Tableur",
                    color: "#198754"
                },
                'application/vnd.google-apps.presentation': {
                    kind: "document",
                    icon: "bi-file-earmark-slides",
                    label: "Présentation",
                    color: "#fd7e14"
                }
            };

            for (const [key, value] of Object.entries(mimeTypes)) {
                if (mime.includes(key.replace('*', ''))) {
                    return value;
                }
            }

            return {
                kind: "file",
                icon: "bi-file-earmark",
                label: "Fichier",
                color: "#6c757d"
            };
        }



        // Initialize the platform when DOM is loaded
        document.addEventListener('DOMContentLoaded', function () {
            // Load initial content
            if (auth.currentUser) {
                fetchDriveFolder(DRIVE_FOLDER_ID);
                setTimeout(() => {
                    fetchYoutubeTutorials();
                }, 1000);
            }

            // Add retry mechanism for failed loads
            window.retryDriveLoad = function () {
                fetchDriveFolder(currentFolderId || DRIVE_FOLDER_ID);
            };
        });

        function extractVideoId(url) {
            if (!url) return null;
            const match = url.match(
                /(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/
            );
            return match ? match[1] : null;
        }

        function extractPlaylistId(url) {
            const match = url.match(/[&?]list=([a-zA-Z0-9_-]+)/);
            return match ? match[1] : null;
        }

        function extractYoutubeId(url, type) {
            return type === "playlist"
                ? extractPlaylistId(url)
                : extractVideoId(url);
        }


        function renderBreadcrumb() {
            const breadcrumb = document.getElementById("breadcrumb");
            if (!breadcrumb) return;

            // Use join() with a separator element for cleaner logic
            breadcrumb.innerHTML = folderPath
                .map((folder, index) => {
                    if (index === folderPath.length - 1) {
                        // This is the current, non-clickable folder
                        return `<span class="breadcrumb-current">${escapeHtml(
                            folder.name
                        )}</span>`;
                    } else {
                        // These are the clickable parent folders
                        return `<a href="#" class="breadcrumb-link" onclick="navigateToFolder('${folder.id
                            }', ${index})">${escapeHtml(folder.name)}</a>`;
                    }
                })
                .join(' <i class="bi bi-chevron-right text-muted mx-1"></i> ');
        }

        /*window.navigateToFolder = function (folderId, index) {
            folderPath = folderPath.slice(0, index + 1);
            currentFolderId = folderId;
            fetchDriveFolder(folderId);
        };*/

        window.navigateToFolder = function (folderId, index) {
            folderPath = folderPath.slice(0, index + 1);
            currentFolderId = folderId;
            fetchDriveFolder(folderId);
        };


        function renderCourses() {
            const grid = document.getElementById("coursesGrid");
            if (!grid) return;
            grid.innerHTML = "";

            if (!currentFiles.length) {
                grid.innerHTML = `<div class="col-12 text-center text-muted py-5"><i class="bi bi-inbox fs-1"></i><p class="mt-2">Aucun cours trouvé dans ce dossier.</p></div>`;
                return;
            }

            currentFiles.forEach((file) => {
                const meta = getFileMeta(file.mimeType);
                const progress = userProgress[file.id] || 0;
                const thumb = file.thumbnailLink ||
                    `https://via.placeholder.com/400x250/${meta.color.replace("#", "")}/ffffff?text=${encodeURIComponent(meta.label)}`;

                const col = document.createElement("div");
                col.className = "col-xl-3 col-lg-4 col-md-6 mb-4";

                col.innerHTML = `
        <div class="card card-modern course-card h-100 fade-in shadow-sm border-0 rounded-3 overflow-hidden">
            ${progress > 0 ? `<div class="progress-ring">${progress}%</div>` : ""}
            <span class="course-badge"><i class="${meta.icon} me-1"></i>${meta.label}</span>

            ${meta.kind === "folder"
                        ? `<div class="course-thumbnail d-flex align-items-center justify-content-center" style="background:linear-gradient(135deg, ${meta.color}22, ${meta.color}11)">
                    <i class="${meta.icon}" style="font-size:64px; color:${meta.color}"></i>
                </div>`
                        : `<img class="course-thumbnail w-100" src="${thumb}" alt="${escapeHtml(file.name)}" loading="lazy">`
                    }

            <div class="card-body d-flex flex-column p-3">
                <h6 class="card-title mb-2 text-truncate" title="${escapeHtml(file.name)}" style="min-height:44px; line-height:1.4;">
                    ${escapeHtml(file.name)}
                </h6>
                
                ${progress > 0 ? `<div class="progress mb-3" style="height:6px;">
                        <div class="progress-bar bg-success" style="width:${progress}%"></div>
                    </div>` : ""}

                <div class="mt-auto d-grid gap-2">
                    ${meta.kind === "folder"
                        ? `<button class="btn btn-sm btn-primary" onclick="openFolder('${file.id}', '${escapeHtml(file.name)}')">
                            <i class="bi bi-folder-symlink me-1"></i>Ouvrir
                        </button>`
                        : meta.kind === "video"
                            ? `<button class="btn btn-sm btn-primary" onclick="playVideo('${file.id}', '${escapeHtml(file.name)}', '${file.webViewLink || ""}')">
                                <i class="bi bi-play-fill me-1"></i>Regarder
                            </button>`
                            : `<button class="btn btn-sm btn-primary" onclick="viewDocument('${file.id}', '${escapeHtml(file.name)}', '${file.webViewLink || ""}', '${meta.kind}')">
                                <i class="bi bi-eye me-1"></i>Voir
                            </button>`
                    }
                    ${file.webContentLink ? `<a class="btn btn-sm btn-outline-secondary" href="${file.webContentLink}" target="_blank" rel="noopener noreferrer">
                            <i class="bi bi-download me-1"></i>Télécharger
                        </a>` : ""}
                    <button class="btn btn-sm btn-outline-success" onclick="markComplete('${file.id}')">
                        <i class="bi bi-check-circle me-1"></i>
                        ${progress === 100 ? "Complété" : "Marquer comme complété"}
                    </button>
                </div>
            </div>
        </div>`;

                grid.appendChild(col);
            });
        }


        function renderFolderContributed() {
            const section = document.getElementById("folderContributedSection");
            if (!section) return;
            if (currentFolderId === DRIVE_FOLDER_ID) {
                section.classList.add("d-none");
                return;
            }

            section.classList.remove("d-none");
            const grid = document.getElementById("folderContributedGrid");
            grid.innerHTML = "";

            const filtered = contributedContent.filter(
                (c) => c.courseId === currentFolderId
            );

            if (!filtered.length) {
                grid.innerHTML = `
            <div class="col-12 text-center text-muted py-5">
               <i class="bi bi-camera-video-off fs-2 d-block mb-2"></i>
               Aucun tutoriel ou ressource contribué(e) pour ce cours.
            </div>`;
                return;
            }

            filtered.forEach((content) => {
                const col = document.createElement("div");
                col.className = "col-lg-4 col-md-6";
                let cardHTML = "";
                let iconClass = "";
                let iconBg = "";
                const clickHandler = `viewContributedContent(${JSON.stringify(
                    content
                )})`;

                // DÉTERMINER LE TYPE DE CARTE ET L'APERÇU
                switch (content.type) {
                    case "youtube":
                        const ytId = content.id || content.youtubeId;
                        const isPlaylist = content.youtubeType === "playlist";
                        // FIX: S'assurer que le rendu YouTube utilise le style video-card
                        const thumbYt = isPlaylist
                            ? "" // Pas de vignette pour la playlist (le CSS gère un fond de dégradé)
                            : `https://img.youtube.com/vi/${ytId}/mqdefault.jpg`;

                        const badgeTextYt = isPlaylist ? "Playlist" : "Vidéo";

                        cardHTML = `
                    <div class="video-card h-100 fade-in ${isPlaylist ? "playlist" : ""
                            }" style="cursor: pointer;" onclick='${clickHandler}'>
                        <div class="video-thumb">
                            ${isPlaylist
                                ? `<span class="playlist-title">${escapeHtml(
                                    content.title || "Playlist YouTube"
                                )}</span>`
                                : `<img src="${thumbYt}" alt="${escapeHtml(
                                    content.title
                                )}" class="video-thumb-img">`
                            }
                            <div class="video-overlay"><i class="bi bi-play-fill play-icon"></i></div>
                            <span class="video-badge">${badgeTextYt}</span>
                        </div>
                        <div class="video-body d-flex flex-column">
                            <h6 class="video-title"><i class="bi bi-youtube text-danger me-2"></i>${escapeHtml(
                                content.title || "Vidéo YouTube"
                            )}</h6>
                            <p class="video-author mt-auto"><i class="bi bi-person-circle me-1"></i>${escapeHtml(
                                content.userName
                            )}</p>
                        </div>
                    </div>`;
                        break;

                    case "gdrive_video":
                        iconClass = "bi-camera-video-fill text-info";
                        iconBg = "linear-gradient(135deg, var(--info), var(--brand))";
                        // FIX: Utiliser la structure de carte de document/lien pour les aperçus d'icône
                        cardHTML = `
                    <div class="card card-modern h-100 fade-in hover-lift contributed-doc" style="cursor: pointer;" onclick='${clickHandler}'>
                        <div class="card-body d-flex flex-column">
                             <div class="flex-grow-1 rounded d-flex align-items-center justify-content-center" style="background: ${iconBg}; min-height: 120px; margin-bottom: 1rem;">
                                <i class="bi ${iconClass}" style="font-size: 4rem; color: #fff; filter: drop-shadow(0 4px 6px rgba(0,0,0,0.2));"></i>
                            </div>
                            <h6 class="card-title mt-1 mb-1"><i class="bi bi-google me-2"></i>${escapeHtml(
                            content.title || "Vidéo Google Drive"
                        )}</h6>
                            <small class="text-muted">Type: Vidéo Drive</small>
                            <p class="video-author mt-auto text-muted"><i class="bi bi-person-circle me-1"></i>${escapeHtml(
                            content.userName
                        )}</p>
                        </div>
                    </div>`;
                        break;

                    case "gdrive_doc":
                        iconClass = "bi-file-earmark-pdf-fill text-danger";
                        iconBg = "linear-gradient(135deg, var(--danger), #841212)";
                        cardHTML = `
                    <div class="card card-modern h-100 fade-in hover-lift contributed-doc" style="cursor: pointer;" onclick='${clickHandler}'>
                        <div class="card-body d-flex flex-column">
                             <div class="flex-grow-1 rounded d-flex align-items-center justify-content-center" style="background: ${iconBg}; min-height: 120px; margin-bottom: 1rem;">
                                <i class="bi ${iconClass}" style="font-size: 4rem; color: #fff; filter: drop-shadow(0 4px 6px rgba(0,0,0,0.2));"></i>
                            </div>
                            <h6 class="card-title mt-1 mb-1"><i class="bi bi-file-earmark-text me-2"></i>${escapeHtml(
                            content.title || "Document Google Drive"
                        )}</h6>
                             <small class="text-muted">Type: Document PDF/Slide</small>
                            <p class="video-author mt-auto text-muted"><i class="bi bi-person-circle me-1"></i>${escapeHtml(
                            content.userName
                        )}</p>
                        </div>
                    </div>`;
                        break;

                    case "link":
                        iconClass = "bi-link-45deg";
                        iconBg = "linear-gradient(135deg, var(--muted), var(--text))";
                        cardHTML = `
                     <div class="card card-modern h-100 fade-in hover-lift contributed-link" style="cursor: pointer;" onclick='${clickHandler}'>
                        <div class="card-body d-flex flex-column">
                             <div class="flex-grow-1 rounded d-flex align-items-center justify-content-center" style="background: ${iconBg}; min-height: 120px; margin-bottom: 1rem;">
                                <i class="bi ${iconClass}" style="font-size: 5rem; color: #fff; filter: drop-shadow(0 4px 6px rgba(0,0,0,0.2));"></i>
                            </div>
                            <h6 class="card-title mt-1 mb-1"><i class="bi bi-globe me-2"></i>${escapeHtml(
                            content.title || content.url
                        )}</h6>
                            <small class="text-muted">Type: Lien Web</small>
                            <p class="video-author mt-auto text-muted"><i class="bi bi-person-circle me-1"></i>${escapeHtml(
                            content.userName
                        )}</p>
                        </div>
                    </div>`;
                        break;
                }
                col.innerHTML = cardHTML;
                grid.appendChild(col);
            });
        }


        function renderDashboard() {
            const continueSection = document.getElementById("continueSection");
            const inProgress = allFiles
                .filter((f) => {
                    const prog = userProgress[f.id] || 0;
                    return prog > 0 && prog < 100;
                })
                .slice(0, 3);

            if (!inProgress.length) {
                continueSection.innerHTML = `
        <div class="col-12 text-center text-muted py-3">
          <i class="bi bi-play-circle fs-1"></i>
          <p class="mt-2">Commencez un cours pour le voir ici</p>
        </div>`;
                return;
            }

            continueSection.innerHTML = "";
            inProgress.forEach((file) => {
                const meta = getFileMeta(file.mimeType);
                const progress = userProgress[file.id] || 0;

                const col = document.createElement("div");
                col.className = "col-md-4";
                col.innerHTML = `
        <div class="card border-0 bg-light fade-in">
          <div class="card-body">
            <div class="d-flex gap-3">
              <div class="text-primary" style="font-size:32px">
                <i class="${meta.icon}"></i>
              </div>
              <div class="flex-grow-1">
                <h6 class="mb-1">${escapeHtml(file.name)}</h6>
                <small class="text-muted">${meta.label}</small>
                <div class="progress mt-2" style="height:6px">
                  <div class="progress-bar" style="width:${progress}%"></div>
                </div>
                <small class="text-muted">${progress}% complété</small>
              </div>
            </div>
            <button class="btn btn-sm btn-primary w-100 mt-3" onclick="resumeCourse('${file.id
                    }')">
              <i class="bi bi-play-fill me-1"></i>Continuer
            </button>
          </div>
        </div>
      `;
                continueSection.appendChild(col);
            });
        }

        // ============================
        // QUILL EDITOR INITIALIZATION (FIXED HLJS)
        // ============================

        function imageHandler() {
            // Demander à l'utilisateur de coller une URL d'image
            const url = prompt('Entrez l\'URL de l\'image (doit être accessible publiquement) :');
            if (url) {
                const range = this.quill.getSelection(true);
                // Insérer l'image à la position du curseur
                this.quill.insertEmbed(range.index, 'image', url, Quill.sources.USER);
            }
        }

        function initializeQuill(selector) {
            const container = document.querySelector(selector);
            if (!container) { return null; }
            if (container.__quill) { return container.__quill; }

            const modules = {
                toolbar: {
                    container: [
                        [{ 'header': [1, 2, 3, false] }],
                        ['bold', 'italic', 'underline', 'strike'],
                        [{ 'color': [] }, { 'background': [] }],
                        [{ 'list': 'ordered' }, { 'list': 'bullet' }],
                        [{ 'indent': '-1' }, { 'indent': '+1' }],
                        [{ 'align': [] }],
                        ['link', 'image'],
                        ['code-block'],
                        ['clean']
                    ],
                    handlers: {
                        'image': imageHandler
                    }
                },
                // FIX: Vérifie si hljs est chargé avant d'initialiser le module syntaxe
                syntax: window.hljs ? { highlight: window.hljs.highlightAll } : false
            };

            const quill = new Quill(selector, { theme: "snow", modules: modules });
            container.__quill = quill;
            return quill;
        }

        // 1. Add/update these variables at the top of your script
        const historyQueue = document.getElementById("historyQueue");
        let videoHistory = JSON.parse(localStorage.getItem("videoHistory")) || [];

        // 2. Add this NEW function. It's the brain of the history feature.
        function addVideoToHistory(videoData) {
            // videoData should be an object: { videoId, title, thumbnailUrl }

            // Remove any existing instance of this video to avoid duplicates
            videoHistory = videoHistory.filter(
                (v) => v.videoId !== videoData.videoId
            );

            // Add the new video to the beginning of the array
            videoHistory.unshift(videoData);

            // Limit the history to the last 30 videos
            if (videoHistory.length > 30) {
                videoHistory = videoHistory.slice(0, 30);
            }

            // Save to localStorage
            localStorage.setItem("videoHistory", JSON.stringify(videoHistory));

            // Refresh the visible history panel
            renderVideoHistory();
        }

        // 3. Add this NEW function to render the history panel
        function renderVideoHistory() {
            historyQueue.innerHTML = "";
            if (videoHistory.length === 0) {
                historyQueue.innerHTML =
                    '<div class="p-3 text-center text-muted small">Votre historique de lecture est vide.</div>';
                return;
            }

            videoHistory.forEach((video) => {
                const itemEl = document.createElement("button");
                itemEl.className = "list-group-item history-item";
                itemEl.innerHTML = `
    <img src="${video.thumbnailUrl}" alt="">
    <div class="flex-grow-1">
        <span class="history-title">${escapeHtml(video.title)}</span>
    </div>
    `;
                itemEl.addEventListener("click", (e) => {
                    e.preventDefault();
                    playVideoFromHistory(video, itemEl);
                });
                historyQueue.appendChild(itemEl);
            });
        }


        // ===============================
        // 📚 BIBLIOTHÈQUE FPN (OpenLibrary)
        // ===============================

        // === DOM ELEMENTS ===
        const libraryForm = document.getElementById("librarySearchForm");
        const libraryInput = document.getElementById("librarySearchInput");
        const libraryGrid = document.getElementById("libraryResultsGrid");
        const libraryResultCount = document.getElementById("libraryResultCount");
        const loadMoreContainer = document.getElementById("loadMoreContainer");
        const libraryListView = document.getElementById("libraryList");
        const bookDetailView = document.getElementById("bookDetailView");
        const bookDetailContent = document.getElementById("bookDetailContent");

        let currentSearch = "";
        let currentPage = 1;
        const RESULTS_PER_PAGE = 20;
        let totalResults = 0;

        // === FORM SUBMIT: SEARCH BOOKS ===
        libraryForm?.addEventListener("submit", async (e) => {
            e.preventDefault();
            const query = libraryInput.value.trim();
            if (!query) return;

            currentSearch = query;
            currentPage = 1;

            await searchBooks(currentSearch, currentPage);
        });

        // === FETCH BOOKS FROM OPENLIBRARY ===
        async function searchBooks(query, page = 1) {
            libraryGrid.innerHTML = `
    <div class="col-12 text-center text-muted py-5">
        <div class="spinner-border text-primary"></div>
        <p class="mt-3">Recherche de livres...</p>
    </div>`;

            try {
                const res = await fetch(
                    `https://openlibrary.org/search.json?q=${encodeURIComponent(query)}&page=${page}`
                );
                const data = await res.json();

                totalResults = data.numFound || 0;
                libraryResultCount.textContent = totalResults.toLocaleString("fr-FR");

                renderBooks(data.docs, page > 1);

                // Toggle "Load More" button
                if (data.docs.length >= RESULTS_PER_PAGE && totalResults > page * RESULTS_PER_PAGE) {
                    loadMoreContainer.classList.remove("d-none");
                } else {
                    loadMoreContainer.classList.add("d-none");
                }
            } catch (err) {
                libraryGrid.innerHTML = `
    <div class="col-12 text-center text-danger py-5">
        <i class="bi bi-exclamation-triangle fs-2"></i>
        <p class="mt-2">${err.message}</p>
    </div>`;
            }
        }

        // === RENDER BOOK CARDS ===
        function renderBooks(books, append = false) {
            const html = books
                .map((b) => {
                    const cover = b.cover_i
                        ? `https://covers.openlibrary.org/b/id/${b.cover_i}-M.jpg`
                        : "https://via.placeholder.com/200x300?text=Aucune+Image";

                    const title = b.title || "Titre inconnu";
                    const author = b.author_name ? b.author_name.join(", ") : "Auteur inconnu";

                    return `
    <div class="col-md-3 col-sm-6">
        <div class="card h-100 shadow-sm border-0">
            <img src="${cover}" class="card-img-top rounded-top" alt="${title}">
            <div class="card-body d-flex flex-column">
                <h6 class="fw-bold mb-1" title="${title}">${title}</h6>
                <p class="text-muted small flex-grow-1">${author}</p>
                <button class="btn btn-outline-primary btn-sm mt-auto" onclick="viewBookDetail('${b.key}')">
                    <i class="bi bi-info-circle me-1"></i> Détails
                </button>
            </div>
        </div>
    </div>
    `;
                })
                .join("");

            libraryGrid.innerHTML = append ? libraryGrid.innerHTML + html : html;

            if (!books.length && !append) {
                libraryGrid.innerHTML = `
    <div class="col-12 text-center text-muted py-5">
        <i class="bi bi-book fs-1"></i>
        <p class="mt-2">Aucun résultat trouvé pour cette recherche.</p>
    </div>`;
            }
        }

        // === LOAD MORE RESULTS ===
        window.loadMoreBooks = async function () {
            currentPage++;
            await searchBooks(currentSearch, currentPage);
        };



        // === VIEW BOOK DETAILS (With Embedded Reader) ===
        window.viewBookDetail = async function (key) {
            libraryListView.classList.add("d-none");
            bookDetailView.classList.remove("d-none");

            bookDetailContent.innerHTML = `
    <div class="text-center text-muted py-5">
        <div class="spinner-border text-primary" role="status"></div>
        <p class="mt-2">Chargement des détails du livre...</p>
    </div>`;

            try {
                // Fetch book details from Open Library
                const res = await fetch(`https://openlibrary.org${key}.json`);
                const book = await res.json();

                // Prepare book cover
                const cover =
                    book.covers && book.covers.length
                        ? `https://covers.openlibrary.org/b/id/${book.covers[0]}-L.jpg`
                        : "https://via.placeholder.com/400x600?text=Aucune+Image";

                // Prepare book metadata
                const title = book.title || "Titre inconnu";
                const description =
                    (book.description && (book.description.value || book.description)) ||
                    "Aucune description disponible.";
                const authors =
                    book.authors && book.authors.length
                        ? book.authors
                            .map((a) => a.name || (a.author && a.author.name) || "Auteur inconnu")
                            .join(", ")
                        : "Auteur inconnu";
                const publishDate = book.publish_date || "Date inconnue";
                const publishers =
                    book.publishers && book.publishers.length
                        ? book.publishers.join(", ")
                        : "Éditeur inconnu";
                const isbn =
                    book.isbn_10 && book.isbn_10.length
                        ? book.isbn_10[0]
                        : book.isbn_13 && book.isbn_13.length
                            ? book.isbn_13[0]
                            : null;

                // Handle subjects with collapsible feature
                let subjectsHTML = "";
                if (book.subjects && book.subjects.length) {
                    const shown = book.subjects.slice(0, 8);
                    const hidden = book.subjects.slice(8);
                    subjectsHTML = `
    <div id="subjectsContainer">
        ${shown.map((s) => `<span class="badge bg-secondary me-1 mb-1">${s}</span>`).join("")}
        ${hidden.length ? `<span id="hiddenSubjects" class="d-none">${hidden.map((s) => `<span
                class="badge bg-secondary me-1 mb-1">${s}</span>`).join("")}</span>` : ""}
        ${hidden.length ? `<button id="toggleSubjectsBtn" class="btn btn-link p-0 mt-2 small text-decoration-none">+
            Voir plus</button>` : ""}
    </div>`;
                } else {
                    subjectsHTML = "<span class='text-muted'>Aucun sujet</span>";
                }

                // Check Internet Archive availability and prepare preview
                let readerHTML = "";
                let availabilityStatus = "";
                try {
                    const archiveRes = await fetch(`https://archive.org/metadata${key}`);
                    const archiveData = await archiveRes.json();
                    const isAvailable =
                        archiveData.is_lendable || archiveData.availability?.status === "open";
                    const identifier = book.ocaid || archiveData.identifier;

                    if (identifier && isAvailable) {
                        const readerSrc = `https://archive.org/embed/${identifier}`;
                        availabilityStatus = `<span class="badge bg-success">Disponible</span>`;
                        readerHTML = `
    <div class="mt-4 p-3 rounded-3" style="background-color: #dc3545; color: white;">
        <h6 class="fw-bold mb-3">
            <i class="bi bi-book-half me-2"></i>Prévisualisation du livre ${availabilityStatus}
        </h6>
        <div class="ratio ratio-16x9 border rounded overflow-hidden shadow">
            <iframe src="${readerSrc}" frameborder="0" allowfullscreen style="width:100%;height:600px;"></iframe>
        </div>
        <p class="small mt-3 mb-2">Consultez ce livre ou des copies numériques sur Internet Archive.</p>
        <a href="https://archive.org/details/${identifier}" target="_blank" class="btn btn-light btn-sm fw-bold">
            <i class="bi bi-box-arrow-up-right me-1"></i>Ouvrir sur archive.org
        </a>
    </div>`;
                    } else {
                        availabilityStatus = `<span class="badge bg-warning">Non disponible</span>`;
                        readerHTML = `
    <div class="mt-4 p-3 rounded-3" style="background-color: #dc3545; color: white;">
        <h6 class="fw-bold mb-2"><i class="bi bi-book-half me-2"></i>Prévisualisation non disponible
            ${availabilityStatus}</h6>
        <p class="small mb-2">Ce livre n’a pas de version lisible sur Internet Archive.</p>
        <a href="https://archive.org/details${key}" target="_blank" class="btn btn-light btn-sm fw-bold">
            <i class="bi bi-box-arrow-up-right me-1"></i>Vérifier sur archive.org
        </a>
    </div>`;
                    }
                } catch (archiveErr) {
                    availabilityStatus = `<span class="badge bg-danger">Erreur</span>`;
                    readerHTML = `
    <div class="mt-4 p-3 rounded-3" style="background-color: #dc3545; color: white;">
        <h6 class="fw-bold mb-2"><i class="bi bi-book-half me-2"></i>Erreur de prévisualisation ${availabilityStatus}
        </h6>
        <p class="small mb-2">Erreur lors de la récupération de la prévisualisation : ${archiveErr.message}</p>
        <a href="https://archive.org/details${key}" target="_blank" class="btn btn-light btn-sm fw-bold">
            <i class="bi bi-box-arrow-up-right me-1"></i>Vérifier sur archive.org
        </a>
    </div>`;
                }

                // ISBN Copy Button
                const isbnHTML = isbn
                    ? `
    <div class="input-group input-group-sm">
        <input type="text" class="form-control" value="${isbn}" readonly>
        <button class="btn btn-outline-secondary copy-isbn-btn" type="button" title="Copier l'ISBN">
            <i class="bi bi-clipboard"></i>
        </button>
    </div>`
                    : "Aucun ISBN disponible";

                // Render the enhanced book view
                bookDetailContent.innerHTML = `
    <button class="btn btn-outline-secondary mb-4" onclick="backToLibraryList()">
        <i class="bi bi-arrow-left me-2"></i> Retour
    </button>

    <div class="row g-4">
        <div class="col-md-4 text-center">
            <img src="${cover}" alt="${title}" class="img-fluid rounded shadow-sm" style="max-height: 600px;">
        </div>
        <div class="col-md-8">
            <h3 class="fw-bold" style="color:var(--brand)">${title}</h3>
            <p class="text-muted">${description}</p>

            <div class="card mt-4">
                <div class="card-body">
                    <h6 class="card-title text-uppercase text-muted mb-3">Détails du livre</h6>
                    <ul class="list-unstyled">
                        <li><strong>Auteur(s):</strong> ${authors}</li>
                        <li><strong>Date de publication:</strong> ${publishDate}</li>
                        <li><strong>Éditeur(s):</strong> ${publishers}</li>
                        <li><strong>ISBN:</strong> ${isbnHTML}</li>
                    </ul>
                    <h6 class="text-uppercase text-muted mt-4">Sujets</h6>
                    <div>${subjectsHTML}</div>
                </div>
            </div>

            ${readerHTML}
        </div>
    </div>
    `;

                // Handle "Voir plus" / "Voir moins" toggle for subjects
                const toggleBtn = document.getElementById("toggleSubjectsBtn");
                if (toggleBtn) {
                    toggleBtn.addEventListener("click", () => {
                        const hiddenSubjects = document.getElementById("hiddenSubjects");
                        const isHidden = hiddenSubjects.classList.contains("d-none");
                        hiddenSubjects.classList.toggle("d-none");
                        toggleBtn.textContent = isHidden ? "- Voir moins" : "+ Voir plus";
                    });
                }

                // Handle ISBN copy button
                const copyBtn = document.querySelector(".copy-isbn-btn");
                if (copyBtn) {
                    copyBtn.addEventListener("click", () => {
                        navigator.clipboard.writeText(isbn).then(() => {
                            copyBtn.innerHTML = '<i class="bi bi-check2"></i>';
                            setTimeout(() => {
                                copyBtn.innerHTML = '<i class="bi bi-clipboard"></i>';
                            }, 2000);
                        });
                    });
                }
            } catch (err) {
                bookDetailContent.innerHTML = `
    <div class="text-danger text-center py-5">
        <i class="bi bi-exclamation-circle fs-2"></i>
        <p class="mt-2">Erreur lors du chargement des détails : ${err.message}</p>
        <button class="btn btn-outline-secondary mt-3" onclick="backToLibraryList()">
            <i class="bi bi-arrow-left me-2"></i> Retour
        </button>
    </div>`;
            }
        };



        // === BACK TO LIST VIEW ===
        window.backToLibraryList = function () {
            bookDetailView.classList.add("d-none");
            libraryListView.classList.remove("d-none");
        };

        // === OPTIONAL: LOAD POPULAR BOOKS ON FIRST OPEN ===
        async function loadPopularBooks() {
            libraryGrid.innerHTML = `
    <div class="col-12 text-center text-muted py-5">
        <div class="spinner-border text-primary"></div>
        <p class="mt-2">Chargement des livres populaires...</p>
    </div>`;
            const res = await fetch("https://openlibrary.org/search.json?q=programming&page=1");
            const data = await res.json();
            libraryResultCount.textContent = data.numFound || 0;
            renderBooks(data.docs);
        }
        loadPopularBooks();


        // 4. Add the event listener for the "Clear History" button
        document.getElementById("clearHistoryBtn").addEventListener("click", () => {
            if (confirm("Êtes-vous sûr de vouloir effacer tout votre historique de lecture ?")) {
                videoHistory = [];
                localStorage.removeItem("videoHistory");
                renderVideoHistory();
                showToast("L'historique a été effacé.", "info");
            }
        });

        // 5. RENAME `playVideoFromQueue` to `playVideoFromHistory` and update it
        window.playVideoFromHistory = function (videoData, clickedElement) {
            const container = document.getElementById("videoContainer");
            container.innerHTML = `<iframe src="https://www.youtube.com/embed/${videoData.videoId}?autoplay=1" frameborder="0"
        allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
        allowfullscreen></iframe>`;

            // Update the active state in the queue
            document
                .querySelectorAll(".history-item.active")
                .forEach((el) => el.classList.remove("active"));
            if (clickedElement) {
                clickedElement.classList.add("active");
                clickedElement.scrollIntoView({
                    behavior: "smooth",
                    block: "center",
                });
            }

            // Add to history again to move it to the top
            addVideoToHistory(videoData);
            document.getElementById("videoTitle").innerText = videoData.title;
        };

        /*function formatDate(timestamp) {
            if (!timestamp) return "date inconnue";
            return new Date(timestamp.seconds * 1000).toLocaleString("fr-FR", {
                dateStyle: "medium",
                timeStyle: "short",
            });
        }*/

        let currentDiscussionFilter = 'recent';
        // Shows the main list of discussion threads
        // Shows the main list of discussion threads
        async function showDiscussionsList(filter = 'recent') {
            const listEl = document.getElementById("discussionsList");
            const detailEl = document.getElementById("discussionDetail");
            const threadsContainer = document.getElementById("threadsContainer");

            listEl.classList.remove("d-none");
            detailEl.classList.add("d-none");

            currentDiscussionId = null;
            currentDiscussionFilter = filter;

            // Loader
            threadsContainer.innerHTML = `
        <div class="text-center p-5">
            <div class="loader"></div>
        </div>
    `;

            try {
                // Define Firestore query
                let q;
                switch (filter) {
                    case 'popular':
                        q = query(collection(db, "discussions"), orderBy("likes", "desc"));
                        break;
                    case 'replies':
                        q = query(collection(db, "discussions"), orderBy("replyCount", "desc"));
                        break;
                    case 'admin':
                        q = query(collection(db, "discussions"), orderBy("createdAt", "desc"));
                        break;
                    case 'recent':
                    default:
                        q = query(collection(db, "discussions"), orderBy("createdAt", "desc"));
                        break;
                }

                const snapshot = await getDocs(q);
                let threads = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                // Filter admin threads only (if applicable)
                if (filter === 'admin') {
                    threads = threads.filter(t => t.authorId === ADMIN_UID || t.isByAdmin);
                }

                if (threads.length === 0) {
                    threadsContainer.innerHTML = `
                <div class="col-12 text-center text-muted py-5">
                    <i class="bi bi-chat-square-quote fs-1"></i>
                    <p class="mt-2">Aucune discussion trouvée avec ce filtre.</p>
                </div>
            `;
                    return;
                }

                threadsContainer.innerHTML = "";

                // Render each thread
                threads.forEach((thread) => {
                    const isAuthor = auth.currentUser && thread.authorId === auth.currentUser.uid;
                    const isAdminPost = thread.authorId === ADMIN_UID || thread.isByAdmin;
                    const adminIcon = isAdminPost ? ADMIN_VERIFIED_ICON : "";

                    const threadCard = document.createElement("div");
                    threadCard.className = `card card-modern hover-lift ${isAdminPost ? "admin-thread-card" : ""}`;
                    threadCard.style.cursor = "pointer";

                    threadCard.onclick = (e) => {
                        if (!e.target.closest('.reaction-btn') &&
                            !e.target.closest('.edit-thread') &&
                            !e.target.closest('.delete-thread')) {
                            showDiscussionDetail(thread.id);
                        }
                    };

                    threadCard.innerHTML = `
                <div class="card-body d-flex align-items-center justify-content-between">
                    <div class="flex-grow-1">
                        <h5 class="card-title mb-1">${escapeHtml(thread.title)}</h5>
                        <small class="text-muted">
                            Par <strong>${escapeHtml(thread.authorName)}</strong> ${adminIcon}
                            - ${formatDate(thread.createdAt)}
                        </small>
                    </div>

                    <div class="d-flex align-items-center me-3 gap-2">
                        <button class="btn btn-sm btn-outline-primary reaction-btn" data-type="like" data-id="${thread.id}" data-target="thread" title="Aimer">
                            <i class="bi bi-hand-thumbs-up"></i> <span class="reaction-count">${thread.likes || 0}</span>
                        </button>
                        <button class="btn btn-sm btn-outline-secondary reaction-btn" data-type="dislike" data-id="${thread.id}" data-target="thread" title="Ne pas aimer">
                            <i class="bi bi-hand-thumbs-down"></i> <span class="reaction-count">${thread.dislikes || 0}</span>
                        </button>
                        <button class="btn btn-sm btn-outline-warning favorite-btn" data-id="${thread.id}" title="Sauvegarder la discussion">
                            <i class="bi bi-bookmark"></i> <span class="reaction-count">${thread.favorites || 0}</span>
                        </button>
                    </div>

                    <div class="text-center ms-3" style="min-width: 80px;">
                        <span class="fs-4 fw-bold">${Math.max(0, thread.replyCount || 0)}</span><br>
                        <small class="text-muted">Réponses</small>
                    </div>

                    ${(isAuthor || isAdminPost) ? `
                    <div class="ms-3">
                        <button class="btn btn-sm btn-outline-primary edit-thread" data-id="${thread.id}">
                            <i class="bi bi-pencil"></i>
                        </button>
                        <button class="btn btn-sm btn-outline-danger delete-thread" data-id="${thread.id}">
                            <i class="bi bi-trash"></i>
                        </button>
                    </div>` : ""}
                </div>
            `;

                    threadsContainer.appendChild(threadCard);
                });

            } catch (error) {
                console.error("Error fetching discussions:", error);
                threadsContainer.innerHTML = `
            <div class="text-center text-danger p-5">
                Erreur de chargement des discussions.
            </div>
        `;
            }
        }

        // AJOUTER L'ÉCOUTEUR DE FILTRE
        document.getElementById('discussionFilter')?.addEventListener('change', (e) => {
            const filter = e.target.value;
            showDiscussionsList(filter);
        });

        // ============================
        // SHOW DISCUSSION DETAIL (FIXED PROFILE AND COUNTER DISPLAY)
        // ============================
        async function showDiscussionDetail(threadId) {
            const listEl = document.getElementById("discussionsList");
            const detailEl = document.getElementById("discussionDetail");
            const repliesContainer = document.getElementById("repliesContainer");

            listEl.classList.add("d-none");
            detailEl.classList.remove("d-none");
            currentDiscussionId = threadId;

            try {
                // Fetch thread
                const threadRef = doc(db, "discussions", threadId);
                const threadSnap = await getDoc(threadRef);

                if (threadSnap.exists()) {
                    const threadData = threadSnap.data();
                    const isAdminPost = threadData.authorId === ADMIN_UID || threadData.isByAdmin;
                    const adminIcon = isAdminPost ? ADMIN_VERIFIED_ICON : "";

                    document.getElementById("threadTitle").textContent = threadData.title;

                    // AFFICHAGE DE L'AUTEUR ORIGINAL AVEC POPOVER
                    document.getElementById("threadAuthor").innerHTML =
                        `<span class="profile-trigger" 
                            data-user-id="${threadData.authorId}" 
                            data-bs-toggle="popover" 
                            title="Profil de ${escapeHtml(threadData.authorName)}">
                            ${escapeHtml(threadData.authorName)}
                        </span>`;

                    document.getElementById("threadDate").textContent = formatDate(threadData.createdAt);
                    document.querySelector("#threadContent .ql-editor").innerHTML = threadData.content;

                    const originalPostCard = document.querySelector("#discussionDetail > .card");
                    originalPostCard.classList.toggle("admin-thread-card", isAdminPost);
                }

                // Loader for replies
                repliesContainer.innerHTML = `
            <div class="text-center p-3">
                <div class="loader"></div>
            </div>
        `;

                const repliesQuery = query(collection(db, "discussions", threadId, "replies"));
                const repliesSnapshot = await getDocs(repliesQuery);

                if (repliesSnapshot.empty) {
                    repliesContainer.innerHTML = `<p class="text-muted text-center mt-3">Aucune réponse pour le moment.</p>`;
                } else {
                    repliesContainer.innerHTML = "";
                }

                repliesSnapshot.forEach((replyDoc) => {
                    const replyData = replyDoc.data();
                    const isAuthor = auth.currentUser && replyData.authorId === auth.currentUser.uid;
                    const isAdminReply = replyData.authorId === ADMIN_UID || replyData.isByAdmin;
                    const adminIcon = isAdminReply ? ADMIN_VERIFIED_ICON : "";
                    const avatarUrl = replyData.authorPhotoURL
                        ? escapeHtml(replyData.authorPhotoURL)
                        : `https://ui-avatars.com/api/?name=${encodeURIComponent(replyData.authorName || 'Utilisateur')}`;

                    const replyCard = document.createElement("div");
                    replyCard.className = `card mb-2 ${isAdminReply ? "admin-reply-card" : ""}`;
                    replyCard.innerHTML = `
                <div class="card-body d-flex">
                    <div class="me-3 flex-shrink-0">
                        <img src="${avatarUrl}" alt="${escapeHtml(replyData.authorName)}" class="reply-avatar ${isAdminReply ? "admin-avatar" : ""}">
                    </div>
                    <div class="flex-grow-1">
                        <div class="d-flex justify-content-between align-items-start">
                            <p class="text-muted border-bottom pb-2 mb-2 flex-grow-1">
                                Par 
                                <strong class="profile-trigger"
                                        data-user-id="${replyData.authorId}" 
                                        data-bs-toggle="popover"
                                        title="Profil de ${escapeHtml(replyData.authorName)}">
                                    ${escapeHtml(replyData.authorName)}
                                </strong> 
                                ${adminIcon}
                                <small class="ms-1">le ${formatDate(replyData.createdAt)}</small>
                            </p>
                            ${isAuthor ? `
                            <div class="btn-group btn-group-sm me-3">
                                <button class="btn btn-outline-primary edit-reply" data-id="${replyDoc.id}">
                                    <i class="bi bi-pencil"></i>
                                </button>
                                <button class="btn btn-outline-danger delete-reply" data-id="${replyDoc.id}">
                                    <i class="bi bi-trash"></i>
                                </button>
                            </div>` : ""}
                            <div class="btn-group btn-group-sm reaction-controls">
                                <button class="btn btn-outline-primary reaction-btn" data-type="like" data-id="${replyDoc.id}" data-target="reply" data-thread-id="${threadId}" title="Aimer">
                                    <i class="bi bi-hand-thumbs-up"></i> <span class="reaction-count">${replyData.likes || 0}</span>
                                </button>
                                <button class="btn btn-outline-secondary reaction-btn" data-type="dislike" data-id="${replyDoc.id}" data-target="reply" data-thread-id="${threadId}" title="Ne pas aimer">
                                    <i class="bi bi-hand-thumbs-down"></i> <span class="reaction-count">${replyData.dislikes || 0}</span>
                                </button>
                            </div>
                        </div>
                        <div class="ql-snow">
                            <div class="ql-editor reply-content">${replyData.content}</div>
                        </div>
                    </div>
                </div>
            `;

                    repliesContainer.appendChild(replyCard);
                });

            } catch (error) {
                console.error("Error fetching thread detail:", error);
                repliesContainer.innerHTML = `<p class="text-danger text-center p-3">Erreur de chargement des réponses.</p>`;
            }
            // Initialisation des Popovers après le rendu des noms d'auteurs
            initializeProfilePopovers();
        }


        // =================================================================
        // 🤖 ADVANCED AI ASSISTANT INTEGRATION (v5.0 - With Media Support)
        // Features: URLs, Images, YouTube Embeds, Source Citations
        // =================================================================

        (function () {
            'use strict';

            // --- CONFIGURATION ---
            const AI_CONFIG = {
                apiUrl: 'https://openrouter.ai/api/v1/chat/completions',
                model: 'deepseek/deepseek-r1',
                temperature: 0.8,
                storageKey: 'deepseekApiKey',
                modalHistoryKey: 'aiAssistantModalHistory',
                conversationsKey: 'aiChatsSectionConversations',
                maxRetries: 3,
                retryDelay: 1000
            };

            // --- STATE MANAGEMENT ---
            const state = {
                modalHistory: [],
                conversationHistory: [],
                activeConversationId: null,
                modalInstance: null,
                streamingFrame: null,
                isProcessing: false
            };

            // --- UTILITY FUNCTIONS ---
            const utils = {
                escapeHtml(text) {
                    const div = document.createElement('div');
                    div.textContent = text;
                    return div.innerHTML;
                },

                cleanSpecialCharacters(text) {
                    return text
                        .replace(/[\u0000-\u0008\u000B\u000C\u000E-\u001F\u007F-\u009F]/g, '')
                        .replace(/\uFFFD/g, '')
                        .replace(/[\u200B-\u200D\uFEFF]/g, '')
                        .replace(/…/g, '...')
                        .replace(/['']/g, "'")
                        .replace(/[""]/g, '"')
                        .replace(/—/g, '-')
                        .replace(/–/g, '-');
                },

                debounce(func, wait) {
                    let timeout;
                    return function executedFunction(...args) {
                        const later = () => {
                            clearTimeout(timeout);
                            func(...args);
                        };
                        clearTimeout(timeout);
                        timeout = setTimeout(later, wait);
                    };
                },

                showToast(message, type = 'info') {
                    if (typeof showToast === 'function') {
                        showToast(message, type);
                    } else {
                        console.log(`[${type.toUpperCase()}] ${message}`);
                    }
                },

                // Extract YouTube video ID from various URL formats
                extractYouTubeId(url) {
                    const patterns = [
                        /(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})/,
                        /youtube\.com\/watch\?.*v=([a-zA-Z0-9_-]{11})/
                    ];

                    for (const pattern of patterns) {
                        const match = url.match(pattern);
                        if (match) return match[1];
                    }
                    return null;
                },

                // Check if URL is an image
                isImageUrl(url) {
                    return /\.(jpg|jpeg|png|gif|webp|svg|bmp|ico)(\?.*)?$/i.test(url);
                },

                // Check if URL is a YouTube link
                isYouTubeUrl(url) {
                    return /(?:youtube\.com|youtu\.be)/.test(url);
                },

                // Validate URL
                isValidUrl(string) {
                    try {
                        const url = new URL(string);
                        return url.protocol === 'http:' || url.protocol === 'https:';
                    } catch (_) {
                        return false;
                    }
                }
            };

            // --- API KEY MANAGEMENT ---
            const apiKeyManager = {
                get() {
                    return localStorage.getItem(AI_CONFIG.storageKey);
                },

                set(key) {
                    localStorage.setItem(AI_CONFIG.storageKey, key);
                },

                has() {
                    return !!this.get();
                },

                validate(key) {
                    return key && key.trim().length > 0;
                }
            };

            // --- STORAGE MANAGEMENT ---
            const storage = {
                getModalHistory() {
                    try {
                        return JSON.parse(localStorage.getItem(AI_CONFIG.modalHistoryKey)) || [];
                    } catch (e) {
                        console.error('Error loading modal history:', e);
                        return [];
                    }
                },

                saveModalHistory(history) {
                    try {
                        localStorage.setItem(AI_CONFIG.modalHistoryKey, JSON.stringify(history));
                    } catch (e) {
                        console.error('Error saving modal history:', e);
                    }
                },

                getConversations() {
                    try {
                        return JSON.parse(localStorage.getItem(AI_CONFIG.conversationsKey)) || [];
                    } catch (e) {
                        console.error('Error loading conversations:', e);
                        return [];
                    }
                },

                saveConversations(conversations) {
                    try {
                        localStorage.setItem(AI_CONFIG.conversationsKey, JSON.stringify(conversations));
                    } catch (e) {
                        console.error('Error saving conversations:', e);
                    }
                }
            };

            // --- AI API HANDLER ---
            const aiAPI = {
                async call(messages, retries = AI_CONFIG.maxRetries) {
                    const apiKey = apiKeyManager.get();
                    if (!apiKey) {
                        throw new Error('API key not configured. Please set it in the settings.');
                    }

                    try {
                        const response = await fetch(AI_CONFIG.apiUrl, {
                            method: 'POST',
                            headers: {
                                'Authorization': `Bearer ${apiKey}`,
                                'HTTP-Referer': window.location.origin,
                                'X-Title': 'FPN Learning Platform - AI Assistant',
                                'Content-Type': 'application/json',
                            },
                            body: JSON.stringify({
                                model: AI_CONFIG.model,
                                messages: messages,
                                temperature: AI_CONFIG.temperature,
                                stream: false
                            }),
                        });

                        if (!response.ok) {
                            const error = await response.json().catch(() => ({}));
                            throw new Error(error.error?.message || `API Error: ${response.status}`);
                        }

                        const data = await response.json();
                        return data.choices[0]?.message?.content || 'No response received.';
                    } catch (error) {
                        if (retries > 0 && error.message.includes('fetch')) {
                            await new Promise(resolve => setTimeout(resolve, AI_CONFIG.retryDelay));
                            return this.call(messages, retries - 1);
                        }
                        throw error;
                    }
                }
            };

            // --- ENHANCED MARKDOWN PARSER WITH MEDIA SUPPORT ---
            const markdownParser = {
                parse(text) {
                    let html = utils.cleanSpecialCharacters(text);

                    // Parse media FIRST before other markdown
                    html = this.parseYouTubeEmbeds(html);
                    html = this.parseImages(html);
                    html = this.parseLinks(html);

                    // Then parse standard markdown
                    html = this.parseCodeBlocks(html);
                    html = this.parseTables(html);
                    html = this.parseHeaders(html);
                    html = this.parseTextFormatting(html);
                    html = this.parseLists(html);
                    html = this.parseBlockquotes(html);
                    html = this.parseLineBreaks(html);

                    return html;
                },

                parseYouTubeEmbeds(html) {
                    // Match YouTube URLs and convert to embeds
                    const youtubePattern = /(?:^|\s)(https?:\/\/(?:www\.)?(?:youtube\.com\/watch\?v=|youtu\.be\/)([a-zA-Z0-9_-]{11})(?:[^\s]*))/gm;

                    html = html.replace(youtubePattern, (match, fullUrl, videoId) => {
                        return `
                    <div class="youtube-embed-container" style="position: relative; padding-bottom: 56.25%; height: 0; overflow: hidden; max-width: 100%; margin: 1rem 0; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
                        <iframe 
                            style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; border: 0; border-radius: 8px;"
                            src="https://www.youtube.com/embed/${videoId}" 
                            frameborder="0" 
                            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
                            allowfullscreen
                            loading="lazy"
                        ></iframe>
                    </div>
                    <div class="text-muted small mb-2">
                        <i class="bi bi-youtube text-danger me-1"></i>
                        <a href="${fullUrl}" target="_blank" rel="noopener noreferrer">Voir sur YouTube</a>
                    </div>
                `;
                    });

                    return html;
                },

                parseImages(html) {
                    // Parse markdown image syntax: ![alt text](url)
                    html = html.replace(/!\[([^\]]*)\]\(([^)]+)\)/g, (match, alt, url) => {
                        if (utils.isValidUrl(url) && utils.isImageUrl(url)) {
                            return `
                        <div class="markdown-image-container" style="margin: 1rem 0;">
                            <img 
                                src="${url}" 
                                alt="${utils.escapeHtml(alt)}" 
                                class="img-fluid rounded shadow-sm"
                                style="max-width: 100%; height: auto; cursor: pointer;"
                                onclick="window.open('${url}', '_blank')"
                                loading="lazy"
                            />
                            ${alt ? `<div class="text-muted small mt-2 text-center"><i class="bi bi-image me-1"></i>${utils.escapeHtml(alt)}</div>` : ''}
                        </div>
                    `;
                        }
                        return match;
                    });

                    // Also parse direct image URLs in text
                    const imageUrlPattern = /(https?:\/\/[^\s"'<>)]+\.(?:jpg|jpeg|png|gif|webp|svg)(?:\?[^\s"'<>)]*)?)/gi;
                    html = html.replace(imageUrlPattern, (match, url) => {
                        // Avoid double-parsing if already in markdown
                        if (html.includes(`src="${url}"`)) return match;

                        return `
                    <div class="markdown-image-container" style="margin: 1rem 0;">
                        <img 
                            src="${url}" 
                            alt="Image" 
                            class="img-fluid rounded shadow-sm"
                            style="max-width: 100%; height: auto; cursor: pointer;"
                            onclick="window.open('${url}', '_blank')"
                            loading="lazy"
                        />
                    </div>
                `;
                    });

                    return html;
                },

                parseLinks(html) {
                    // Parse markdown links: [text](url)
                    html = html.replace(/\[([^\]]+)\]\(([^)]+)\)/g, (match, text, url) => {
                        if (utils.isValidUrl(url)) {
                            const icon = utils.isYouTubeUrl(url) ? 'youtube' : 'link-45deg';
                            const iconColor = utils.isYouTubeUrl(url) ? 'text-danger' : 'text-primary';

                            return `
                        <a href="${url}" target="_blank" rel="noopener noreferrer" class="text-decoration-none">
                            <i class="bi bi-${icon} ${iconColor} me-1"></i>${utils.escapeHtml(text)}
                            <i class="bi bi-box-arrow-up-right ms-1 small"></i>
                        </a>
                    `;
                        }
                        return match;
                    });

                    // Parse standalone URLs (not already in links or images)
                    const urlPattern = /(?<!")(?<!src=")(?<!href=")(https?:\/\/[^\s<>"]+)/g;
                    html = html.replace(urlPattern, (match, url) => {
                        // Skip if already embedded as YouTube or image
                        if (html.includes(`src="${url}"`) || html.includes(`href="${url}"`)) {
                            return match;
                        }

                        const displayUrl = url.length > 50 ? url.substring(0, 47) + '...' : url;
                        return `
                    <a href="${url}" target="_blank" rel="noopener noreferrer" class="text-decoration-none">
                        <i class="bi bi-link-45deg text-primary me-1"></i>${utils.escapeHtml(displayUrl)}
                        <i class="bi bi-box-arrow-up-right ms-1 small"></i>
                    </a>
                `;
                    });

                    return html;
                },

                parseCodeBlocks(html) {
                    html = html.replace(/```(\w*)\n?([\s\S]*?)```/g, (match, lang, code) => {
                        const language = lang || 'plaintext';
                        const cleanCode = code.trim();
                        let highlightedCode;

                        if (window.hljs) {
                            try {
                                highlightedCode = window.hljs.highlight(cleanCode, {
                                    language,
                                    ignoreIllegals: true
                                }).value;
                            } catch (e) {
                                highlightedCode = utils.escapeHtml(cleanCode);
                            }
                        } else {
                            highlightedCode = utils.escapeHtml(cleanCode);
                        }

                        return `<pre class="code-block"><div class="code-block-header"><span class="code-language">${language}</span><button class="copy-code-btn" onclick="window.copyCodeToClipboard(this)"><i class="bi bi-clipboard"></i> Copy</button></div><code class="hljs">${highlightedCode}</code></pre>`;
                    });

                    html = html.replace(/`([^`]+)`/g, '<code class="inline-code">$1</code>');
                    return html;
                },

                parseTables(html) {
                    const lines = html.split('\n');
                    const result = [];
                    let tableRows = [];
                    let inTable = false;

                    for (let i = 0; i < lines.length; i++) {
                        const line = lines[i].trim();

                        if (line.includes('|') && line.split('|').length > 2) {
                            const cells = line.split('|').map(cell => cell.trim()).filter(cell => cell);
                            const nextLine = lines[i + 1]?.trim() || '';
                            const isSeparator = /^[\|\s:-]+$/.test(nextLine);

                            if (!inTable) {
                                inTable = true;
                                tableRows = [];
                            }

                            if (isSeparator && tableRows.length === 0) {
                                tableRows.push({ type: 'header', cells });
                                i++;
                            } else {
                                tableRows.push({ type: 'data', cells });
                            }

                            const nextNonEmpty = lines[i + 1]?.trim() || '';
                            if (!nextNonEmpty.includes('|') || i === lines.length - 1) {
                                result.push(this.buildTable(tableRows));
                                inTable = false;
                                tableRows = [];
                            }
                        } else {
                            if (inTable) {
                                result.push(this.buildTable(tableRows));
                                inTable = false;
                                tableRows = [];
                            }
                            result.push(line);
                        }
                    }

                    return result.join('\n');
                },

                buildTable(rows) {
                    if (!rows.length) return '';

                    let html = '<table class="markdown-table"><thead><tr>';
                    const headerRow = rows.find(r => r.type === 'header') || rows[0];

                    headerRow.cells.forEach(cell => {
                        html += `<th>${cell}</th>`;
                    });
                    html += '</tr></thead><tbody>';

                    const dataRows = rows.filter(r => r.type === 'data' || (r !== headerRow && r.type !== 'header'));
                    dataRows.forEach(row => {
                        html += '<tr>';
                        row.cells.forEach(cell => {
                            html += `<td>${cell}</td>`;
                        });
                        html += '</tr>';
                    });

                    html += '</tbody></table>';
                    return html;
                },

                parseHeaders(html) {
                    html = html.replace(/^######\s+(.+)$/gm, '<h6 class="markdown-h6">$1</h6>');
                    html = html.replace(/^#####\s+(.+)$/gm, '<h5 class="markdown-h5">$1</h5>');
                    html = html.replace(/^####\s+(.+)$/gm, '<h4 class="markdown-h4">$1</h4>');
                    html = html.replace(/^###\s+(.+)$/gm, '<h3 class="markdown-h3">$1</h3>');
                    html = html.replace(/^##\s+(.+)$/gm, '<h2 class="markdown-h2">$1</h2>');
                    html = html.replace(/^#\s+(.+)$/gm, '<h1 class="markdown-h1">$1</h1>');
                    return html;
                },

                parseTextFormatting(html) {
                    html = html.replace(/\*\*\*(.+?)\*\*\*/g, '<strong><em>$1</em></strong>');
                    html = html.replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>');
                    html = html.replace(/__(.+?)__/g, '<strong>$1</strong>');
                    html = html.replace(/\*(.+?)\*/g, '<em>$1</em>');
                    html = html.replace(/_(.+?)_/g, '<em>$1</em>');
                    html = html.replace(/~~(.+?)~~/g, '<del>$1</del>');
                    return html;
                },

                parseLists(html) {
                    const lines = html.split('\n');
                    const result = [];
                    let listItems = [];
                    let inList = false;
                    let listType = null;

                    for (const line of lines) {
                        const trimmed = line.trim();
                        const ulMatch = trimmed.match(/^[*\-+]\s+(.+)/);
                        const olMatch = trimmed.match(/^(\d+)\.\s+(.+)/);

                        if (ulMatch || olMatch) {
                            const content = ulMatch ? ulMatch[1] : olMatch[2];
                            const currentType = ulMatch ? 'ul' : 'ol';

                            if (!inList || listType !== currentType) {
                                if (inList && listItems.length > 0) {
                                    result.push(this.buildList(listType, listItems));
                                    listItems = [];
                                }
                                inList = true;
                                listType = currentType;
                            }

                            listItems.push(content);
                        } else {
                            if (inList && listItems.length > 0) {
                                result.push(this.buildList(listType, listItems));
                                listItems = [];
                                inList = false;
                                listType = null;
                            }
                            result.push(line);
                        }
                    }

                    if (inList && listItems.length > 0) {
                        result.push(this.buildList(listType, listItems));
                    }

                    return result.join('\n');
                },

                buildList(type, items) {
                    const tag = type === 'ul' ? 'ul' : 'ol';
                    const className = type === 'ul' ? 'markdown-ul' : 'markdown-ol';
                    let html = `<${tag} class="${className}">`;
                    items.forEach(item => {
                        html += `<li>${item}</li>`;
                    });
                    html += `</${tag}>`;
                    return html;
                },

                parseBlockquotes(html) {
                    const lines = html.split('\n');
                    const result = [];
                    let quoteLines = [];
                    let inBlockquote = false;

                    for (const line of lines) {
                        if (line.trim().startsWith('>')) {
                            inBlockquote = true;
                            quoteLines.push(line.trim().substring(1).trim());
                        } else {
                            if (inBlockquote && quoteLines.length > 0) {
                                result.push(`<blockquote class="markdown-blockquote">${quoteLines.join('<br>')}</blockquote>`);
                                quoteLines = [];
                                inBlockquote = false;
                            }
                            result.push(line);
                        }
                    }

                    if (inBlockquote && quoteLines.length > 0) {
                        result.push(`<blockquote class="markdown-blockquote">${quoteLines.join('<br>')}</blockquote>`);
                    }

                    return result.join('\n');
                },

                parseLineBreaks(html) {
                    const blocks = html.split(/\n\s*\n/);
                    const result = blocks.map(block => {
                        const trimmed = block.trim();
                        if (!trimmed) return '';

                        if (trimmed.startsWith('<') &&
                            (trimmed.includes('<h') || trimmed.includes('<ul') ||
                                trimmed.includes('<ol') || trimmed.includes('<pre') ||
                                trimmed.includes('<table') || trimmed.includes('<blockquote') ||
                                trimmed.includes('<div') || trimmed.includes('<iframe'))) {
                            return trimmed;
                        }

                        return `<p class="markdown-paragraph">${trimmed.replace(/\n/g, '<br>')}</p>`;
                    });

                    return result.join('\n');
                }
            };

            // --- CONTEXT MENU HANDLER ---
            const contextMenu = {
                init() {
                    const mainContent = document.getElementById('mainContent');
                    const menuEl = document.getElementById('aiContextMenu');

                    if (!mainContent || !menuEl) return;

                    mainContent.addEventListener('contextmenu', (e) => {
                        const selection = window.getSelection();
                        const selectedText = selection.toString().trim();
                        const targetElement = e.target;

                        if (selectedText.length > 10 && targetElement.closest('#discussionsView')) {
                            e.preventDefault();
                            this.show(e.clientX, e.clientY, selectedText, menuEl);
                        } else {
                            this.hide(menuEl);
                        }
                    });

                    document.addEventListener('click', () => this.hide(menuEl));

                    menuEl.addEventListener('click', (e) => {
                        const actionItem = e.target.closest('li');
                        if (actionItem) {
                            const action = actionItem.dataset.action;
                            const text = actionItem.dataset.text;
                            this.handleAction(action, text);
                            this.hide(menuEl);
                        }
                    });
                },

                show(x, y, text, menuEl) {
                    menuEl.innerHTML = `
                <li data-action="explain" data-text="${utils.escapeHtml(text)}">
                    <i class="bi bi-lightbulb-fill"></i> Explain This Concept
                </li>
                <li data-action="summarize" data-text="${utils.escapeHtml(text)}">
                    <i class="bi bi-card-text"></i> Summarize Selection
                </li>
                <li data-action="simplify" data-text="${utils.escapeHtml(text)}">
                    <i class="bi bi-translate"></i> Simplify This
                </li>
                <li data-action="code" data-text="${utils.escapeHtml(text)}">
                    <i class="bi bi-file-earmark-code-fill"></i> Generate Code Example
                </li>
            `;

                    menuEl.style.display = 'block';

                    const menuWidth = menuEl.offsetWidth;
                    const menuHeight = menuEl.offsetHeight;
                    const screenWidth = window.innerWidth;
                    const screenHeight = window.innerHeight;

                    menuEl.style.left = (x + menuWidth > screenWidth)
                        ? `${screenWidth - menuWidth - 10}px`
                        : `${x}px`;
                    menuEl.style.top = (y + menuHeight > screenHeight)
                        ? `${screenHeight - menuHeight - 10}px`
                        : `${y}px`;
                },

                hide(menuEl) {
                    if (menuEl) menuEl.style.display = 'none';
                },

                handleAction(action, text) {
                    if (!apiKeyManager.has()) {
                        modalManager.showApiKeyModal();
                        return;
                    }

                    const prompts = {
                        explain: `Please explain the following concept in a clear and educational way:\n\n"${text}"`,
                        summarize: `Summarize the key points of the following text:\n\n"${text}"`,
                        simplify: `Simplify this text, assuming the reader is a beginner on this topic:\n\n"${text}"`,
                        code: `Based on this concept, generate a relevant code example (e.g., in Python or JavaScript). Concept:\n\n"${text}"`
                    };

                    /*const systemMessage = {
                        role: 'system',
                        content: 'You are a helpful AI assistant. Format responses with markdown: use ## for headings, - for lists, ` for code, and when sharing resources, always provide clickable URLs. For YouTube videos, provide the full URL (e.g., https://youtube.com/watch?v=...) and I will embed them automatically. For images, use markdown syntax: ![description](image-url).'
                    };*/

                    const systemMessage = {
                        role: 'system',
                        content: 'You are an AI assistant for the FPN Learning Platform. If a user asks for your name or who created you, you must respond with the exact phrase: "I am FPN ai assistant developed by Mohamed El-Bouanani". Beyond that, act as a helpful assistant. Format responses with markdown: use ## for headings, - for lists, ` for code. When sharing resources, always provide clickable URLs. For YouTube videos, provide the full URL (e.g., https://youtube.com/watch?v=...) and I will embed them automatically. For images, you MUST use the standard Markdown format: ![description](https://.../image.jpg). Do not output raw image URLs without this Markdown syntax.'
                    };

                    state.modalHistory = [
                        systemMessage,
                        { role: 'user', content: prompts[action] }
                    ];

                    modalManager.showChatModal();
                    modalManager.runConversation();
                }
            };

            // --- MODAL MANAGER ---
            const modalManager = {
                showChatModal() {
                    const existingModal = document.getElementById('aiChatModal');
                    if (existingModal) existingModal.remove();

                    const modal = document.createElement('div');
                    modal.className = 'modal fade ai-chat-modal-glass';
                    modal.id = 'aiChatModal';
                    modal.innerHTML = `
                <div class="modal-dialog modal-lg modal-dialog-centered">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title d-flex align-items-center gap-2">
                                <i class="bi bi-robot text-info"></i> AI Assistant
                            </h5>
                            <div class="d-flex gap-2 align-items-center">
                                <button type="button" id="goToAIConversationsBtn" class="btn btn-outline-secondary btn-sm">
                                    <i class="bi bi-journal-text"></i> Chats
                                </button>
                                <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                            </div>
                        </div>
                        <div class="modal-body">
                            <div class="ai-chat-container">
                                <div class="ai-chat-log" id="aiChatLog"></div>
                                <div class="ai-chat-input-container">
                                    <form id="aiChatFollowUpForm" class="d-flex gap-2">
                                        <input type="text" id="aiFollowUpInput" class="form-control" 
                                               placeholder="Ask a follow-up question..." required autocomplete="off">
                                        <button type="submit" class="btn btn-primary">
                                            <i class="bi bi-send-fill"></i>
                                        </button>
                                        <button type="button" id="aiClearChatBtn" class="btn btn-outline-danger" 
                                                title="Clear Conversation">
                                            <i class="bi bi-trash"></i>
                                        </button>
                                    </form>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            `;

                    document.body.appendChild(modal);
                    state.modalInstance = new bootstrap.Modal(modal);
                    state.modalInstance.show();

                    modal.addEventListener('hidden.bs.modal', () => {
                        if (state.streamingFrame) {
                            cancelAnimationFrame(state.streamingFrame);
                        }
                        storage.saveModalHistory(state.modalHistory);
                        modal.remove();
                        state.modalInstance = null;
                    });

                    modal.querySelector('#aiChatFollowUpForm').addEventListener('submit', (e) => {
                        e.preventDefault();
                        this.handleFollowUp();
                    });

                    modal.querySelector('#aiClearChatBtn').addEventListener('click', () => {
                        this.clearChat();
                    });

                    modal.querySelector('#goToAIConversationsBtn')?.addEventListener('click', () => {
                        state.modalInstance?.hide();
                        document.querySelectorAll('.view-content').forEach(v => v.classList.add('d-none'));
                        const aiSection = document.getElementById('ai-chatsSection');
                        if (aiSection) aiSection.classList.remove('d-none');
                    });

                    this.renderChat();
                },

                renderChat() {
                    const chatLog = document.getElementById('aiChatLog');
                    if (!chatLog) return;

                    chatLog.innerHTML = '';
                    state.modalHistory.forEach(msg => {
                        if (msg.role !== 'system') {
                            this.appendMessage(msg.role, msg.content, true);
                        }
                    });
                },

                appendMessage(role, content, instant = false) {
                    const chatLog = document.getElementById('aiChatLog');
                    if (!chatLog) return;

                    const thinkingEl = chatLog.querySelector('.thinking-message');
                    if (thinkingEl) thinkingEl.remove();

                    const messageEl = document.createElement('div');
                    messageEl.className = role === 'user' ? 'user-message' : 'ai-message';

                    const avatar = role === 'user'
                        ? `<div class="user-avatar"><i class="bi bi-person"></i></div>`
                        : `<div class="ai-avatar"><i class="bi bi-robot"></i></div>`;

                    if (role === 'thinking') {
                        messageEl.classList.add('thinking-message');
                        messageEl.innerHTML = `${avatar}
                    <div class="ai-message-content">
                        <div class="thinking-indicator">
                            <div class="thinking-dot"></div>
                            <div class="thinking-dot"></div>
                            <div class="thinking-dot"></div>
                            thinking
                        </div>
                    </div>`;
                        chatLog.appendChild(messageEl);
                    } else {
                        messageEl.innerHTML = `${avatar}<div class="${role}-message-content"></div>`;
                        const contentEl = messageEl.querySelector(`.${role}-message-content`);
                        chatLog.appendChild(messageEl);

                        if (role === 'assistant' && !instant) {
                            this.streamResponse(contentEl, content);
                        } else {
                            contentEl.innerHTML = markdownParser.parse(content);
                        }
                    }

                    chatLog.scrollTop = chatLog.scrollHeight;
                },

                streamResponse(element, text) {
                    let index = 0;
                    element.innerHTML = '';

                    const animate = () => {
                        const chunkSize = 2;
                        if (index < text.length) {
                            const partialText = text.substring(0, index + chunkSize);
                            element.innerHTML = markdownParser.parse(partialText) +
                                '<span class="streaming-cursor"></span>';
                            index += chunkSize;
                            element.parentElement?.scrollIntoView({ behavior: 'smooth', block: 'end' });
                            state.streamingFrame = requestAnimationFrame(animate);
                        } else {
                            element.innerHTML = markdownParser.parse(text);
                            state.streamingFrame = null;
                        }
                    };
                    animate();
                },

                async runConversation() {
                    if (state.isProcessing) return;
                    state.isProcessing = true;

                    this.appendMessage('thinking', '');

                    try {
                        const responseText = await aiAPI.call(state.modalHistory);
                        state.modalHistory.push({ role: 'assistant', content: responseText });
                        storage.saveModalHistory(state.modalHistory);
                        this.appendMessage('assistant', responseText);
                    } catch (error) {
                        this.appendMessage('assistant', `**Error:** ${error.message}`);
                    } finally {
                        state.isProcessing = false;
                    }
                },

                async handleFollowUp() {
                    const input = document.getElementById('aiFollowUpInput');
                    if (!input) return;

                    const userMessage = input.value.trim();
                    if (!userMessage) return;

                    input.value = '';
                    this.appendMessage('user', userMessage);
                    state.modalHistory.push({ role: 'user', content: userMessage });

                    await this.runConversation();
                },

                clearChat() {
                    state.modalHistory = state.modalHistory.filter(msg => msg.role === 'system');
                    storage.saveModalHistory(state.modalHistory);

                    const chatLog = document.getElementById('aiChatLog');
                    if (chatLog) chatLog.innerHTML = '';

                    utils.showToast('Conversation cleared.', 'info');
                },

                showApiKeyModal() {
                    const existingModal = document.getElementById('aiKeyModal');
                    if (existingModal) existingModal.remove();

                    const modal = document.createElement('div');
                    modal.className = 'modal fade';
                    modal.id = 'aiKeyModal';
                    modal.innerHTML = `
                <div class="modal-dialog modal-dialog-centered">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h5 class="modal-title">
                                <i class="bi bi-key-fill me-2"></i> Configure AI Assistant
                            </h5>
                            <button type="button" class="btn-close" data-bs-dismiss="modal"></button>
                        </div>
                        <div class="modal-body">
                            <p class="text-muted small">
                                To use AI features, enter your API key from OpenRouter. 
                                Your key is stored securely in your browser's local storage 
                                and is never sent to our servers.
                            </p>
                            <a href="https://openrouter.ai/keys" target="_blank" class="d-block mb-3">
                                Get your free key here &rarr;
                            </a>
                            <input type="password" id="aiKeyInput" class="form-control" 
                                   placeholder="sk-or-v1-..." value="${apiKeyManager.get() || ''}">
                        </div>
                        <div class="modal-footer">
                            <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">
                                Cancel
                            </button>
                            <button type="button" class="btn btn-primary" id="saveAIKeyBtn">
                                Save Key
                            </button>
                        </div>
                    </div>
                </div>
            `;

                    document.body.appendChild(modal);
                    const modalInstance = new bootstrap.Modal(modal);
                    modalInstance.show();

                    modal.addEventListener('hidden.bs.modal', () => modal.remove());

                    modal.querySelector('#saveAIKeyBtn').addEventListener('click', () => {
                        const input = document.getElementById('aiKeyInput');
                        const key = input.value.trim();

                        if (!apiKeyManager.validate(key)) {
                            utils.showToast('Please enter a valid API key.', 'warning');
                            return;
                        }

                        apiKeyManager.set(key);
                        utils.showToast('API Key saved successfully!', 'success');
                        modalInstance.hide();
                    });
                }
            };

            // --- CONVERSATIONS MANAGER ---
            const conversationsManager = {
                init() {
                    const newBtn = document.getElementById('newAIConversationBtn');
                    const sendBtn = document.getElementById('sendAIMessageBtn');
                    const input = document.getElementById('aiMessageInput');

                    if (newBtn) {
                        newBtn.addEventListener('click', () => this.createNew());
                    }

                    if (sendBtn) {
                        sendBtn.addEventListener('click', () => this.sendMessage());
                    }

                    if (input) {
                        input.addEventListener('keydown', (e) => {
                            if (e.key === 'Enter' && !e.shiftKey) {
                                e.preventDefault();
                                this.sendMessage();
                            }
                        });
                    }

                    this.renderList();
                },

                createNew() {
                    const conversations = storage.getConversations();
                    /*const newConv = {
                        id: Date.now(),
                        title: `Chat ${conversations.length + 1}`,
                        history: [{
                            role: 'system',
                            content: 'You are a helpful AI assistant. Format responses with markdown: use ## for headings, - for lists, ` for code. When sharing resources, provide clickable URLs. For YouTube videos, provide full URLs (https://youtube.com/watch?v=...) and I will embed them. For images, use markdown: ![description](url).'
                        }],
                        createdAt: Date.now()
                    };*/

                    const newConv = {
                        id: Date.now(),
                        title: `Chat ${conversations.length + 1}`,
                        history: [{
                            role: 'system',
                            content: 'You are an AI assistant for the FPN Learning Platform. If a user asks for your name or who created you, you must respond with the exact phrase: "I am FPN ai assistant developed by Mohamed El-Bouanani". Beyond that, act as a helpful assistant. Format responses with markdown: use ## for headings, - for lists, ` for code. When sharing resources, provide clickable URLs. For YouTube videos, provide full URLs (https://youtube.com/watch?v=...) and I will embed them. For images, you MUST use the standard Markdown format: ![description](https://.../image.jpg). Do not output raw image URLs without this Markdown syntax.'
                        }],
                        createdAt: Date.now()
                    };

                    conversations.push(newConv);
                    storage.saveConversations(conversations);
                    this.renderList();
                    this.load(newConv.id);
                },

                renderList() {
                    const list = document.getElementById('aiConversationList');
                    if (!list) return;

                    const conversations = storage.getConversations();
                    list.innerHTML = '';

                    if (!conversations.length) {
                        list.innerHTML = `
                    <div class="text-muted small text-center mt-4">
                        No conversations yet
                    </div>
                `;
                        return;
                    }

                    conversations.reverse().forEach(conv => {
                        const btn = document.createElement('button');
                        btn.className = 'list-group-item list-group-item-action d-flex justify-content-between align-items-center';
                        btn.dataset.id = conv.id;

                        if (conv.id === state.activeConversationId) {
                            btn.classList.add('active');
                        }

                        btn.innerHTML = `
                    <span>
                        <i class="bi bi-chat-left-text me-2"></i>${utils.escapeHtml(conv.title)}
                    </span>
                    <button class="btn btn-sm btn-outline-danger delete-conv-btn" 
                            data-id="${conv.id}" title="Delete">
                        <i class="bi bi-trash"></i>
                    </button>
                `;

                        btn.addEventListener('click', (e) => {
                            if (!e.target.closest('.delete-conv-btn')) {
                                this.load(conv.id);
                            }
                        });

                        const deleteBtn = btn.querySelector('.delete-conv-btn');
                        deleteBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            this.delete(conv.id);
                        });

                        list.appendChild(btn);
                    });
                },

                load(id) {
                    const conversations = storage.getConversations();
                    const conv = conversations.find(c => c.id === id);
                    if (!conv) return;

                    state.activeConversationId = id;
                    state.conversationHistory = conv.history.slice();

                    const chatArea = document.getElementById('aiConversationContent');
                    if (!chatArea) return;

                    chatArea.innerHTML = '';

                    conv.history.forEach(msg => {
                        if (msg.role !== 'system') {
                            this.appendMessage(msg.role, msg.content, true);
                        }
                    });

                    this.renderList();
                    chatArea.scrollTop = chatArea.scrollHeight;
                },

                delete(id) {
                    if (!confirm('Delete this conversation?')) return;

                    let conversations = storage.getConversations();
                    conversations = conversations.filter(c => c.id !== id);
                    storage.saveConversations(conversations);

                    if (state.activeConversationId === id) {
                        state.activeConversationId = null;
                        state.conversationHistory = [];
                        const chatArea = document.getElementById('aiConversationContent');
                        if (chatArea) {
                            chatArea.innerHTML = `
                        <p class="text-muted text-center mt-5">
                            Select or start a new conversation to chat with FPN AI.
                        </p>
                    `;
                        }
                    }

                    this.renderList();
                    utils.showToast('Conversation deleted.', 'info');
                },

                appendMessage(role, content, instant = false) {
                    const chatArea = document.getElementById('aiConversationContent');
                    if (!chatArea) return;

                    const thinkingEl = chatArea.querySelector('.thinking-message');
                    if (thinkingEl) thinkingEl.remove();

                    const messageEl = document.createElement('div');
                    messageEl.className = role === 'user' ? 'user-message mb-3' : 'ai-message mb-3';

                    const avatar = role === 'user'
                        ? `<div class="user-avatar"><i class="bi bi-person"></i></div>`
                        : `<div class="ai-avatar"><i class="bi bi-robot"></i></div>`;

                    if (role === 'thinking') {
                        messageEl.classList.add('thinking-message');
                        messageEl.innerHTML = `${avatar}
                    <div class="thinking-indicator">
                        <div class="thinking-dot"></div>
                        <div class="thinking-dot"></div>
                        <div class="thinking-dot"></div>
                        thinking
                    </div>`;
                        chatArea.appendChild(messageEl);
                        return messageEl;
                    }

                    messageEl.innerHTML = `${avatar}<div class="${role}-message-content"></div>`;
                    const contentEl = messageEl.querySelector(`.${role}-message-content`);
                    chatArea.appendChild(messageEl);

                    if (role === 'assistant' && !instant) {
                        this.streamResponse(contentEl, content);
                    } else {
                        contentEl.innerHTML = markdownParser.parse(content);
                    }

                    chatArea.scrollTop = chatArea.scrollHeight;
                    return messageEl;
                },

                streamResponse(element, text) {
                    let index = 0;
                    element.innerHTML = '';

                    const animate = () => {
                        const chunkSize = 2;
                        if (index < text.length) {
                            const partialText = text.substring(0, index + chunkSize);
                            element.innerHTML = markdownParser.parse(partialText) +
                                '<span class="streaming-cursor"></span>';
                            index += chunkSize;
                            element.parentElement?.scrollIntoView({ behavior: 'smooth', block: 'end' });
                            state.streamingFrame = requestAnimationFrame(animate);
                        } else {
                            element.innerHTML = markdownParser.parse(text);
                            state.streamingFrame = null;
                        }
                    };
                    animate();
                },

                toggleSendButton(isThinking) {
                    const btn = document.getElementById('sendAIMessageBtn');
                    if (!btn) return;

                    if (isThinking) {
                        btn.disabled = true;
                        btn.innerHTML = '<span class="spinner-border spinner-border-sm"></span>';
                    } else {
                        btn.disabled = false;
                        btn.innerHTML = '<i class="bi bi-send-fill"></i>';
                    }
                },

                async sendMessage() {
                    if (!apiKeyManager.has()) {
                        modalManager.showApiKeyModal();
                        return;
                    }

                    if (!state.activeConversationId) {
                        utils.showToast('Please create or select a conversation first.', 'warning');
                        return;
                    }

                    if (state.isProcessing) return;

                    const input = document.getElementById('aiMessageInput');
                    if (!input) return;

                    const text = input.value.trim();
                    if (!text) return;

                    input.value = '';
                    state.isProcessing = true;

                    this.appendMessage('user', text);
                    state.conversationHistory.push({ role: 'user', content: text });

                    this.toggleSendButton(true);
                    this.appendMessage('thinking', '');

                    try {
                        const answer = await aiAPI.call(state.conversationHistory);

                        const thinkingEl = document.querySelector('#aiConversationContent .thinking-message');
                        if (thinkingEl) thinkingEl.remove();

                        this.appendMessage('assistant', answer);
                        state.conversationHistory.push({ role: 'assistant', content: answer });
                        this.save();
                    } catch (error) {
                        const thinkingEl = document.querySelector('#aiConversationContent .thinking-message');
                        if (thinkingEl) thinkingEl.remove();

                        this.appendMessage('assistant', `**Error:** ${error.message}`);
                        utils.showToast('Failed to get AI response. Please try again.', 'error');
                    } finally {
                        this.toggleSendButton(false);
                        state.isProcessing = false;
                    }
                },

                save() {
                    if (!state.activeConversationId) return;

                    const conversations = storage.getConversations();
                    const index = conversations.findIndex(c => c.id === state.activeConversationId);

                    if (index !== -1) {
                        conversations[index].history = state.conversationHistory;
                        conversations[index].updatedAt = Date.now();
                        storage.saveConversations(conversations);
                    }
                }
            };

            // --- GLOBAL COPY CODE FUNCTION ---
            window.copyCodeToClipboard = function (button) {
                const codeBlock = button.closest('pre');
                if (!codeBlock) return;

                const code = codeBlock.querySelector('code');
                if (!code) return;

                const text = code.innerText;

                navigator.clipboard.writeText(text).then(() => {
                    const originalHTML = button.innerHTML;
                    button.innerHTML = '<i class="bi bi-check-lg"></i> Copied!';
                    button.classList.add('btn-success');

                    setTimeout(() => {
                        button.innerHTML = originalHTML;
                        button.classList.remove('btn-success');
                    }, 2000);
                }).catch(err => {
                    console.error('Failed to copy code:', err);
                    utils.showToast('Failed to copy code to clipboard.', 'error');
                });
            };

            // --- INITIALIZATION ---
            function initialize() {
                // Load modal history
                state.modalHistory = storage.getModalHistory();

                // Initialize context menu
                contextMenu.init();

                // Initialize conversations manager
                conversationsManager.init();

                console.log('✅ AI Assistant with Media Support initialized successfully');
            }

            // Initialize when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initialize);
            } else {
                initialize();
            }

            // Expose public API for external access if needed
            window.FPNAIAssistant = {
                showApiKeyModal: () => modalManager.showApiKeyModal(),
                hasApiKey: () => apiKeyManager.has(),
                clearModalHistory: () => {
                    state.modalHistory = [];
                    storage.saveModalHistory([]);
                    utils.showToast('Modal history cleared.', 'info');
                },
                exportConversations: () => {
                    const conversations = storage.getConversations();
                    const dataStr = JSON.stringify(conversations, null, 2);
                    const dataUri = 'data:application/json;charset=utf-8,' + encodeURIComponent(dataStr);

                    const exportFileDefaultName = `fpn-ai-conversations-${Date.now()}.json`;

                    const linkElement = document.createElement('a');
                    linkElement.setAttribute('href', dataUri);
                    linkElement.setAttribute('download', exportFileDefaultName);
                    linkElement.click();

                    utils.showToast('Conversations exported successfully!', 'success');
                },
                importConversations: (jsonData) => {
                    try {
                        const conversations = JSON.parse(jsonData);
                        if (!Array.isArray(conversations)) {
                            throw new Error('Invalid format');
                        }

                        storage.saveConversations(conversations);
                        conversationsManager.renderList();
                        utils.showToast('Conversations imported successfully!', 'success');
                    } catch (error) {
                        utils.showToast('Failed to import conversations. Invalid file format.', 'error');
                    }
                }
            };

        })();
        // ============================================
        // AI API KEY SETTINGS HANDLER
        // ============================================
        (function () {
            'use strict';

            const AI_STORAGE_KEY = 'deepseekApiKey';

            function initAIApiKeySettings() {
                const form = document.getElementById('aiApiKeyForm');
                const input = document.getElementById('aiApiKeyInput');
                const toggleBtn = document.getElementById('toggleApiKeyVisibility');
                const removeBtn = document.getElementById('removeApiKeyBtn');
                const testBtn = document.getElementById('testApiKeyBtn');
                const statusDiv = document.getElementById('apiKeyStatus');

                if (!form || !input) return;

                // Load existing key
                loadApiKey();

                // Toggle visibility
                toggleBtn?.addEventListener('click', () => {
                    const isPassword = input.type === 'password';
                    input.type = isPassword ? 'text' : 'password';
                    const icon = toggleBtn.querySelector('i');
                    icon.className = isPassword ? 'bi bi-eye-slash' : 'bi bi-eye';
                });

                // Save API key
                form.addEventListener('submit', (e) => {
                    e.preventDefault();
                    saveApiKey();
                });

                // Remove API key
                removeBtn?.addEventListener('click', () => {
                    if (confirm('Êtes-vous sûr de vouloir supprimer votre clé API ? Vous ne pourrez plus utiliser l\'assistant IA.')) {
                        removeApiKey();
                    }
                });

                // Test API key
                testBtn?.addEventListener('click', () => {
                    testApiConnection();
                });
            }

            function loadApiKey() {
                const input = document.getElementById('aiApiKeyInput');
                const storedKey = localStorage.getItem(AI_STORAGE_KEY);

                if (storedKey) {
                    input.value = storedKey;
                    showStatus('success', 'Clé API configurée et prête à l\'utilisation.');
                } else {
                    showStatus('info', 'Aucune clé API configurée. Ajoutez-en une pour utiliser l\'assistant IA.');
                }
            }

            function saveApiKey() {
                const input = document.getElementById('aiApiKeyInput');
                const key = input.value.trim();

                if (!key) {
                    showStatus('warning', 'Veuillez entrer une clé API valide.');
                    return;
                }

                if (!key.startsWith('sk-or-')) {
                    showStatus('warning', 'Format de clé invalide. Les clés OpenRouter commencent par "sk-or-".');
                    return;
                }

                try {
                    localStorage.setItem(AI_STORAGE_KEY, key);
                    showStatus('success', 'Clé API enregistrée avec succès ! L\'assistant IA est maintenant disponible.');

                    // Show toast notification if available
                    if (typeof showToast === 'function') {
                        showToast('Clé API enregistrée avec succès !', 'success');
                    }
                } catch (error) {
                    showStatus('danger', 'Erreur lors de l\'enregistrement de la clé : ' + error.message);
                }
            }

            function removeApiKey() {
                try {
                    localStorage.removeItem(AI_STORAGE_KEY);
                    document.getElementById('aiApiKeyInput').value = '';
                    showStatus('info', 'Clé API supprimée. L\'assistant IA n\'est plus disponible.');

                    if (typeof showToast === 'function') {
                        showToast('Clé API supprimée.', 'info');
                    }
                } catch (error) {
                    showStatus('danger', 'Erreur lors de la suppression : ' + error.message);
                }
            }

            async function testApiConnection() {
                const testBtn = document.getElementById('testApiKeyBtn');
                const key = localStorage.getItem(AI_STORAGE_KEY);

                if (!key) {
                    showStatus('warning', 'Aucune clé API à tester. Veuillez d\'abord en enregistrer une.');
                    return;
                }

                // Show loading state
                const originalHTML = testBtn.innerHTML;
                testBtn.disabled = true;
                testBtn.innerHTML = '<span class="spinner-border spinner-border-sm me-1"></span>Test en cours...';

                try {
                    const response = await fetch('https://openrouter.ai/api/v1/chat/completions', {
                        method: 'POST',
                        headers: {
                            'Authorization': `Bearer ${key}`,
                            'Content-Type': 'application/json',
                            'HTTP-Referer': window.location.origin
                        },
                        body: JSON.stringify({
                            model: 'deepseek/deepseek-r1',
                            messages: [{ role: 'user', content: 'test' }],
                            max_tokens: 5
                        })
                    });

                    if (response.ok) {
                        showStatus('success', '✓ Connexion réussie ! Votre clé API fonctionne correctement.');
                        if (typeof showToast === 'function') {
                            showToast('Test réussi ! Clé API valide.', 'success');
                        }
                    } else {
                        const error = await response.json();
                        showStatus('danger', `✗ Erreur de connexion : ${error.error?.message || response.statusText}`);
                    }
                } catch (error) {
                    showStatus('danger', `✗ Erreur réseau : ${error.message}`);
                } finally {
                    testBtn.disabled = false;
                    testBtn.innerHTML = originalHTML;
                }
            }

            function showStatus(type, message) {
                const statusDiv = document.getElementById('apiKeyStatus');
                if (!statusDiv) return;

                statusDiv.className = `alert alert-${type}`;
                statusDiv.innerHTML = `
            <i class="bi bi-${getIconForType(type)} me-2"></i>${message}
        `;
                statusDiv.classList.remove('d-none');
            }

            function getIconForType(type) {
                const icons = {
                    success: 'check-circle-fill',
                    danger: 'exclamation-triangle-fill',
                    warning: 'exclamation-circle-fill',
                    info: 'info-circle-fill'
                };
                return icons[type] || 'info-circle';
            }

            // Initialize when DOM is ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', initAIApiKeySettings);
            } else {
                initAIApiKeySettings();
            }
        })();

        // ===================================
        // === SYSTÈME DE CARTE DE PROFIL (POPOVER) ===
        // ===================================

        // (Code des fonctions fetchUserProfile, buildProfileCardContent, initializeProfilePopovers)
        // (Ces fonctions ont été conservées dans les étapes précédentes pour éviter la redondance dans l'extrait)
        let userCache = {};

        async function fetchUserProfile(userId) {
            if (userCache[userId]) {
                return userCache[userId];
            }

            try {
                const userRef = doc(db, 'users', userId);
                const userSnap = await getDoc(userRef);

                if (userSnap.exists()) {
                    const data = userSnap.data();
                    const profile = {
                        displayName: data.name || 'Utilisateur inconnu',
                        email: data.email || 'non disponible',
                        photoURL: data.photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(data.name || data.email)}`,
                        isAdmin: userId === ADMIN_UID,
                    };
                    userCache[userId] = profile;
                    return profile;
                }
            } catch (error) {
                console.warn(`Impossible de récupérer le profil pour l'ID ${userId}:`, error);
            }

            return {
                displayName: 'Profil non trouvé',
                email: 'Erreur de chargement',
                photoURL: 'https://via.placeholder.com/50x50?text=?',
                isAdmin: false
            };
        }
        function buildProfileCardContent(profile) {
            const adminBadge = profile.isAdmin ? `<span class="badge bg-danger ms-2">Admin</span>` : '';
            const emailDisplay = profile.email && profile.email !== 'non disponible' ? `
                <p class="card-text small text-muted mb-1 d-flex align-items-center">
                    <i class="bi bi-envelope me-2"></i> ${escapeHtml(profile.email)}
                </p>
            ` : '';

            return `
                <div class="p-2" style="max-width: 250px;">
                    <div class="d-flex align-items-center mb-3 border-bottom pb-2">
                        <img src="${profile.photoURL}" class="rounded-circle me-3" style="width: 50px; height: 50px; object-fit: cover;">
                        <div>
                            <h6 class="mb-0 fw-bold">${escapeHtml(profile.displayName)} ${adminBadge}</h6>
                        </div>
                    </div>
                    ${emailDisplay}
                    <button class="btn btn-sm btn-outline-primary w-100 mt-2 disabled">
                        <i class="bi bi-person-lines-fill me-1"></i> Contacter
                    </button>
                </div>
            `;
        }
        function initializeProfilePopovers() {
            document.querySelectorAll('.profile-trigger[data-bs-toggle="popover"]').forEach(el => {
                const popover = bootstrap.Popover.getInstance(el);
                if (popover) {
                    popover.dispose();
                }
            });

            const popoverTriggers = document.querySelectorAll('.profile-trigger');

            popoverTriggers.forEach(el => {
                const userId = el.dataset.userId;

                if (!userId) return;

                if (!bootstrap.Popover.getInstance(el)) {
                    new bootstrap.Popover(el, {
                        container: 'body',
                        html: true,
                        customClass: 'profile-popover',
                        placement: 'bottom',
                        trigger: 'hover',
                        delay: { "show": 200, "hide": 100 },
                        sanitize: false,

                        content: async () => {
                            const profile = await fetchUserProfile(userId);
                            return buildProfileCardContent(profile);
                        }
                    });
                }
            });
        }
        // ===================================
        // === FIN: SYSTÈME DE CARTE DE PROFIL ===
        // ===================================

        document.addEventListener("DOMContentLoaded", () => {
            // FIX: Initialisation des éditeurs statiques
            if (document.getElementById("replyEditor")) {
                replyQuill = initializeQuill("#replyEditor");
            }
            if (document.getElementById("newDiscussionEditor")) {
                newDiscussionQuill = initializeQuill("#newDiscussionEditor");
            }
            // FIX: Initialiser editReplyQuill immédiatement
            if (document.getElementById("editReplyEditor")) {
                editReplyQuill = initializeQuill("#editReplyEditor");
            }

            // Initialize Quill editor for creating new discussions
            document
                .getElementById("newDiscussionModal")
                .addEventListener("shown.bs.modal", () => {
                    if (!newDiscussionQuill) {
                        newDiscussionQuill = initializeQuill("#newDiscussionEditor");
                    }
                });

            // Initialize Quill editor for EDITING replies
            document
                .getElementById("editReplyModal")
                .addEventListener("shown.bs.modal", () => {
                    if (!editReplyQuill) {
                        editReplyQuill = initializeQuill("#editReplyEditor");
                    }
                });

            // Initialize the main reply editor on the discussion detail page
            if (document.getElementById("discussionDetail")) {
                if (!replyQuill) {
                    replyQuill = initializeQuill("#replyEditor");
                }
            }
            document
                .getElementById("backToLibraryList")
                ?.addEventListener("click", backToLibrary);

            // Écouteur global pour le bouton plein écran des modaux
            document.addEventListener('click', (e) => {
                const toggleBtn = e.target.closest('.fullscreen-toggle-btn');
                if (toggleBtn) {
                    e.preventDefault();

                    const dialogId = toggleBtn.dataset.targetDialog;
                    const dialogElement = document.getElementById(dialogId);
                    const icon = toggleBtn.querySelector('i');

                    if (dialogElement) {
                        dialogElement.classList.toggle('modal-fullscreen');

                        const isFullscreen = dialogElement.classList.contains('modal-fullscreen');

                        if (isFullscreen) {
                            icon.classList.remove('bi-arrows-fullscreen');
                            icon.classList.add('bi-fullscreen-exit');
                            toggleBtn.title = "Quitter le plein écran";
                        } else {
                            icon.classList.remove('bi-fullscreen-exit');
                            icon.classList.add('bi-arrows-fullscreen');
                            toggleBtn.title = "Plein écran";

                            // Pour le modal document, rétablir la taille XL par défaut
                            if (dialogId === 'documentModalDialog') {
                                dialogElement.classList.remove('modal-fullscreen');
                                dialogElement.classList.add('modal-xl');
                            }
                        }
                    }
                }
            });
        });

        document
            .getElementById("editReplyForm")
            .addEventListener("submit", async (e) => {
                e.preventDefault();
                const replyId = document.getElementById("editReplyId").value;
                const newContent = editReplyQuill.root.innerHTML;

                if (!replyId || !currentDiscussionId || !newContent) return;

                try {
                    const replyRef = doc(
                        db,
                        "discussions",
                        currentDiscussionId,
                        "replies",
                        replyId
                    );
                    await updateDoc(replyRef, {
                        content: newContent,
                    });

                    showToast("Réponse mise à jour !", "success");
                    editReplyModal.hide();
                    await showDiscussionDetail(currentDiscussionId); // ATTENDRE

                } catch (error) {
                    console.error("Error updating reply:", error);
                    showToast("Erreur lors de la mise à jour: " + error.message, "danger");
                }
            });

        // ============================
        // SUBMIT REPLY FORM (FIXED COUNTER AND PERMISSION)
        // ============================
        document.getElementById("replyForm")?.addEventListener("submit", async (e) => {
            e.preventDefault();

            const user = auth.currentUser;
            if (!user || !currentDiscussionId) return;

            if (!replyQuill) {
                showToast("Erreur d'éditeur.", "danger");
                return;
            }
            const content = replyQuill.root.innerHTML;

            if (!content.trim() || content === "<p><br></p>") {
                showToast("Veuillez écrire une réponse avant de publier.", "warning");
                return;
            }

            try {
                const threadRef = doc(db, "discussions", currentDiscussionId);

                // 1. Ajouter la réponse
                await addDoc(collection(threadRef, "replies"), {
                    content,
                    authorId: user.uid,
                    authorName: user.displayName || "Anonyme",
                    authorPhotoURL: user.photoURL || null,
                    isByAdmin: user.uid === ADMIN_UID,
                    createdAt: Timestamp.now()
                });

                // 2. Mettre à jour le compteur de réponses de manière atomique (FIXED)
                await updateDoc(threadRef, { replyCount: increment(1) });

                showToast("Réponse publiée !", "success");

                // 3. Réinitialiser et rafraîchir (ATTENDRE le rafraîchissement)
                replyQuill.root.innerHTML = '';
                await showDiscussionDetail(currentDiscussionId);

            } catch (error) {
                console.error("Error submitting reply:", error);
                showToast("Erreur lors de la publication de la réponse: " + error.message, "danger");
            }
        });

        // Récupère l'état de la réaction d'un utilisateur sur un document donné.
        function getReactionState(docId, targetType, userReactions) {
            // userReactions est un objet qui pourrait ressembler à : { 'thread_ID1': 'like', 'reply_ID2': 'dislike', ... }
            const key = `${targetType}_${docId} `;
            return userReactions[key] || 'none';
        }

        async function updateReaction(docId, targetType, newReaction) {
            const user = auth.currentUser;
            if (!user) return showToast('Veuillez vous connecter pour réagir.', 'warning');

            const collectionPath = targetType === 'thread' ? 'discussions' : `discussions/${currentDiscussionId}/replies`;
            const docRef = doc(db, collectionPath, docId);
            const userRef = doc(db, 'users', user.uid);
            const reactionKey = `reactions.${targetType}_${docId}`; // Changed to dot notation for nested field

            try {
                await runTransaction(db, async (transaction) => {
                    const docSnap = await transaction.get(docRef);
                    const userSnap = await transaction.get(userRef);

                    if (!docSnap.exists()) {
                        throw new Error("Le document cible n'existe pas.");
                    }

                    const currentData = docSnap.data();
                    const currentLikes = currentData.likes || 0;
                    const currentDislikes = currentData.dislikes || 0;

                    // Récupérer l'état de réaction de l'utilisateur
                    const userReactions = userSnap.data()?.reactions || {};
                    const reactionKeySimple = `${targetType}_${docId}`;
                    const previousReaction = userReactions[reactionKeySimple] || 'none';

                    let newLikes = currentLikes;
                    let newDislikes = currentDislikes;

                    // 1. Annuler l'ancienne réaction (si elle existe)
                    if (previousReaction === 'like') {
                        newLikes = Math.max(0, newLikes - 1);
                    } else if (previousReaction === 'dislike') {
                        newDislikes = Math.max(0, newDislikes - 1);
                    }

                    // 2. Appliquer la nouvelle réaction
                    let finalReaction = 'none';
                    if (newReaction === 'like' && previousReaction !== 'like') {
                        newLikes += 1;
                        finalReaction = 'like';
                    } else if (newReaction === 'dislike' && previousReaction !== 'dislike') {
                        newDislikes += 1;
                        finalReaction = 'dislike';
                    }

                    // 3. Mettre à jour le document de la discussion/réponse (compteurs)
                    transaction.update(docRef, {
                        likes: newLikes,
                        dislikes: newDislikes,
                    });

                    // 4. Mettre à jour le document utilisateur (état)
                    if (finalReaction === 'none') {
                        transaction.update(userRef, {
                            [reactionKey]: deleteField()
                        });
                    } else {
                        transaction.update(userRef, {
                            [reactionKey]: finalReaction
                        });
                    }
                });

                // Après transaction, rafraîchir l'interface
                if (targetType === 'thread') {
                    showDiscussionsList(currentDiscussionFilter);
                } else {
                    showDiscussionDetail(currentDiscussionId);
                }

                showToast('Réaction enregistrée !', 'success');

            } catch (error) {
                console.error("Erreur de transaction de réaction:", error);
                showToast('Erreur: Impossible d\'enregistrer la réaction.', 'danger');
            }
        }

        // ÉCOUTEUR GLOBAL POUR LES CLICS SUR LES BOUTONS DE RÉACTION
        document.addEventListener('click', (e) => {
            const reactionBtn = e.target.closest('.reaction-btn');
            if (reactionBtn) {
                e.preventDefault();
                const docId = reactionBtn.dataset.id;
                const targetType = reactionBtn.dataset.target; // 'thread' ou 'reply'
                const reactionType = reactionBtn.dataset.type; // 'like' ou 'dislike'

                // La fonction updateReaction gère si c'est une désélection ou une nouvelle sélection
                updateReaction(docId, targetType, reactionType);
            }
        });

        // Gérer le bouton Favorite (simplement un toggle)
        document.addEventListener('click', async (e) => {
            const favBtn = e.target.closest('.favorite-btn');
            if (!favBtn) return;
            e.preventDefault();

            const docId = favBtn.dataset.id;
            const user = auth.currentUser;

            if (!user) {
                showToast("Veuillez vous connecter pour ajouter aux favoris.", "warning");
                return;
            }

            try {
                const docRef = doc(db, "threads", docId);
                const snap = await getDoc(docRef);

                if (!snap.exists()) {
                    showToast("Thread introuvable.", "error");
                    return;
                }

                const data = snap.data();
                const favorites = data.favorites || [];
                const isFavorited = favorites.includes(user.uid);

                // Toggle favorite
                const updatedFavorites = isFavorited
                    ? favorites.filter((id) => id !== user.uid)
                    : [...favorites, user.uid];

                await updateDoc(docRef, { favorites: updatedFavorites });

                // UI feedback
                favBtn.classList.toggle("favorited", !isFavorited);
                favBtn.innerHTML = !isFavorited
                    ? `<i class="bi bi-heart-fill text-danger"></i>`
                    : `<i class="bi bi-heart"></i>`;

                showToast(
                    isFavorited
                        ? "Retiré des favoris"
                        : "Ajouté aux favoris ❤️",
                    "success"
                );
            } catch (err) {
                console.error("Erreur favoris:", err);
                showToast("Erreur lors de la mise à jour des favoris.", "error");
            }
        });


        // ============================
        // EDIT & DELETE HANDLERS (FIXED)
        // ============================
        document.addEventListener("click", async (e) => {
            const target = e.target;
            const editReplyBtn = target.closest(".edit-reply");
            const deleteReplyBtn = target.closest(".delete-reply");
            const editThreadBtn = target.closest(".edit-thread");
            const deleteThreadBtn = target.closest(".delete-thread");


            if (editReplyBtn) {
                e.stopPropagation();
                const replyId = editReplyBtn.dataset.id;
                if (!currentDiscussionId) return showToast("ID de discussion manquant.", "danger");

                try {
                    // FIX: Utilisation de getDoc pour une récupération directe par ID
                    const replyRef = doc(db, "discussions", currentDiscussionId, "replies", replyId);
                    const replySnap = await getDoc(replyRef);

                    if (!replySnap.exists())
                        return showToast("Réponse introuvable.", "danger");

                    const replyData = replySnap.data();
                    document.getElementById("editReplyId").value = replyId;

                    // Initialize Quill editor if not already done
                    if (!editReplyQuill) {
                        editReplyQuill = initializeQuill("#editReplyEditor");
                    }

                    // Set content 
                    setTimeout(() => {
                        editReplyQuill.root.innerHTML = replyData.content;
                    }, 100);

                    editReplyModal.show();
                } catch (error) {
                    console.error("Error opening reply editor:", error);
                    showToast("Erreur lors de l'ouverture de l'éditeur: " + error.message, "danger");
                }

            } else if (deleteReplyBtn) {
                e.stopPropagation();
                const replyId = deleteReplyBtn.dataset.id;
                if (!currentDiscussionId) return;

                if (confirm("Supprimer cette réponse ?")) {
                    try {
                        // Suppression de la réponse
                        await deleteDoc(
                            doc(db, "discussions", currentDiscussionId, "replies", replyId)
                        );

                        // Mise à jour du compteur de réponses de manière atomique
                        const threadRef = doc(db, "discussions", currentDiscussionId);
                        await updateDoc(threadRef, {
                            replyCount: increment(-1),
                        });

                        showToast("Réponse supprimée.", "success");
                        await showDiscussionDetail(currentDiscussionId);

                    } catch (error) {
                        console.error("Error deleting reply:", error);
                        showToast("Erreur lors de la suppression: " + error.message, "danger");
                    }
                }
            } else if (editThreadBtn) {
                e.stopPropagation();
                const threadId = editThreadBtn.dataset.id;
                try {
                    // FIX: Utilisation de getDoc pour la récupération de la discussion
                    const threadRef = doc(db, "discussions", threadId);
                    const threadSnap = await getDoc(threadRef);

                    if (!threadSnap.exists())
                        return showToast("Discussion introuvable.", "danger");

                    const threadData = threadSnap.data();
                    const form = document.getElementById("newDiscussionForm");

                    // Logique de l'input caché
                    let idInput = form.querySelector('input[name="threadId"]');
                    if (!idInput) {
                        idInput = document.createElement("input");
                        idInput.type = "hidden";
                        idInput.name = "threadId";
                        form.appendChild(idInput);
                    }
                    idInput.value = threadId;
                    document.getElementById("newDiscussionModalLabel").innerText =
                        "Modifier la discussion";
                    document.getElementById("newDiscussionTitle").value =
                        threadData.title;

                    // Initialize Quill editor
                    if (!newDiscussionQuill) {
                        newDiscussionQuill = initializeQuill("#newDiscussionEditor");
                    }

                    // Set content
                    setTimeout(() => {
                        newDiscussionQuill.root.innerHTML = threadData.content;
                    }, 100);

                    newDiscussionModal.show();
                } catch (error) {
                    console.error("Error opening thread editor:", error);
                    showToast("Erreur lors de l'ouverture de l'éditeur: " + error.message, "danger");
                }
            } else if (deleteThreadBtn) {
                e.stopPropagation();
                const threadId = deleteThreadBtn.dataset.id;
                if (confirm("Supprimer cette discussion et ses réponses ?")) {
                    try {
                        // Suppression du thread parent
                        await deleteDoc(doc(db, "discussions", threadId));
                        showToast("Discussion supprimée.", "success");
                        await showDiscussionsList();
                    } catch (error) {
                        console.error("Error deleting thread:", error);
                        showToast("Erreur de suppression: " + error.message, "danger");
                    }
                }
            }
        });

        document
            .getElementById("editReplyForm")
            .addEventListener("submit", async (e) => {
                e.preventDefault();
                const replyId = document.getElementById("editReplyId").value;
                const newContent = editReplyQuill.root.innerHTML;

                if (!replyId || !currentDiscussionId || !newContent) return;

                try {
                    const replyRef = doc(
                        db,
                        "discussions",
                        currentDiscussionId,
                        "replies",
                        replyId
                    );
                    await updateDoc(replyRef, {
                        content: newContent,
                    });

                    showToast("Réponse mise à jour !", "success");
                    editReplyModal.hide();
                    await showDiscussionDetail(currentDiscussionId); // Refresh the view to show changes
                } catch (error) {
                    console.error("Error updating reply:", error);
                    showToast("Erreur lors de la mise à jour.", "danger");
                }
            });

        document
            .getElementById("newDiscussionForm")
            .addEventListener("submit", async (e) => {
                e.preventDefault();
                const user = auth.currentUser;
                if (!user) {
                    showToast("Veuillez vous connecter.", "warning");
                    return;
                }

                const threadId = document.querySelector(
                    'input[name="threadId"]'
                )?.value;
                const title = document
                    .getElementById("newDiscussionTitle")
                    .value.trim();
                const content = newDiscussionQuill.root.innerHTML.trim();

                if (!title || content === "<p><br></p>" || !content) {
                    showToast("Veuillez remplir tous les champs.", "warning");
                    return;
                }

                try {
                    if (threadId) {
                        // Update existing thread
                        const threadRef = doc(db, "discussions", threadId);
                        await updateDoc(threadRef, {
                            title: title,
                            content: content,
                            updatedAt: Timestamp.now(),
                        });
                        showToast("✅ Discussion mise à jour !", "success");
                    } else {
                        // Create new thread - ADD authorEmail
                        await addDoc(collection(db, "discussions"), {
                            title: title,
                            content: content,
                            authorId: user.uid,
                            authorName: user.displayName || "Anonyme",
                            isByAdmin: isAdmin,
                            authorEmail: user.email,
                            createdAt: Timestamp.now(),
                            replyCount: 0,
                        });
                        showToast("✅ Discussion créée !", "success");
                    }

                    // Close modal and reset form
                    newDiscussionModal.hide();
                    document.getElementById("newDiscussionForm").reset();
                    document.getElementById("newDiscussionModalLabel").innerText =
                        "Démarrer une nouvelle discussion";
                    if (newDiscussionQuill) newDiscussionQuill.setText("");

                    // Remove the hidden threadId input if it exists
                    const idInput = document.querySelector('input[name="threadId"]');
                    if (idInput) idInput.remove();

                    // Refresh the discussions list
                    await showDiscussionsList(); // ATTENDRE
                } catch (error) {
                    console.error("Error saving discussion:", error);
                    showToast("❌ Erreur : " + error.message, "danger");
                }
            });


        document
            .getElementById("backToDiscussions")
            .addEventListener("click", showDiscussionsList);

        function renderVideos() {
            const grid = document.getElementById("videosGrid");
            const videos = allFiles.filter((f) => f.mimeType?.startsWith("video/"));

            grid.innerHTML = "";
            if (!videos.length) {
                grid.innerHTML = `
                    <div class="col-12 text-center text-muted py-5"><i class="bi bi-camera-video fs-1"></i>
                         <p class="mt-2" > Aucune vidéo trouvée</p>
                   </div > `;
                return;
            }

            videos.forEach((file) => {
                const progress = userProgress[file.id] || 0;
                const col = document.createElement("div");
                col.className = "col-lg-6 col-xl-4";
                col.innerHTML = `
        <div class="card card-modern h-100 fade-in">
            <div class="position-relative">
                <img src="${file.thumbnailLink ||
                    " https://via.placeholder.com/400x225/dc3545/ffffff?text=Vidéo"}" class="course-thumbnail w-100"
                    alt="${escapeHtml(file.name)}">
                <div class="position-absolute top-50 start-50 translate-middle">
                    <button class="btn btn-danger btn-lg rounded-circle" style="width:64px; height:64px" onclick="playVideo('${file.id
                    }', '${escapeHtml(file.name)}', '${file.webViewLink || ""}')">
                        <i class="bi bi-play-fill fs-3"></i>
                    </button>
                </div>
                ${progress > 0
                        ? `<div class="progress-ring">${progress}%</div>`
                        : ""
                    }
            </div>
            <div class="card-body">
                <h6>${escapeHtml(file.name)}</h6>
                ${progress > 0
                        ? `
                <div class="progress mt-2" style="height:6px">
                    <div class="progress-bar bg-danger" style="width:${progress}%"></div>
                </div>`
                        : ""
                    }
                <div class="d-flex gap-2 mt-3">
                    <button class="btn btn-sm btn-outline-primary flex-grow-1" onclick="playVideo('${file.id
                    }', '${escapeHtml(file.name)}', '${file.webViewLink || ""}')">
                        <i class="bi bi-play me-1"></i>Regarder
                    </button>
                    <button class="btn btn-sm btn-outline-secondary" onclick="saveForLater('${file.id
                    }')">
                        <i class="bi bi-bookmark"></i>
                    </button>
                </div>
            </div>
        </div>
        `;
                grid.appendChild(col);
            });
        }


        // --- FETCH YOUTUBE TUTORIALS (FIXED API KEY USAGE) ---
        /*async function fetchYoutubeTutorials() {
            const grid = document.getElementById("youtubeVideosGrid");
            if (!grid) return;

            const cachedResults = sessionStorage.getItem("youtubeRecommendations");
            const cacheTimestamp = sessionStorage.getItem("youtubeRecsTimestamp");

            if (
                cachedResults &&
                cacheTimestamp &&
                Date.now() - new Date(cacheTimestamp).getTime() < 3600000
            ) {
                console.log("Chargement depuis le cache YouTube.");
                renderYoutubeResults(JSON.parse(cachedResults));
                return;
            }

            grid.innerHTML = `
        <div class="col-12 text-center">
            <div class="loader"></div>
            <p class="text-muted mt-2">Recherche de tutoriels...</p>
        </div>`;

            try {
                const queries = await getYoutubeSearchQueries();
                if (queries.length === 0) {
                    grid.innerHTML = `
                <div class="col-12 text-center text-muted py-3">
                    <i class="bi bi-search-heart fs-2"></i>
                    <p class="mt-2">Aucun cours trouvé pour générer des recommandations.</p>
                </div>`;
                    return;
                }

                // Utiliser Promise.all pour exécuter les recherches en parallèle
                const fetchPromises = queries.map(async (q) => {
                    const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(
                        q
                    )}&type=video,playlist&maxResults=3&key=${YOUTUBE_API_KEY}`;

                    const res = await fetch(url);

                    if (!res.ok) {
                        const errorData = await res.json();
                        throw new Error(`Erreur API YouTube (${res.status}): ${errorData.error.message || 'Clé invalide ou API non activée'}`);
                    }

                    return res.json();
                });

                const results = await Promise.all(fetchPromises);

                const allItems = results.flatMap((json) => json.items || []);

                sessionStorage.setItem("youtubeRecommendations", JSON.stringify(allItems));
                sessionStorage.setItem("youtubeRecsTimestamp", new Date().toISOString());

                renderYoutubeResults(allItems);
            } catch (err) {
                console.error("Erreur de chargement des tutoriels YouTube:", err);
                grid.innerHTML = `
            <div class="col-12 text-center text-danger py-3">
                <i class="bi bi-exclamation-triangle fs-2"></i>
                <p class="mt-2">Impossible de charger les recommandations.<br><small>${err.message}</small></p>
            </div>`;
            }
        }
        */
        async function fetchYoutubeTutorials() {
            const youtubeGrid = document.getElementById("youtubeVideosGrid");

            if (!YOUTUBE_API_KEY) {
                youtubeGrid.innerHTML = `
                <div class="col-12 text-center text-muted py-3">
                    <i class="bi bi-youtube text-danger fs-1"></i>
                    <p class="mt-2">Clé API YouTube non configurée</p>
                </div>
               `;
                return;
            }

            try {
                // Search for programming/education tutorials
                const searchQueries = [
                    'programming tutorials french',
                    'computer science courses',
                    'web development tutorials',
                    'python programming',
                    'javascript tutorial'
                ];

                const randomQuery = searchQueries[Math.floor(Math.random() * searchQueries.length)];
                const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&q=${encodeURIComponent(randomQuery)}&type=video&maxResults=12&key=${YOUTUBE_API_KEY}`;

                const res = await fetch(url);

                if (!res.ok) {
                    throw new Error(`YouTube API error: ${res.status}`);
                }

                const data = await res.json();

                if (!data.items || data.items.length === 0) {
                    youtubeGrid.innerHTML = `
                <div class="col-12 text-center text-muted py-3">
                    <i class="bi bi-youtube text-danger fs-1"></i>
                    <p class="mt-2">Aucun tutoriel YouTube trouvé</p>
                </div>
            `;
                    return;
                }

                youtubeGrid.innerHTML = data.items.map(video => {
                    const videoId = video.id.videoId;
                    const thumb = video.snippet.thumbnails.medium.url;
                    const title = video.snippet.title;
                    const channel = video.snippet.channelTitle;

                    return `
                <div class="col-xl-3 col-lg-4 col-md-6">
                    <div class="video-card h-100 fade-in" onclick="playYouTubeVideo('${videoId}', '${title.replace(/'/g, "\\'")}')">
                        <div class="video-thumb">
                            <img src="${thumb}" alt="${title}" class="video-thumb-img">
                            <div class="video-overlay">
                                <i class="bi bi-play-fill play-icon"></i>
                            </div>
                            <span class="video-badge">YouTube</span>
                        </div>
                        <div class="video-body d-flex flex-column">
                            <h6 class="video-title" title="${title}">
                                <i class="bi bi-youtube text-danger me-2"></i>${title}
                            </h6>
                            <p class="video-author mt-auto">
                                <i class="bi bi-person-circle me-1"></i>${channel}
                            </p>
                        </div>
                    </div>
                </div>
            `;
                }).join('');

            } catch (err) {
                console.error("Error fetching YouTube tutorials:", err);
                youtubeGrid.innerHTML = `
            <div class="col-12 text-center text-danger py-3">
                <i class="bi bi-exclamation-triangle fs-1"></i>
                <p class="mt-2">Erreur de chargement YouTube: ${err.message}</p>
            </div>
        `;
            }
        }

        window.playYouTubeVideo = function (videoId, title) {
            const container = document.getElementById("videoContainer");
            container.innerHTML = `
        <iframe src="https://www.youtube.com/embed/${videoId}?autoplay=1" 
                frameborder="0" 
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" 
                allowfullscreen>
        </iframe>
    `;

            document.getElementById("videoTitle").textContent = title;

            // Add to history
            addVideoToHistory({
                videoId: videoId,
                title: title,
                thumbnailUrl: `https://img.youtube.com/vi/${videoId}/mqdefault.jpg`
            });

            // Show playlist panel
            document.getElementById("playlistPanel").classList.remove("d-none");
            document.getElementById("playlistPanel").classList.add("d-flex");

            videoModal.show();
        };

        // Add this NEW helper function somewhere in your script
        async function getYoutubeSearchQueries() {
            const cachedFolders = sessionStorage.getItem("courseFoldersForYT");
            if (cachedFolders) {
                return JSON.parse(cachedFolders);
            }

            try {
                // Cette requête utilise la DRIVE_API_KEY publique
                const url = `https://www.googleapis.com/drive/v3/files?q='${DRIVE_FOLDER_ID}'+in+parents+and+mimeType='application/vnd.google-apps.folder'&fields=files(name)&key=${DRIVE_API_KEY}`;
                const res = await fetch(url);
                const json = await res.json();

                if (json.error) throw new Error(json.error.message);

                const queries = json.files.map((f) => f.name + " tutorial");

                sessionStorage.setItem("courseFoldersForYT", JSON.stringify(queries));
                return queries;
            } catch (err) {
                console.error(
                    "Could not fetch course folders for YouTube search (Drive API Error):",
                    err
                );
                return [];
            }
        }

        function renderYoutubeResults(items) {
            const grid = document.getElementById("youtubeVideosGrid");
            grid.innerHTML = "";
            items.forEach((item) => {
                const isPlaylist = item.id.kind === "youtube#playlist";
                const id = isPlaylist ? item.id.playlistId : item.id.videoId;
                const type = isPlaylist ? "playlist" : "video";
                const thumb =
                    item.snippet.thumbnails?.medium?.url ||
                    "https://via.placeholder.com/320x180";
                const col = document.createElement("div");
                col.className = "col-md-4";
                col.innerHTML = `
            <div class="card card-modern h-100 fade-in">
                <div class="position-relative">
                    <img src="${thumb}" class="card-img-top" alt="${escapeHtml(
                    item.snippet.title
                )}">
                    <div class="position-absolute top-50 start-50 translate-middle">
                        <button class="btn btn-danger rounded-circle" onclick="playYoutube('${type}', '${id}', '${escapeHtml(
                    item.snippet.title
                )}')">
                            <i class="bi bi-play-fill fs-4"></i>
                        </button>
                    </div>
                </div>
                <div class="card-body">
                    <h6 class="card-title">${escapeHtml(item.snippet.title)}</h6>
                    <small class="text-muted">${item.snippet.channelTitle}</small>
                </div>
            </div>
            `;
                grid.appendChild(col);
            });
        }

        function renderContributedVideos() {
            const grid = document.getElementById("contributedVideosGrid");
            grid.innerHTML = "";
            contributedContent.forEach((content) => {
                const col = document.createElement("div");
                col.className = "col-md-4";
                col.innerHTML = `
            <div class="card card-modern h-100 fade-in">
                <div class="position-relative">
                    <img src="https://img.youtube.com/vi/${content.type === " playlist" ? "" : content.id
                    }/mqdefault.jpg" class="card-img-top" alt="${escapeHtml(
                        content.title
                    )}">
                    <div class="position-absolute top-50 start-50 translate-middle">
                        <button class="btn btn-danger rounded-circle" onclick="playYoutube('${content.type
                    }', '${content.id}', '${escapeHtml(content.title)}')">
                            <i class="bi bi-play-fill fs-4"></i>
                        </button>
                    </div>
                </div>
                <div class="card-body">
                    <h6 class="card-title">${escapeHtml(
                        content.title || "Sans titre"
                    )}</h6>
                    <small class="text-muted">${content.type.charAt(0).toUpperCase() + content.type.slice(1)
                    } - Par ${escapeHtml(content.userName)}</small>
                </div>
            </div>
            `;
                grid.appendChild(col);
            });
        }

        function renderContributed() {
            const grid = document.getElementById("contributedGrid");
            if (!grid) return;
            grid.innerHTML = "";

            if (contributedContent.length === 0) {
                grid.innerHTML =
                    '<div class="col-12 text-center text-muted py-5"><i class="bi bi-cloud-slash fs-1"></i><p class="mt-2">Aucun contenu contribué pour le moment.</p></div>';
                return;
            }

            contributedContent.forEach((content) => {
                const col = document.createElement("div");
                col.className = "col-lg-4 col-md-6";
                let cardHTML = "";
                let iconClass = "";
                let iconBg = "";

                const clickHandler = `viewContributedContent(${JSON.stringify(content).replace(/'/g, "\\'")})`;

                switch (content.type) {
                    case "youtube":
                        const ytId = content.id || content.youtubeId;
                        const isPlaylist = content.youtubeType === "playlist";
                        const thumbYt = ytId ? `https://img.youtube.com/vi/${ytId}/mqdefault.jpg` : "https://via.placeholder.com/320x180/6c757d/ffffff?text=Video+YT";
                        const badgeTextYt = isPlaylist ? "Playlist" : "Vidéo";

                        cardHTML = `
                            <div class="video-card h-100 fade-in" style="cursor: pointer;" onclick='${clickHandler}'>
                                <div class="video-thumb">
                                    <img src="${thumbYt}" class="video-thumb-img" alt="${escapeHtml(
                            content.title
                        )}">
                                    <div class="video-overlay"><i class="bi bi-play-fill play-icon"></i></div>
                                    <span class="video-badge">${badgeTextYt}</span>
                                </div>
                                <div class="video-body d-flex flex-column">
                                    <h6 class="video-title"><i class="bi bi-youtube text-danger me-2"></i>${escapeHtml(
                            content.title || "Vidéo YouTube"
                        )}</h6>
                                    <p class="video-author mt-auto"><i class="bi bi-person-circle me-1"></i>${escapeHtml(
                            content.userName
                        )}</p>
                                </div>
                            </div>`;
                        break;

                    case "gdrive_video":
                        iconClass = "bi-camera-video-fill text-info";
                        iconBg = "linear-gradient(135deg, var(--info), var(--brand))";
                        cardHTML = `
                            <div class="card card-modern h-100 fade-in hover-lift contributed-doc" style="cursor: pointer;" onclick='${clickHandler}'>
                                <div class="card-body d-flex flex-column">
                                    <div class="flex-grow-1 rounded d-flex align-items-center justify-content-center" style="background: ${iconBg}; min-height: 120px; margin-bottom: 1rem;">
                                        <i class="bi ${iconClass}" style="font-size: 4rem; color: #fff; filter: drop-shadow(0 4px 6px rgba(0,0,0,0.2));"></i>
                                    </div>
                                    <h6 class="card-title mt-1 mb-1"><i class="bi bi-google me-2"></i>${escapeHtml(
                            content.title || "Vidéo Google Drive"
                        )}</h6>
                                    <small class="text-muted">Type: Vidéo Drive</small>
                                    <p class="video-author mt-auto text-muted"><i class="bi bi-person-circle me-1"></i>${escapeHtml(
                            content.userName
                        )}</p>
                                </div>
                            </div>`;
                        break;

                    case "gdrive_doc":
                        iconClass = "bi-file-earmark-pdf-fill text-danger";
                        iconBg = "linear-gradient(135deg, var(--danger), #841212)";
                        cardHTML = `
                            <div class="card card-modern h-100 fade-in hover-lift contributed-doc" style="cursor: pointer;" onclick='${clickHandler}'>
                                <div class="card-body d-flex flex-column">
                                    <div class="flex-grow-1 rounded d-flex align-items-center justify-content-center" style="background: ${iconBg}; min-height: 120px; margin-bottom: 1rem;">
                                        <i class="bi ${iconClass}" style="font-size: 4rem; color: #fff; filter: drop-shadow(0 4px 6px rgba(0,0,0,0.2));"></i>
                                    </div>
                                    <h6 class="card-title mt-1 mb-1"><i class="bi bi-file-earmark-text me-2"></i>${escapeHtml(
                            content.title || "Document Google Drive"
                        )}</h6>
                                    <small class="text-muted">Type: Document PDF/Slide</small>
                                    <p class="video-author mt-auto text-muted"><i class="bi bi-person-circle me-1"></i>${escapeHtml(
                            content.userName
                        )}</p>
                                </div>
                            </div>`;
                        break;

                    case "link":
                        iconClass = "bi-link-45deg";
                        iconBg = "linear-gradient(135deg, var(--muted), var(--text))";
                        cardHTML = `
                            <div class="card card-modern h-100 fade-in hover-lift contributed-link" style="cursor: pointer;" onclick='${clickHandler}'>
                                <div class="card-body d-flex flex-column">
                                    <div class="flex-grow-1 rounded d-flex align-items-center justify-content-center" style="background: ${iconBg}; min-height: 120px; margin-bottom: 1rem;">
                                        <i class="bi ${iconClass}" style="font-size: 5rem; color: #fff; filter: drop-shadow(0 4px 6px rgba(0,0,0,0.2));"></i>
                                    </div>
                                    <h6 class="card-title mt-1 mb-1"><i class="bi bi-globe me-2"></i>${escapeHtml(
                            content.title || content.url
                        )}</h6>
                                    <small class="text-muted">Type: Lien Web</small>
                                    <p class="video-author mt-auto text-muted"><i class="bi bi-person-circle me-1"></i>${escapeHtml(
                            content.userName
                        )}</p>
                                </div>
                            </div>`;
                        break;
                }

                if (cardHTML) {
                    col.innerHTML = cardHTML;
                    grid.appendChild(col);
                }
            });
        }

        window.viewContributedContent = function (content) {
            const safeContent = JSON.parse(JSON.stringify(content));

            switch (safeContent.type) {
                case "youtube":
                    playYoutube(
                        safeContent.youtubeType,
                        safeContent.youtubeId,
                        safeContent.title
                    );
                    break;

                // --- THE FIX: NEW CASE FOR GDRIVE VIDEOS ---
                case "gdrive_video":
                    // Open in the VIDEO modal
                    document.getElementById("videoTitle").innerText =
                        safeContent.title || "Vidéo";
                    const videoContainer = document.getElementById("videoContainer");
                    videoContainer.innerHTML = `<iframe src="https://drive.google.com/file/d/${safeContent.gdriveId}/preview"
                frameborder="0" allow="autoplay" allowfullscreen></iframe>`;

                    // Hide the history panel for non-YouTube videos
                    playlistPanel.classList.add("d-none");
                    playlistPanel.classList.remove("d-flex");

                    videoModal.show();
                    break;

                case "gdrive_doc":
                    // Open in the DOCUMENT modal
                    document.getElementById("documentTitle").innerText =
                        safeContent.title || "Document";
                    const docContainer = document.getElementById("documentContainer");
                    docContainer.innerHTML = `<iframe src="https://drive.google.com/file/d/${safeContent.gdriveId}/preview"
                frameborder="0"></iframe>`;
                    documentModal.show();
                    break;

                case "link":
                    if (
                        confirm(
                            `Vous allez être redirigé vers un lien externe:\n\n${safeContent.url}\n\nVoulez-vous continuer ?`
                        )
                    ) {
                        window.open(safeContent.url, "_blank", "noopener,noreferrer");
                    }
                    break;
            }
        };

        // 1. Add these variables at the top
        let favoriteDocuments =
            JSON.parse(localStorage.getItem("favoriteDocuments")) || [];

        // 2. Add this new function to handle toggling favorites
        window.toggleFavorite = function (fileId, event) {
            event.stopPropagation(); // Prevents the card from being clicked
            const starIcon = event.currentTarget.querySelector("i");

            const index = favoriteDocuments.indexOf(fileId);
            if (index > -1) {
                favoriteDocuments.splice(index, 1); // Remove from favorites
                starIcon.classList.remove("bi-star-fill");
                starIcon.classList.add("bi-star");
            } else {
                favoriteDocuments.push(fileId); // Add to favorites
                starIcon.classList.add("bi-star-fill");
                starIcon.classList.remove("bi-star");
            }

            localStorage.setItem(
                "favoriteDocuments",
                JSON.stringify(favoriteDocuments)
            );
            showToast("Favoris mis à jour !", "info");
        };

        function renderAssignments() {
            const grid = document.getElementById("assignmentsGrid");
            grid.innerHTML =
                `<div class="col-12 text-center text-muted py-5"><i class="bi bi-tools fs-1"></i>
                    <p class="mt-2"> Cette fonctionnalité est en cours de développement.</p>
                </div >`;
        }

        const eventModal = new bootstrap.Modal(
            document.getElementById("eventModal")
        );
        let calendar; // Will hold the FullCalendar instance
        let alarmIntervalId = null; // To manage the alarm checking interval

        // --- ALARM SOUNDS & HELPERS ---
        const alarmSounds = {
            chime: new Audio(
                "https://cdn.freesound.org/previews/510/510323_10899534-lq.mp3"
            ),
            notification: new Audio(
                "https://cdn.freesound.org/previews/415/415763_6142149-lq.mp3"
            ),
            digital: new Audio(
                "https://cdn.freesound.org/previews/142/142641_228222-lq.mp3"
            ),
        };

        function formatDateTimeLocal(date) {
            if (!date) return "";
            const ten = (i) => (i < 10 ? "0" : "") + i; const YYYY = date.getFullYear(); const
                MM = ten(date.getMonth() + 1); const DD = ten(date.getDate()); const HH = ten(date.getHours());
            const II = ten(date.getMinutes()); return `${YYYY}-${MM}-${DD}T${HH}:${II}`;
        } // --- CORE
        async function renderCalendar() {
            const
                calendarEl = document.getElementById("calendar"); if (!calendarEl) return; if (calendar)
                calendar.destroy(); const user = auth.currentUser; if (!user) {
                    calendarEl.innerHTML = '<div class="text-center text-muted p-5"><i class="bi bi-lock fs-1"></i><p>Connectez-vous pour voir le calendrier.</p></div>'
                        ; return;
                } calendar = new FullCalendar.Calendar(calendarEl, {
                    themeSystem: "bootstrap5",
                    locale: "fr", headerToolbar: {
                        left: "prev,next today", center: "title",
                        right: "dayGridMonth,timeGridWeek,timeGridDay,listWeek",
                    }, initialView: "dayGridMonth",
                    editable: true, selectable: true, slotMinTime: "06:00:00", slotMaxTime: "23:00:00",
                    slotDuration: "00:30:00", height: "auto", nowIndicator: true, displayEventTime: true,
                    displayEventEnd: true, eventDisplay: "block", events: async (fetchInfo, successCallback) => {
                        const eventsCol = collection(db, "users", user.uid, "events");
                        const eventSnapshot = await getDocs(query(eventsCol)); // No need to order here,

                        const events = eventSnapshot.docs.map((doc) => {
                            const data = doc.data();

                            // This is the logic that adds the class for the alarm icon
                            const classNames =
                                data.alarm && data.alarm !== "none" ? ["has-alarm"] : [];

                            const event = {
                                id: doc.id,
                                title: data.title,
                                start: data.start.toDate(),
                                end: data.end ? data.end.toDate() : null,
                                allDay: data.allDay,
                                backgroundColor: data.color || "var(--brand)",
                                borderColor: data.color || "var(--brand)",
                                classNames: classNames, // Assign the class here
                                extendedProps: {
                                    alarm: data.alarm,
                                    sound: data.sound,
                                    color: data.color,
                                },
                            };

                            // This handles correct multi-day display
                            if (event.allDay && event.end) {
                                event.end.setDate(event.end.getDate() + 1);
                            }
                            return event;
                        });
                        successCallback(events);
                    },

                    select: (selectionInfo) => {
                        document.getElementById("eventForm").reset();
                        document.getElementById("eventId").value = "";
                        document.getElementById("deleteEventButton").style.display = "none";
                        document.getElementById("eventModalLabel").innerText =
                            "Ajouter un événement";

                        document.getElementById("eventStart").value = formatDateTimeLocal(
                            selectionInfo.start
                        );
                        document.getElementById("eventEnd").value = formatDateTimeLocal(
                            selectionInfo.end
                        );
                        document.getElementById("eventAllDay").checked =
                            selectionInfo.allDay;
                        document.getElementById("eventColor").value = "#0b3b61";
                        document.getElementById("eventAlarm").value = "none";
                        document.getElementById("eventSound").value = "chime";

                        eventModal.show();
                    },

                    eventClick: (clickInfo) => {
                        const event = clickInfo.event;
                        document.getElementById("eventForm").reset();
                        document.getElementById("eventId").value = event.id;
                        document.getElementById("eventModalLabel").innerText =
                            "Modifier l'événement";

                        document.getElementById("eventTitle").value = event.title;
                        document.getElementById("eventStart").value = formatDateTimeLocal(
                            event.start
                        );
                        document.getElementById("eventEnd").value = formatDateTimeLocal(
                            event.end || event.start
                        );
                        document.getElementById("eventAllDay").checked = event.allDay;
                        document.getElementById("eventAlarm").value =
                            event.extendedProps.alarm || "none";
                        document.getElementById("eventSound").value =
                            event.extendedProps.sound || "chime";
                        document.getElementById("eventColor").value =
                            event.extendedProps.color || "#0b3b61";

                        document.getElementById("deleteEventButton").style.display =
                            "block";
                        eventModal.show();
                    },

                    eventResize: async (resizeInfo) => {
                        const { id, start, end } = resizeInfo.event;
                        try {
                            await updateDoc(doc(db, "users", user.uid, "events", id), {
                                start: Timestamp.fromDate(start),
                                end: Timestamp.fromDate(end),
                            });
                            showToast("Durée de l'événement mise à jour !", "success");
                        } catch (error) {
                            showToast("Erreur lors du redimensionnement.", "danger");
                            resizeInfo.revert();
                        }
                    },

                    eventDrop: async (dropInfo) => {
                        const { id, start, end, allDay } = dropInfo.event;
                        try {
                            await updateDoc(doc(db, "users", user.uid, "events", id), {
                                start: Timestamp.fromDate(start),
                                end: Timestamp.fromDate(end || start),
                                allDay: allDay,
                            });
                            showToast("Événement déplacé !", "success");
                        } catch (error) {
                            showToast("Erreur lors du déplacement.", "danger");
                            dropInfo.revert();
                        }
                    },
                });

            calendar.render();
        }

        // --- EVENT FORM SUBMIT HANDLER ---
        document
            .getElementById("eventForm")
            .addEventListener("submit", async (e) => {
                e.preventDefault();
                const user = auth.currentUser;
                if (!user) {
                    showToast("Veuillez vous connecter.", "warning");
                    return;
                }

                const eventId = document.getElementById("eventId").value;
                const allDay = document.getElementById("eventAllDay").checked;

                let start, end;
                try {
                    start = new Date(document.getElementById("eventStart").value);
                    end = new Date(document.getElementById("eventEnd").value);

                    if (isNaN(start.getTime()) || isNaN(end.getTime())) {
                        throw new Error("Veuillez sélectionner des dates valides.");
                    }

                    if (end < start) { throw new Error("La date de fin doit être après la date de début."); }
                } catch (err) { showToast(err.message, "danger"); return; } if (allDay) {
                    start.setHours(0, 0, 0, 0); end.setHours(23, 59, 59, 999);
                } const eventData = {
                    title:
                        document.getElementById("eventTitle").value.trim() || "Sans titre", start:
                        Timestamp.fromDate(start), end: Timestamp.fromDate(end), allDay: allDay, alarm:
                        document.getElementById("eventAlarm").value, sound:
                        document.getElementById("eventSound").value, color:
                        document.getElementById("eventColor").value || "#0b3b61", userId: user.uid, updatedAt:
                        Timestamp.now(),
                }; try {
                    if (eventId) {
                        await updateDoc(doc(db, "users",
                            user.uid, "events", eventId), eventData); showToast("✅ Événement mis à jour!", "success");
                    } else {
                        eventData.createdAt = Timestamp.now(); await addDoc(
                            collection(db, "users", user.uid, "events"), eventData); showToast("✅ Événementajouté!", "success");
                    } eventModal.hide(); if (calendar) calendar.refetchEvents();
                }
                catch (error) {
                    console.error("Error saving event:", error); showToast(`❌ Erreur:
                                ${error.message}`, "danger");
                }
            });
        function checkAlarms() {
            const user = auth.currentUser; if (!user) return; const now = new Date();
            const eventsQuery = query(collection(db, "users", user.uid, "events"));
            getDocs(eventsQuery).then((snapshot) => {
                snapshot.forEach((docSnap) => {
                    const event = { id: docSnap.id, ...docSnap.data() };

                    if (event.alarm && event.alarm !== "none") {
                        const startTime = event.start.toDate();
                        const alarmMinutes = parseInt(event.alarm);
                        const alarmTime = new Date(
                            startTime.getTime() - alarmMinutes * 60000
                        );

                        const timeDiff = now.getTime() - alarmTime.getTime();

                        // Trigger if within 1 minute of alarm time
                        if (timeDiff >= 0 && timeDiff < 60000) {
                            const triggeredKey = `alarm_${event.id
                                }_${alarmTime.toISOString()}`; if (!sessionStorage.getItem(triggeredKey)) {
                                    triggerAlarm(event, alarmMinutes); sessionStorage.setItem(triggeredKey, "true");
                                }
                        }
                    }
                });
            }).catch((error) => {
                console.error("Error checking alarms:", error);
            });
        }

        function triggerAlarm(event, minutesBefore) {
            const sound = alarmSounds[event.sound] || alarmSounds.chime;
            sound.play().catch((e) => console.warn("Audio autoplay blocked:", e));

            const eventStartTime = event.start
                .toDate()
                .toLocaleTimeString("fr-FR", {
                    hour: "2-digit",
                    minute: "2-digit",
                });

            const notificationMessage =
                minutesBefore === 0
                    ? `🔔 "${event.title}" commence maintenant à ${eventStartTime}!`
                    : `⏰ Rappel: "${event.title}" commence dans ${minutesBefore} minutes
                                    (${eventStartTime})`;

            // Browser notification
            if (Notification.permission === "granted") {
                new Notification("Rappel d'événement 📅", {
                    body: notificationMessage,
                    icon: "https://img.icons8.com/fluent/96/000000/alarm.png",
                    badge: "https://img.icons8.com/fluent/48/000000/alarm.png",
                    tag: `event-${event.id}`,
                    requireInteraction: true,
                });
            }

            // In-app toast
            showToast(notificationMessage, "warning");
        }

        // --- INITIALIZE & STOP ALARM SYSTEM ---
        function initializeAlarmSystem() {
            // Request notification permission
            if ("Notification" in window && Notification.permission === "default") {
                Notification.requestPermission().then((permission) => {
                    if (permission === "granted") {
                        showToast("✅ Notifications activées", "success");
                    }
                });
            }

            // Preload sounds
            Object.values(alarmSounds).forEach((sound) => {
                sound.load();
                sound.volume = 0.7;
            });

            // Start checking every 30 seconds for better responsiveness
            if (alarmIntervalId) clearInterval(alarmIntervalId);
            alarmIntervalId = setInterval(checkAlarms, 30000);

            // Check immediately
            checkAlarms();
        }

        function stopAlarmSystem() {
            if (alarmIntervalId) {
                clearInterval(alarmIntervalId);
                alarmIntervalId = null;
            }
        }

        // ========================================================================
        // === END: COMPLETE CALENDAR & ALARM SYSTEM
        // ========================================================================

        // === FIX: Save event correctly with title, start, end, color, and userId ===
        async function saveEventToFirestore(userId, eventData) {
            try {
                const docRef = await addDoc(
                    collection(db, `users/${userId}/events`),
                    {
                        title: eventData.title,
                        start: eventData.start,
                        end: eventData.end,
                        color: eventData.color,
                        userId: userId,
                    }
                );
                console.log("✅ Event saved:", docRef.id);
            } catch (error) {
                console.error("❌ Error saving event:", error);
            }
        }

        document
            .getElementById("deleteEventButton")
            .addEventListener("click", async () => {
                const user = auth.currentUser;
                const eventId = document.getElementById("eventId").value;
                if (!user || !eventId) return;

                if (confirm("Êtes-vous sûr de vouloir supprimer cet événement ?")) {
                    try {
                        await deleteDoc(doc(db, "users", user.uid, "events", eventId));
                        showToast("Événement supprimé.", "info");
                        eventModal.hide();
                        calendar.refetchEvents();
                    } catch (error) {
                        showToast("Erreur lors de la suppression.", "danger");
                    }
                }
            });

        function renderNotes() {
            const list = document.getElementById("notesList");
            list.innerHTML = "";

            if (notes.length === 0) {
                list.innerHTML =
                    `<div class="col-12 text-center text-muted py-5"><iclass="bi bi-journal-x fs-1" ></i >
                    <p class="mt-2">Vous n\'avez aucune note.</p>
                                    </div > `;
                return;
            }

            notes.forEach((note, index) => {
                const col = document.createElement("div");
                col.className = "col-md-4";
                col.innerHTML = `
                                    <div class="card card-modern fade-in">
                                        <div class="card-body">
                                            <h6>${note.title}</h6>
                                            <p class="text-muted small">${note.date}</p>
                                            <p>${note.content.substring(0, 100)}...</p>
                                            <button class="btn btn-sm btn-outline-danger"
                                                onclick="deleteNote(${index})">Supprimer</button>
                                        </div>
                                    </div>
                                    `;
                list.appendChild(col);
            });
        }

        window.deleteNote = function (index) {
            notes.splice(index, 1);
            localStorage.setItem("notes", JSON.stringify(notes));
            renderNotes();
        };


        /*
        function createMessageElement(msg, isMe, currentUserId, threadId, avatarUrl, isSameSender) {
            const msgWrapper = document.createElement('div');
            msgWrapper.className = `message-wrapper d-flex align-items-end ${isSameSender ? 'mt-1' : 'mt-3'} ${isMe ? 'justify-content-end' : 'justify-content-start'}`;
            msgWrapper.setAttribute('data-message-id', msg.id);
            msgWrapper.style.position = 'relative';

            // Avatar
            if (!isMe) {
                if (avatarUrl) {
                    msgWrapper.innerHTML += `<img src="${avatarUrl}" class="rounded-circle me-2 ${isSameSender ? 'invisible' : ''}" style="width: 28px; height: 28px; object-fit: cover; border: 1px solid var(--border);">`;
                } else {
                    msgWrapper.innerHTML += `<div class="d-flex align-items-center justify-content-center rounded-circle me-2 bg-light ${isSameSender ? 'invisible' : ''}" style="width: 28px; height: 28px;"><i class="bi bi-person text-muted" style="font-size: 14px;"></i></div>`;
                }
            }

            // Bulle de message
            const msgBubble = document.createElement('div');
            msgBubble.style.maxWidth = '75%';
            msgBubble.style.wordBreak = 'break-word';
            msgBubble.style.position = 'relative';

            if (isMe) {
                msgBubble.className = 'message-bubble shadow-sm';
                msgBubble.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
                msgBubble.style.color = 'white';
                msgBubble.style.borderRadius = '18px 18px 4px 18px';
                msgBubble.style.padding = '10px 14px';
            } else {
                msgBubble.className = 'message-bubble shadow-sm border';
                msgBubble.style.background = 'var(--surface, #f8f9fa)';
                msgBubble.style.color = 'var(--text, #212529)';
                msgBubble.style.borderRadius = '18px 18px 18px 4px';
                msgBubble.style.padding = '10px 14px';
            }

            // Contenu du message
            msgBubble.innerHTML = `
                <div class="message-text" style="white-space: pre-wrap;">${escapeHtml(msg.content)}</div>
                    <div class="message-time text-end mt-1" style="font-size: 0.65rem; opacity: 0.7;">
                        ${formatDateShort(msg.createdAt)}
                    </div>
                    ${renderReactions(msg.reactions, currentUserId, msg.id, threadId)}
                `;

            // Boutons d'actions (apparaissent au survol)
            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'message-actions';
            actionsDiv.innerHTML = `
                <button class="message-action-btn" 
                    onclick="showReactionMenu(event, '${threadId}', '${msg.id}', '${currentUserId}')"
                    title="Réagir">
                    <i class="bi bi-emoji-smile"></i>
                </button>
                <button class="message-action-btn" 
                    onclick="togglePinMessage('${threadId}', '${msg.id}')"
                    title="Épingler">
                    <i class="bi bi-pin-angle"></i>
                </button>
            `;

            msgBubble.appendChild(actionsDiv);
            msgWrapper.appendChild(msgBubble);

            // Avatar de l'utilisateur connecté (si message envoyé)
            if (isMe) {
                if (avatarUrl) {
                    msgWrapper.innerHTML += `<img src="${avatarUrl}" class="rounded-circle ms-2 ${isSameSender ? 'invisible' : ''}" style="width: 28px; height: 28px; object-fit: cover; border: 1px solid var(--brand);">`;
                } else {
                    msgWrapper.innerHTML += `<div class="d-flex align-items-center justify-content-center rounded-circle ms-2 bg-primary-subtle ${isSameSender ? 'invisible' : ''}" style="width: 28px; height: 28px;"><i class="bi bi-person-fill text-primary" style="font-size: 14px;"></i></div>`;
                }
            }

            return msgWrapper;
        }
        */

        let currentInboxThreadId = null;
        const newMessageModal = new bootstrap.Modal(document.getElementById("newMessageModal"));
        let unsubscribeThread = null;
        let unsubscribeInbox = null;
        let unsubscribeInvitations = null;

        // 1. Écouteur pour les messages non lus (pour le badge dans la sidebar)
        function listenForInboxMessages(userId) {
            if (unsubscribeInbox) unsubscribeInbox();
            if (unsubscribeInvitations) unsubscribeInvitations();

            const threadsQuery = query(
                collection(db, "messages"),
                where("participants", "array-contains", userId)
            );

            // Listener pour les threads actifs
            unsubscribeInbox = onSnapshot(threadsQuery, (snapshot) => {
                let unreadCount = 0;
                const threads = snapshot.docs.map(doc => ({ id: doc.id, type: 'thread', ...doc.data() }));

                threads.forEach(thread => {
                    if (thread.lastMessageRecipientId === userId && !thread.lastMessageRead) {
                        unreadCount++;
                    }
                });

                console.log('📧 Active threads loaded:', threads.length);

                // Appeler la fonction qui gère les invitations
                listenForInvitations(userId, threads, unreadCount);
            });
        }

        // FONCTION: Écoute des invitations
        function listenForInvitations(userId, activeThreads, initialUnreadCount) {
            console.log('🔍 Setting up invitations listener for user:', userId);

            // Invitations reçues (en attente de réponse)
            const receivedQ = query(
                collection(db, "invitations"),
                where("recipientId", "==", userId),
                where("status", "==", "pending")
            );

            // Invitations envoyées (en attente d'acceptation)
            const sentQ = query(
                collection(db, "invitations"),
                where("senderId", "==", userId),
                where("status", "==", "pending")
            );

            // Listener pour les invitations reçues
            unsubscribeInvitations = onSnapshot(receivedQ, async (receivedSnapshot) => {
                console.log('📨 Received invitations snapshot:', receivedSnapshot.size);

                const receivedInvites = receivedSnapshot.docs.map(doc => {
                    const data = doc.data();
                    console.log('📩 Received invite:', doc.id, data);
                    return { id: doc.id, type: 'received_invite', ...data };
                });

                // Récupérer aussi les invitations envoyées
                try {
                    const sentSnapshot = await getDocs(sentQ);
                    console.log('📤 Sent invitations:', sentSnapshot.size);

                    const sentInvites = sentSnapshot.docs.map(doc => {
                        const data = doc.data();
                        console.log('📮 Sent invite:', doc.id, data);
                        return { id: doc.id, type: 'sent_invite', ...data };
                    });

                    // Combiner tous les éléments
                    const allItems = [...receivedInvites, ...sentInvites, ...activeThreads];
                    console.log('📊 Total items to display:', allItems.length, {
                        received: receivedInvites.length,
                        sent: sentInvites.length,
                        threads: activeThreads.length
                    });

                    // Rendre la liste complète
                    renderInboxList(allItems, initialUnreadCount, userId);
                } catch (error) {
                    console.error('❌ Error fetching sent invitations:', error);
                    // Afficher au moins les invitations reçues
                    const allItems = [...receivedInvites, ...activeThreads];
                    renderInboxList(allItems, initialUnreadCount, userId);
                }
            }, (error) => {
                console.error('❌ Error in invitations listener:', error);
            });
        }

        // 2. Render conversation list with invitations
        async function renderInboxList(allItems, initialUnreadCount, currentUserId) {
            const container = document.getElementById("inboxThreadsContainer");
            if (!container) {
                console.error('❌ Container not found: inboxThreadsContainer');
                return;
            }

            console.log('🎨 Rendering inbox list with', allItems.length, 'items');
            container.innerHTML = "";

            // Mettre à jour le badge de la sidebar
            const inboxCountEl = document.getElementById("inboxCount");
            if (inboxCountEl) {
                inboxCountEl.textContent = initialUnreadCount;
                inboxCountEl.classList.toggle("d-none", initialUnreadCount === 0);
            }

            if (allItems.length === 0) {
                container.innerHTML = `<div class="text-center text-muted p-5">
            <i class="bi bi-inbox fs-1 d-block mb-3"></i>
            <p>Votre boîte de réception est vide.</p>
        </div>`;
                return;
            }

            // Séparer les invitations et les threads
            const receivedInvites = allItems.filter(item => item.type === 'received_invite');
            const sentInvites = allItems.filter(item => item.type === 'sent_invite');
            const threads = allItems.filter(item => item.type === 'thread');

            console.log('📋 Separated items:', {
                receivedInvites: receivedInvites.length,
                sentInvites: sentInvites.length,
                threads: threads.length
            });

            // Afficher d'abord les invitations reçues (priorité haute)
            if (receivedInvites.length > 0) {
                const headerReceived = document.createElement('div');
                headerReceived.className = 'text-muted small fw-bold mb-2 mt-3';
                headerReceived.innerHTML = '<i class="bi bi-bell-fill text-warning me-2"></i>INVITATIONS REÇUES';
                container.appendChild(headerReceived);
            }

            receivedInvites.forEach(invite => {
                console.log('✉️ Rendering received invite:', invite.id);
                const inviteCard = document.createElement("div");
                inviteCard.className = `card card-modern hover-lift p-3 border-warning border-2 mb-3`;
                inviteCard.setAttribute('data-invite-id', invite.id);

                // Escape HTML for onclick attributes
                const escapedSubject = escapeHtml(invite.subject).replace(/'/g, "\\'");
                const escapedMessage = escapeHtml(invite.initialMessage).replace(/'/g, "\\'");
                const escapedSenderId = invite.senderId.replace(/'/g, "\\'");
                const escapedInviteId = invite.id.replace(/'/g, "\\'");

                // In the renderInboxList function, update the button onclick:
                inviteCard.innerHTML = `
                    <div class="d-flex align-items-start">
                        <i class="bi bi-person-fill-add fs-2 me-3 text-warning"></i>
                        <div class="flex-grow-1">
                            <h6 class="mb-1 fw-bold text-warning">
                                <i class="bi bi-envelope-fill me-1"></i>
                                Invitation de ${escapeHtml(invite.senderName || 'Utilisateur')}
                            </h6>
                            <p class="mb-1"><strong>Sujet:</strong> ${escapeHtml(invite.subject)}</p>
                            <p class="mb-2 text-muted small">"${escapeHtml(invite.initialMessage)}"</p>
                            <small class="text-muted">Reçu: ${invite.createdAt ? timeAgo(invite.createdAt.toDate()) : 'Récemment'}</small>
                        </div>
                        <div class="text-end ms-2 flex-shrink-0">
                            <button class="btn btn-sm btn-success mb-2 d-block w-100" onclick="acceptInvitation('${invite.id}')">
                                <i class="bi bi-check-circle me-1"></i>Accepter
                            </button>
                            <button class="btn btn-sm btn-danger d-block w-100" onclick="rejectInvitation('${invite.id}')">
                               <i class="bi bi-x-circle me-1"></i>Rejeter
                            </button>
                        </div>
                    </div>
                `;

                container.appendChild(inviteCard);
            });

            // Afficher les invitations envoyées
            if (sentInvites.length > 0) {
                const headerSent = document.createElement('div');
                headerSent.className = 'text-muted small fw-bold mb-2 mt-4';
                headerSent.innerHTML = '<i class="bi bi-send-fill text-info me-2"></i>INVITATIONS ENVOYÉES';
                container.appendChild(headerSent);
            }

            sentInvites.forEach(invite => {
                console.log('📤 Rendering sent invite:', invite.id);
                const inviteCard = document.createElement("div");
                inviteCard.className = `card card-modern p-3 border-info border-2 mb-3`;
                inviteCard.setAttribute('data-invite-id', invite.id);

                // In the renderInboxList function, update the button onclick:
                inviteCard.innerHTML = `
                    <div class="d-flex align-items-center">
                        <i class="bi bi-hourglass-split fs-3 me-3 text-info"></i>
                        <div class="flex-grow-1">
                            <h6 class="mb-1 fw-bold text-info">
                                En attente de ${escapeHtml(invite.recipientName || 'Utilisateur')}
                            </h6>
                            <small class="text-muted">Sujet: ${escapeHtml(invite.subject)}</small>
                        </div>
                        <div class="text-end">
                            <small class="text-muted">Envoyé: ${invite.createdAt ? timeAgo(invite.createdAt.toDate()) : 'Récemment'}</small>
                        </div>
                    </div>
                `;

                container.appendChild(inviteCard);
            });

            // Afficher les conversations actives
            if (threads.length > 0) {
                const headerThreads = document.createElement('div');
                headerThreads.className = 'text-muted small fw-bold mb-2 mt-4';
                headerThreads.innerHTML = '<i class="bi bi-chat-dots-fill text-primary me-2"></i>CONVERSATIONS ACTIVES';
                container.appendChild(headerThreads);
            }

            // Tri des threads par date
            threads.sort((a, b) =>
                (b.lastMessageTime ? b.lastMessageTime.toDate() : 0) -
                (a.lastMessageTime ? a.lastMessageTime.toDate() : 0)
            );

            // Fetch avatars
            const participantIds = [...new Set(threads.flatMap(t => t.participants))];
            const userAvatars = {};

            for (const userId of participantIds) {
                try {
                    const userDoc = await getDoc(doc(db, "users", userId));
                    if (userDoc.exists()) {
                        const userData = userDoc.data();
                        userAvatars[userId] = userData.photoURL || null;
                    }
                } catch (e) {
                    console.error("Error fetching user avatar:", e);
                }
            }

            threads.forEach(thread => {
                const otherParticipantId = thread.participants.find(id => id !== currentUserId);
                const otherParticipantName = thread.participantNames[otherParticipantId] || 'Utilisateur inconnu';
                const otherParticipantAvatar = userAvatars[otherParticipantId];
                const isUnread = (thread.lastMessageRecipientId === currentUserId && !thread.lastMessageRead);

                const threadCard = document.createElement("div");
                threadCard.className = `card card-modern hover-lift p-3 mb-3 ${isUnread ? 'border-primary border-3' : ''}`;
                threadCard.style.cursor = 'pointer';
                threadCard.setAttribute('data-thread-id', thread.id);
                threadCard.onclick = () => viewInboxThread(thread.id, otherParticipantName, thread.subject, otherParticipantAvatar);

                const avatarHtml = otherParticipantAvatar
                    ? `<img src="${otherParticipantAvatar}" alt="${escapeHtml(otherParticipantName)}" 
                class="rounded-circle me-3" 
                style="width: 48px; height: 48px; object-fit: cover; border: 2px solid #e9ecef;">`
                    : `<i class="bi bi-chat-fill fs-3 me-3 text-secondary"></i>`;

                threadCard.innerHTML = `
            <div class="d-flex align-items-center">
                ${avatarHtml}
                <div class="flex-grow-1">
                    <h6 class="mb-0 ${isUnread ? 'fw-bold text-primary' : ''}">${escapeHtml(thread.subject)}</h6>
                    <small class="text-muted">Avec: ${escapeHtml(otherParticipantName)}</small>
                </div>
                <div class="text-end">
                    <small class="text-muted">${thread.lastMessageTime ? timeAgo(thread.lastMessageTime.toDate()) : 'N/A'}</small>
                    ${isUnread ? '<span class="badge bg-danger ms-2">Nouveau</span>' : ''}
                </div>
            </div>
        `;
                container.appendChild(threadCard);
            });
        }

        // Accept invitation function
        window.acceptInvitation = async function (inviteId) {
            const user = auth.currentUser;
            if (!user) {
                showToast("Vous devez être connecté.", "warning");
                return;
            }

            console.log('✅ Accepting invitation:', inviteId);

            const inviteCard = document.querySelector(`[data-invite-id="${inviteId}"]`);
            if (inviteCard) {
                inviteCard.style.opacity = '0.6';
                inviteCard.style.pointerEvents = 'none';
            }

            try {
                const inviteRef = doc(db, "invitations", inviteId);
                const inviteSnap = await getDoc(inviteRef);

                if (!inviteSnap.exists()) {
                    throw new Error("Invitation introuvable.");
                }

                const inviteData = inviteSnap.data();

                if (inviteData.status !== 'pending') {
                    throw new Error("Cette invitation a déjà été traitée.");
                }

                const senderId = inviteData.senderId;
                const subject = inviteData.subject;
                const initialMessage = inviteData.initialMessage;

                let newThreadId = null;
                let senderName = null;
                let senderAvatar = null;

                const senderDoc = await getDoc(doc(db, "users", senderId));
                if (senderDoc.exists()) {
                    const senderData = senderDoc.data();
                    senderName = senderData.name || senderData.displayName || 'Anonyme';
                    senderAvatar = senderData.photoURL || senderData.avatar || null;
                }

                // Transaction pour créer le thread et supprimer l'invitation
                await runTransaction(db, async (transaction) => {
                    const inviteSnapInTransaction = await transaction.get(inviteRef);

                    if (!inviteSnapInTransaction.exists()) {
                        throw new Error("Invitation introuvable.");
                    }

                    const currentInviteData = inviteSnapInTransaction.data();
                    if (currentInviteData.status !== 'pending') {
                        throw new Error("Cette invitation a déjà été traitée.");
                    }

                    const newThreadRef = doc(collection(db, "messages"));
                    newThreadId = newThreadRef.id;

                    const threadData = {
                        subject: subject,
                        participants: [user.uid, senderId],
                        participantNames: {
                            [user.uid]: user.displayName || user.email || "Vous",
                            [senderId]: senderName
                        },
                        lastMessageContent: initialMessage,
                        lastMessageTime: Timestamp.now(),
                        lastMessageSenderId: senderId,
                        lastMessageRecipientId: user.uid,
                        lastMessageRead: false,
                        createdAt: Timestamp.now(),
                        pinnedMessages: []
                    };

                    console.log('💾 Creating thread:', newThreadId);
                    transaction.set(newThreadRef, threadData);

                    // Supprimer l'invitation
                    transaction.delete(inviteRef);
                });

                // APRÈS la transaction, créer le premier message
                const firstMessageRef = doc(collection(db, "messages", newThreadId, "thread"));
                await setDoc(firstMessageRef, {
                    content: initialMessage,
                    senderId: senderId,
                    senderName: senderName,
                    createdAt: Timestamp.now()
                });

                console.log('✅ Thread and message created!');
                showToast("Invitation acceptée ! Démarrage de la conversation...", "success");

                await new Promise(resolve => setTimeout(resolve, 500));

                viewInboxThread(newThreadId, senderName, subject, senderAvatar);

                if (typeof triggerNotificationEvent === "function") {
                    await triggerNotificationEvent(senderId, {
                        message: `<strong>${user.displayName || 'Un utilisateur'}</strong> a accepté votre invitation !`,
                        type: "invite_accepted",
                        link: "/inbox"
                    });
                }

            } catch (error) {
                console.error("❌ Erreur:", error);
                showToast("Erreur: " + error.message, "danger");

                if (inviteCard) {
                    inviteCard.style.opacity = '1';
                    inviteCard.style.pointerEvents = 'auto';
                }
            }
        }

        // Also update the rejectInvitation function to only take inviteId
        window.rejectInvitation = async function (inviteId) {
            if (!confirm("Voulez-vous vraiment rejeter cette invitation ? Cette action est irréversible.")) {
                return;
            }

            const user = auth.currentUser;
            if (!user) {
                showToast("Vous devez être connecté.", "warning");
                return;
            }

            console.log('❌ Rejecting invitation:', inviteId);

            const inviteCard = document.querySelector(`[data-invite-id="${inviteId}"]`);
            if (inviteCard) {
                inviteCard.style.opacity = '0.6';
                inviteCard.style.pointerEvents = 'none';
            }

            try {
                const inviteRef = doc(db, "invitations", inviteId);
                const inviteSnap = await getDoc(inviteRef);

                if (!inviteSnap.exists()) {
                    throw new Error("Invitation introuvable.");
                }

                const inviteData = inviteSnap.data();
                const senderId = inviteData.senderId;

                await deleteDoc(inviteRef);

                console.log('✅ Invitation deleted');
                showToast("Invitation rejetée.", "info");

                if (typeof triggerNotificationEvent === "function") {
                    await triggerNotificationEvent(senderId, {
                        message: `Votre invitation a été déclinée.`,
                        type: "invite_rejected",
                        link: "/inbox"
                    });
                }

                if (inviteCard) {
                    inviteCard.style.transition = 'all 0.3s ease';
                    inviteCard.style.transform = 'translateX(-100%)';
                    inviteCard.style.opacity = '0';

                    setTimeout(() => {
                        inviteCard.remove();
                        const container = document.getElementById("inboxThreadsContainer");
                        if (container && container.children.length === 0) {
                            container.innerHTML = `<div class="text-center text-muted p-5">
                        <i class="bi bi-inbox fs-1 d-block mb-3"></i>
                        <p>Votre boîte de réception est vide.</p>
                    </div>`;
                        }
                    }, 300);
                }

            } catch (error) {
                console.error("❌ Erreur de rejet:", error);
                showToast("Erreur lors du rejet: " + error.message, "danger");

                if (inviteCard) {
                    inviteCard.style.opacity = '1';
                    inviteCard.style.pointerEvents = 'auto';
                }
            }
        }

        // View thread function (same as before with avatars)

        let typingUnsubscribe = null;
        let presenceUnsubscribe = null;

        async function viewInboxThread(threadId, recipientName, subject, recipientAvatarFallback) {
            document.getElementById("inboxList").classList.add("d-none");
            document.getElementById("inboxDetailView").classList.remove("d-none");
            currentInboxThreadId = threadId;

            // Nettoyer les listeners précédents
            if (unsubscribeThread) {
                unsubscribeThread();
                unsubscribeThread = null;
            }
            if (typingUnsubscribe) {
                typingUnsubscribe();
                typingUnsubscribe = null;
            }
            if (presenceUnsubscribe) {
                presenceUnsubscribe();
                presenceUnsubscribe = null;
            }

            const user = auth.currentUser;
            const currentUserId = user.uid;

            // Récupérer les informations du thread
            const threadRef = doc(db, "messages", threadId);
            const threadSnap = await getDoc(threadRef);

            if (!threadSnap.exists()) {
                showToast("Conversation introuvable", "danger");
                return;
            }

            const threadData = threadSnap.data();
            const recipientId = threadData.participants.find(id => id !== currentUserId);

            // Mettre à jour le header
            document.getElementById("inboxThreadTitle").textContent = subject || 'Conversation';

            // Avatar et nom du destinataire
            const recipientNameEl = document.getElementById("inboxRecipientName");
            const recipientAvatarEl = document.getElementById("recipientAvatar");
            const recipientPresenceEl = document.getElementById("recipientPresence");
            const recipientStatusEl = document.getElementById("recipientStatus");

            recipientAvatarEl.src = recipientAvatarFallback || `https://ui-avatars.com/api/?name=${encodeURIComponent(recipientName)}`;
            recipientNameEl.innerHTML = `avec <strong>${escapeHtml(recipientName)}</strong>`;


            // ============================================
            // 🟢 PRÉSENCE EN TEMPS RÉEL
            // ============================================
            presenceUnsubscribe = listenToUserPresence(recipientId, (presenceData) => {
                const { status, lastSeen } = presenceData;

                // Mettre à jour l'indicateur de présence
                recipientPresenceEl.className = `presence-indicator presence-${status}`;

                // Mettre à jour le texte de statut
                if (status === 'online') {
                    recipientStatusEl.textContent = 'En ligne';
                    recipientStatusEl.style.color = '#10b981';
                } else if (status === 'away') {
                    recipientStatusEl.textContent = 'Absent';
                    recipientStatusEl.style.color = '#f59e0b';
                } else if (lastSeen) {
                    const timeAgoText = timeAgo(lastSeen);
                    recipientStatusEl.textContent = `Vu ${timeAgoText}`;
                    recipientStatusEl.style.color = '#6b7280';
                } else {
                    recipientStatusEl.textContent = 'Hors ligne';
                    recipientStatusEl.style.color = '#6b7280';
                }
            });

            // ============================================
            // ⌨️ INDICATEUR "EN TRAIN D'ÉCRIRE..."
            // ============================================
            const typingIndicatorEl = document.getElementById("typingIndicator");
            const typingUserNameEl = document.getElementById("typingUserName");

            typingUnsubscribe = listenToTyping(threadId, currentUserId, (typingUsers) => {
                if (typingUsers.length > 0) {
                    typingUserNameEl.textContent = recipientName;
                    typingIndicatorEl.classList.remove('d-none');
                } else {
                    typingIndicatorEl.classList.add('d-none');
                }
            });

            // Détecter quand l'utilisateur tape
            const messageInput = document.getElementById("messageInput");
            let typingTimeout;

            messageInput.addEventListener('input', () => {
                notifyTyping(threadId, currentUserId, true);

                clearTimeout(typingTimeout);
                typingTimeout = setTimeout(() => {
                    notifyTyping(threadId, currentUserId, false);
                }, 3000);
            });

            // ============================================
            // 📌 CHARGER LES MESSAGES ÉPINGLÉS
            // ============================================
            const pinnedMessages = threadData.pinnedMessages || [];
            await renderPinnedMessages(threadId, pinnedMessages);

            // ============================================
            // 💬 AFFICHER LES MESSAGES
            // ============================================
            const logContainer = document.getElementById("messageLogContainer");
            logContainer.innerHTML = '<div class="text-center text-muted p-3"><div class="spinner-border spinner-border-sm text-primary me-2"></div>Chargement...</div>';

            // Marquer comme lu
            try {
                if (threadData.lastMessageRecipientId === currentUserId && !threadData.lastMessageRead) {
                    await updateDoc(threadRef, { lastMessageRead: true });
                }
            } catch (e) {
                console.error("Error marking read:", e);
            }

            // Récupérer les avatars
            const avatarsMap = {};
            avatarsMap[currentUserId] = user.photoURL || null;

            try {
                const participants = threadData.participants;
                for (const pid of participants) {
                    if (pid !== currentUserId) {
                        const userDoc = await getDoc(doc(db, "users", pid));
                        if (userDoc.exists()) {
                            const userData = userDoc.data();
                            avatarsMap[pid] = userData.photoURL || userData.avatar || null;
                        }
                    }
                }
            } catch (e) {
                console.error("Erreur fetch avatars:", e);
            }

            // Écouter les messages en temps réel
            const q = query(collection(db, "messages", threadId, "thread"), orderBy("createdAt", "asc"));
            unsubscribeThread = onSnapshot(q, (snapshot) => {
                logContainer.innerHTML = '';

                if (snapshot.empty) {
                    logContainer.innerHTML = '<div class="text-center text-muted p-4"><i class="bi bi-chat-dots fs-1 d-block mb-2"></i>Commencez la conversation !</div>';
                    return;
                }

                let lastSenderId = null;

                /*snapshot.forEach((docSnap) => {
                    const msg = { id: docSnap.id, ...docSnap.data() };
                    const isMe = msg.senderId === currentUserId;
                    const avatarUrl = avatarsMap[msg.senderId];
                    const isSameSender = lastSenderId === msg.senderId;
                    lastSenderId = msg.senderId;

                    // Utiliser la fonction de création de message avec toutes les fonctionnalités
                    const messageEl = createMessageElement(msg, isMe, currentUserId, threadId, avatarUrl, isSameSender);
                    logContainer.appendChild(messageEl);
                });*/

                snapshot.docChanges().forEach(change => {
                    const msg = { id: change.doc.id, ...change.doc.data() };
                    const isMe = msg.senderId === currentUserId;
                    const avatarUrl = avatarsMap[msg.senderId];
                    const isSameSender = lastSenderId === msg.senderId;
                    lastSenderId = msg.senderId;

                    if (change.type === "added") {
                        const messageEl = createMessageElement(msg, isMe, currentUserId, threadId, avatarUrl, isSameSender);
                        logContainer.appendChild(messageEl);
                    } else if (change.type === "modified") {
                        const existing = document.querySelector(`[data-message-id="${msg.id}"]`);
                        if (existing) existing.replaceWith(createMessageElement(msg, isMe, currentUserId, threadId, avatarUrl, false));
                    }
                });

                if (!snapshot.metadata.hasPendingWrites) {
                    const lastMsg = snapshot.docs[snapshot.docs.length - 1]?.data();
                    if (lastMsg && lastMsg.senderId !== currentUserId) {
                        playChatSound('receive');
                    }
                }



                // Auto-scroll vers le bas (sauf si l'utilisateur a scrollé vers le haut)
                const isScrolledToBottom = logContainer.scrollHeight - logContainer.clientHeight <= logContainer.scrollTop + 100;
                if (isScrolledToBottom) {
                    logContainer.scrollTop = logContainer.scrollHeight;
                }
            });

            // ============================================
            // 🔍 CONFIGURATION DE LA RECHERCHE
            // ============================================
            const toggleSearchBtn = document.getElementById('toggleSearchBtn');
            const searchContainer = document.getElementById('searchContainer');
            const searchInput = document.getElementById('messageSearchInput');

            toggleSearchBtn.onclick = () => {
                searchContainer.classList.toggle('d-none');
                if (!searchContainer.classList.contains('d-none')) {
                    searchInput.focus();
                } else {
                    closeSearch();
                }
            };

            let searchDebounce;
            searchInput.addEventListener('input', (e) => {
                clearTimeout(searchDebounce);
                searchDebounce = setTimeout(() => {
                    searchMessages(threadId, e.target.value);
                }, 300);
            });
        }

        // Fonction pour fermer la recherche
        function closeSearch() {
            const searchContainer = document.getElementById('searchContainer');
            const searchInput = document.getElementById('messageSearchInput');

            searchContainer.classList.add('d-none');
            searchInput.value = '';
            clearSearchHighlights();
            searchResults = [];
            document.getElementById('searchResultsCount').textContent = '';
        }

        function formatDateShort(timestamp) {
            if (!timestamp) return '';
            const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
            return date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
        }

        // Cleanup duplicate conversations
        async function cleanupDuplicateConversations() {
            const user = auth.currentUser;
            if (!user) {
                console.error("User must be logged in");
                return;
            }

            try {
                console.log("🔍 Searching for duplicates...");

                const threadsQuery = query(
                    collection(db, "messages"),
                    where("participants", "array-contains", user.uid)
                );

                const snapshot = await getDocs(threadsQuery);
                const threads = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                const threadGroups = {};

                threads.forEach(thread => {
                    const participantsKey = thread.participants.sort().join('_');
                    const groupKey = `${participantsKey}_${thread.subject}`;

                    if (!threadGroups[groupKey]) {
                        threadGroups[groupKey] = [];
                    }
                    threadGroups[groupKey].push(thread);
                });

                let duplicatesFound = 0;
                let threadsDeleted = 0;

                for (const [groupKey, groupThreads] of Object.entries(threadGroups)) {
                    if (groupThreads.length > 1) {
                        duplicatesFound++;
                        console.log(`📌 Found ${groupThreads.length} duplicates for: ${groupThreads[0].subject}`);

                        groupThreads.sort((a, b) => {
                            const timeA = a.lastMessageTime?.toDate() || new Date(0);
                            const timeB = b.lastMessageTime?.toDate() || new Date(0);
                            return timeA - timeB;
                        });

                        const mainThread = groupThreads[0];
                        const duplicates = groupThreads.slice(1);

                        console.log(`  ✅ Keeping: ${mainThread.id}`);

                        for (const dupThread of duplicates) {
                            console.log(`  🔄 Merging: ${dupThread.id}`);

                            const messagesQuery = query(
                                collection(db, "messages", dupThread.id, "thread"),
                                orderBy("createdAt", "asc")
                            );
                            const messagesSnap = await getDocs(messagesQuery);

                            for (const msgDoc of messagesSnap.docs) {
                                const msgData = msgDoc.data();
                                await addDoc(collection(db, "messages", mainThread.id, "thread"), msgData);
                            }

                            await deleteDoc(doc(db, "messages", dupThread.id));
                            threadsDeleted++;
                            console.log(`  ❌ Deleted: ${dupThread.id}`);
                        }

                        const allMessages = await getDocs(
                            query(
                                collection(db, "messages", mainThread.id, "thread"),
                                orderBy("createdAt", "desc"),
                                limit(1)
                            )
                        );

                        if (!allMessages.empty) {
                            const lastMsg = allMessages.docs[0].data();
                            await updateDoc(doc(db, "messages", mainThread.id), {
                                lastMessageContent: lastMsg.content,
                                lastMessageTime: lastMsg.createdAt,
                                lastMessageSenderId: lastMsg.senderId,
                                lastMessageRecipientId: mainThread.participants.find(p => p !== lastMsg.senderId),
                                lastMessageRead: false
                            });
                        }
                    }
                }

                if (duplicatesFound === 0) {
                    console.log("✨ No duplicates found!");
                    showToast("Aucun doublon trouvé !", "success");
                } else {
                    console.log(`✅ Cleanup complete! Deleted ${threadsDeleted} duplicates.`);
                    showToast(`Nettoyage terminé ! ${threadsDeleted} doublons supprimés.`, "success");
                    listenForInboxMessages(user.uid);
                }

            } catch (error) {
                console.error("❌ Cleanup error:", error);
                showToast("Erreur: " + error.message, "danger");
            }
        }

        // Reply message form handler
        /*document.getElementById("replyMessageForm")?.addEventListener("submit", async (e) => {
            e.preventDefault();

            const content = document.getElementById("messageInput").value.trim();
            if (!content || !currentInboxThreadId) return;

            const user = auth.currentUser;
            const threadId = currentInboxThreadId;

            try {
                const threadRef = doc(db, "messages", threadId);
                const threadSnap = await getDoc(threadRef);

                if (!threadSnap.exists()) {
                    throw new Error("Thread introuvable.");
                }

                const threadData = threadSnap.data();
                const recipientId = threadData.participants.find(id => id !== user.uid);

                await addDoc(collection(threadRef, "thread"), {
                    content: content,
                    senderId: user.uid,
                    senderName: user.displayName || 'Anonyme',
                    createdAt: Timestamp.now()
                });

                await updateDoc(threadRef, {
                    lastMessageContent: content,
                    lastMessageTime: Timestamp.now(),
                    lastMessageSenderId: user.uid,
                    lastMessageRecipientId: recipientId,
                    lastMessageRead: false
                });

                if (typeof triggerNotificationEvent === "function") {
                    await triggerNotificationEvent(recipientId, {
                        message: `Nouveau message de <strong>${user.displayName || 'Anonyme'}</strong>`,
                        type: "new_message",
                        link: `/inbox/${threadId}`
                    });
                }

                document.getElementById("messageInput").value = '';
                showToast("Message envoyé!", "success");

            } catch (error) {
                console.error("Error sending message:", error);
                showToast("Erreur: " + error.message, "danger");
            }
        });
         // ============================================
        // GESTION DU FORMULAIRE D'ENVOI DE MESSAGE
        // ============================================
        document.getElementById("replyMessageForm")?.addEventListener("submit", async (e) => {
            e.preventDefault();

            const content = document.getElementById("messageInput").value.trim();
            if (!content || !currentInboxThreadId) return;

            const user = auth.currentUser;
            const threadId = currentInboxThreadId;

            // Arrêter l'indicateur de frappe
            notifyTyping(threadId, user.uid, false);

            try {
                const threadRef = doc(db, "messages", threadId);
                const threadSnap = await getDoc(threadRef);

                if (!threadSnap.exists()) {
                    throw new Error("Thread introuvable.");
                }

                const threadData = threadSnap.data();
                const recipientId = threadData.participants.find(id => id !== user.uid);

                // Ajouter le message
                await addDoc(collection(threadRef, "thread"), {
                    content: content,
                    senderId: user.uid,
                    senderName: user.displayName || 'Anonyme',
                    createdAt: Timestamp.now(),
                    reactions: {} // Initialiser avec un objet vide pour les réactions
                });

                // Mettre à jour les métadonnées du thread
                await updateDoc(threadRef, {
                    lastMessageContent: content,
                    lastMessageTime: Timestamp.now(),
                    lastMessageSenderId: user.uid,
                    lastMessageRecipientId: recipientId,
                    lastMessageRead: false
                });

                // Notification au destinataire
                if (typeof triggerNotificationEvent === "function") {
                    await triggerNotificationEvent(recipientId, {
                        message: `Nouveau message de <strong>${user.displayName || 'Anonyme'}</strong>`,
                        type: "new_message",
                        link: `/inbox/${threadId}`
                    });
                }

                // Réinitialiser le champ
                document.getElementById("messageInput").value = '';

                // Animation subtile d'envoi
                showToast("Message envoyé !", "success");
                playChatSound('send');


            } catch (error) {
                console.error("Error sending message:", error);
                showToast("Erreur: " + error.message, "danger");
            }
        });
        */



        // User search functionality
        const recipientSearch = document.getElementById("recipientSearch");
        const recipientSearchResults = document.getElementById("recipientSearchResults");
        const recipientIdInput = document.getElementById("recipientId");
        const sendMessageButton = document.getElementById("sendMessageButton");

        let searchTimeout = null;

        recipientSearch?.addEventListener('input', (e) => {
            clearTimeout(searchTimeout);
            const searchQuery = e.target.value.trim();
            console.log('Input query:', searchQuery);
            if (searchQuery.length < 3) {
                recipientSearchResults.style.display = 'none';
                return;
            }
            searchTimeout = setTimeout(() => {
                searchUsers(searchQuery);
            }, 300);
        });

        async function searchUsers(searchQuery) {
            console.log('Searching for:', searchQuery);
            const user = auth.currentUser;
            if (!user) {
                console.log('No user logged in');
                showToast('Vous devez être connecté pour rechercher.', 'warning');
                return;
            }

            try {
                const q1 = query(collection(db, "users"), where("name", ">=", searchQuery), where("name", "<=", searchQuery + '\uf8ff'), limit(5));
                const q2 = query(collection(db, "users"), where("email", "==", searchQuery), limit(5));
                const [snap1, snap2] = await Promise.all([getDocs(q1), getDocs(q2)]);
                console.log('Name results:', snap1.size, 'Email results:', snap2.size);

                let results = [];
                const foundIds = new Set();

                snap1.forEach(doc => {
                    if (doc.id !== user.uid) {
                        results.push({ id: doc.id, ...doc.data() });
                        foundIds.add(doc.id);
                    }
                });

                snap2.forEach(doc => {
                    if (doc.id !== user.uid && !foundIds.has(doc.id)) {
                        results.push({ id: doc.id, ...doc.data() });
                    }
                });

                console.log('Combined results:', results);
                renderSearchResults(results);
            } catch (error) {
                console.error('Search error:', error);
                showToast('Erreur lors de la recherche: ' + error.message, 'danger');
            }
        }

        function renderSearchResults(results) {
            console.log('Rendering results:', results);
            if (!recipientSearchResults) {
                console.error('recipientSearchResults element not found');
                return;
            }

            recipientSearchResults.innerHTML = '';
            if (results.length === 0) {
                recipientSearchResults.innerHTML = '<button type="button" class="list-group-item list-group-item-action disabled">Aucun utilisateur trouvé.</button>';
                recipientSearchResults.style.display = 'block';
                return;
            }

            results.forEach(user => {
                console.log('Adding user:', user.name, user.email);
                const item = document.createElement('button');
                item.type = 'button';
                item.className = 'list-group-item list-group-item-action';
                item.innerHTML = `<strong>${escapeHtml(user.name)}</strong> <small class="text-muted">(${escapeHtml(user.email)})</small>`;
                item.onclick = () => {
                    console.log('Selected user:', user.id, user.name);
                    selectRecipient(user.id, user.name);
                };
                recipientSearchResults.appendChild(item);
            });
            recipientSearchResults.style.display = 'block';
        }

        function selectRecipient(id, name) {
            recipientIdInput.value = id;
            recipientSearch.value = name;
            recipientSearchResults.style.display = 'none';
            sendMessageButton.disabled = false;
            recipientSearch.setAttribute('disabled', 'true');
        }

        // Reset search when modal closes
        document.getElementById("newMessageModal")?.addEventListener('hidden.bs.modal', () => {
            recipientIdInput.value = '';
            recipientSearch.value = '';
            recipientSearch.removeAttribute('disabled');
            recipientSearchResults.style.display = 'none';
            sendMessageButton.disabled = true;
        });

        // New message form submission
        document.getElementById("newMessageForm")?.addEventListener("submit", async (e) => {
            e.preventDefault();

            const user = auth.currentUser;
            const recipientId = recipientIdInput.value;
            const subject = document.getElementById("messageSubject").value.trim();
            const content = document.getElementById("initialMessageContent").value.trim();

            if (!user || !recipientId || !subject || !content) {
                showToast("Veuillez sélectionner un destinataire et remplir tous les champs.", "warning");
                return;
            }

            console.log('📤 Creating new invitation:', { recipientId, subject });

            try {
                // 1. Check for existing active thread
                const activeThreadQ = query(
                    collection(db, "messages"),
                    where("participants", "array-contains", user.uid)
                );
                const activeThreadsSnap = await getDocs(activeThreadQ);
                let alreadyChatting = false;

                activeThreadsSnap.forEach(doc => {
                    const data = doc.data();
                    if (data.participants.includes(recipientId)) {
                        alreadyChatting = true;
                    }
                });

                if (alreadyChatting) {
                    showToast("Vous avez déjà une conversation active avec cet utilisateur.", "info");
                    newMessageModal.hide();
                    return;
                }

                // 2. Check for pending invitations (both directions)
                const pendingInviteQ1 = query(
                    collection(db, "invitations"),
                    where("senderId", "==", user.uid),
                    where("recipientId", "==", recipientId),
                    where("status", "==", "pending")
                );

                const pendingInviteQ2 = query(
                    collection(db, "invitations"),
                    where("senderId", "==", recipientId),
                    where("recipientId", "==", user.uid),
                    where("status", "==", "pending")
                );

                const [sentSnap, receivedSnap] = await Promise.all([
                    getDocs(pendingInviteQ1),
                    getDocs(pendingInviteQ2)
                ]);

                if (!sentSnap.empty) {
                    showToast("Invitation déjà envoyée. En attente de réponse.", "info");
                    newMessageModal.hide();
                    return;
                }

                if (!receivedSnap.empty) {
                    showToast("Cet utilisateur vous a déjà envoyé une invitation. Veuillez vérifier votre boîte de réception.", "info");
                    newMessageModal.hide();
                    return;
                }

                // 3. Create invitation
                const recipientDoc = await getDoc(doc(db, "users", recipientId));
                if (!recipientDoc.exists()) {
                    throw new Error("Utilisateur destinataire introuvable.");
                }

                const recipientData = recipientDoc.data();
                const recipientName = recipientData.name || recipientData.email;

                const invitationData = {
                    senderId: user.uid,
                    senderName: user.displayName || 'Anonyme',
                    recipientId: recipientId,
                    recipientName: recipientName,
                    subject: subject,
                    initialMessage: content,
                    status: 'pending',
                    createdAt: Timestamp.now()
                };

                console.log('💾 Saving invitation:', invitationData);

                const inviteRef = await addDoc(collection(db, "invitations"), invitationData);
                console.log('✅ Invitation created with ID:', inviteRef.id);

                // 4. Notify recipient
                if (typeof triggerNotificationEvent === "function") {
                    await triggerNotificationEvent(recipientId, {
                        message: `Nouvelle invitation de <strong>${user.displayName || 'Anonyme'}</strong>: ${escapeHtml(subject)}`,
                        type: "new_invitation",
                        link: "/inbox"
                    });
                }

                showToast("Invitation à discuter envoyée !", "success");
                newMessageModal.hide();
                document.getElementById("newMessageForm").reset();

            } catch (error) {
                console.error("❌ Erreur lors de l'envoi de l'invitation:", error);
                showToast("Erreur: " + error.message, "danger");
            }
        });

        // Back to inbox list
        document.getElementById("backToInboxList")?.addEventListener("click", () => {
            document.getElementById("inboxDetailView").classList.add("d-none");
            document.getElementById("inboxList").classList.remove("d-none");
            currentInboxThreadId = null;

            if (unsubscribeThread) {
                unsubscribeThread();
                unsubscribeThread = null;
            }
        });


        // Helper functions (add if missing)
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;

            const map = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#039;'
            };
            return text.replace(/[&<>"']/g, (match) => map[match]);
        }

        function formatDate(timestamp) {
            if (!timestamp) return 'N/A';
            const date = timestamp.toDate ? timestamp.toDate() : new Date(timestamp);
            return date.toLocaleString('fr-FR', {
                day: '2-digit',
                month: '2-digit',
                year: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
        }

        function timeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);
            const intervals = {
                an: 31536000,
                mois: 2592000,
                jour: 86400,
                heure: 3600,
                minute: 60
            };

            for (let [name, secondsInInterval] of Object.entries(intervals)) {
                const interval = Math.floor(seconds / secondsInInterval);
                if (interval >= 1) {
                    return `Il y a ${interval} ${name}${interval > 1 && name !== 'mois' ? 's' : ''}`;
                }
            }
            return 'À l\'instant';
        }

        // ============================================
        // 🟢 1. SYSTÈME DE PRÉSENCE EN TEMPS RÉEL
        // ============================================

        let typingTimeouts = {};
        let currentUserPresenceRef = null;

        // ============================================
        // 🟢 PRÉSENCE UTILISATEUR (ONLINE / AWAY)
        // ============================================

        let presenceTimeout;
        let userActive = true;

        // Initialiser la présence utilisateur
        function initializeUserPresence(userId) {
            if (!userId) return;

            const presenceRef = doc(db, "presence", userId);
            currentUserPresenceRef = presenceRef;

            // Mettre à jour le statut en ligne
            const updatePresence = async (status) => {
                try {
                    await setDoc(presenceRef, {
                        status: status, // 'online', 'away', 'offline'
                        lastSeen: Timestamp.now(),
                        userId: userId
                    }, { merge: true });
                } catch (error) {
                    console.error("Error updating presence:", error);
                }
            };

            // Marquer comme en ligne
            updatePresence('online');

            // Détecter l'inactivité (5 minutes = absent)
            let inactivityTimer;
            const resetInactivityTimer = () => {
                clearTimeout(inactivityTimer);
                updatePresence('online');
                inactivityTimer = setTimeout(() => {
                    updatePresence('away');
                }, 5 * 60 * 1000); // 5 minutes
            };

            // Événements pour détecter l'activité
            ['mousedown', 'keypress', 'scroll', 'touchstart'].forEach(event => {
                document.addEventListener(event, resetInactivityTimer);
            });

            // Marquer comme hors ligne lors de la fermeture
            window.addEventListener('beforeunload', () => {
                updatePresence('offline');
            });

            resetInactivityTimer();
        }


        // Écouter le statut de présence d'un utilisateur
        function listenToUserPresence(userId, callback) {
            const presenceRef = doc(db, "presence", userId);
            return onSnapshot(presenceRef, (snapshot) => {
                if (snapshot.exists()) {
                    const data = snapshot.data();
                    callback({
                        status: data.status,
                        lastSeen: data.lastSeen ? data.lastSeen.toDate() : null
                    });
                } else {
                    callback({ status: 'offline', lastSeen: null });
                }
            });
        }

        // Indicateur "En train d'écrire..."
        function notifyTyping(threadId, userId, isTyping) {
            const typingRef = doc(db, "typing", threadId);

            if (isTyping) {
                setDoc(typingRef, {
                    [userId]: Timestamp.now()
                }, { merge: true });

                // Auto-clear après 3 secondes
                if (typingTimeouts[threadId]) clearTimeout(typingTimeouts[threadId]);
                typingTimeouts[threadId] = setTimeout(() => {
                    updateDoc(typingRef, {
                        [userId]: deleteField()
                    }).catch(() => { });
                }, 3000);
            } else {
                updateDoc(typingRef, {
                    [userId]: deleteField()
                }).catch(() => { });
            }
        }

        // Écouter qui est en train d'écrire
        function listenToTyping(threadId, currentUserId, callback) {
            const typingRef = doc(db, "typing", threadId);
            return onSnapshot(typingRef, (snapshot) => {
                if (snapshot.exists()) {
                    const data = snapshot.data();
                    const typingUsers = Object.keys(data).filter(uid => uid !== currentUserId);
                    callback(typingUsers);
                } else {
                    callback([]);
                }
            });
        }

        // ============================================
        // 🔧 DIAGNOSTIC ET CORRECTIONS
        // ============================================

        console.log("🔍 Vérification des fonctions...");
        console.log("showReactionMenu existe ?", typeof window.showReactionMenu);
        console.log("toggleReaction existe ?", typeof window.toggleReaction);
        console.log("togglePinMessage existe ?", typeof window.togglePinMessage);
        console.log("renderReactions existe ?", typeof window.renderReactions);
        console.log("createMessageElement existe ?", typeof window.createMessageElement);

        // ============================================
        // 💬 RÉACTIONS - VERSION GLOBALE ET ROBUSTE
        // ============================================

        const REACTION_EMOJIS = ['👍', '❤️', '😂', '😮', '😢', '🙏'];

        // ✅ Afficher le menu de réactions
        window.showReactionMenu = function (event, threadId, messageId, currentUserId) {
            console.log("🎯 showReactionMenu appelé:", { threadId, messageId, currentUserId });
            event.stopPropagation();

            // Supprimer menu existant
            const existingMenu = document.getElementById('reactionMenu');
            if (existingMenu) existingMenu.remove();

            // Créer le menu
            const menu = document.createElement('div');
            menu.id = 'reactionMenu';
            menu.className = 'reaction-menu glass-effect';
            menu.setAttribute('aria-label', 'Menu de réactions');

            // Ajouter les emojis
            REACTION_EMOJIS.forEach(emoji => {
                const btn = document.createElement('button');
                btn.textContent = emoji;
                btn.className = 'reaction-menu-btn';
                btn.setAttribute('aria-label', `Ajouter la réaction ${emoji}`);
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    console.log("🎯 Emoji cliqué:", emoji);
                    window.toggleReaction(threadId, messageId, currentUserId, emoji);
                    menu.remove();
                });
                btn.addEventListener('mouseenter', () => (btn.style.transform = 'scale(1.25)'));
                btn.addEventListener('mouseleave', () => (btn.style.transform = 'scale(1)'));
                menu.appendChild(btn);
            });

            document.body.appendChild(menu);

            // Positionnement
            const rect = event.currentTarget.getBoundingClientRect();
            menu.style.left = `${rect.left}px`;
            menu.style.top = `${rect.top - menu.offsetHeight - 10}px`;

            // Fermer en cliquant ailleurs
            const closeHandler = (e) => {
                if (!menu.contains(e.target)) {
                    menu.remove();
                    document.removeEventListener('click', closeHandler);
                }
            };
            document.addEventListener('click', closeHandler, { capture: true });
        };



        // ✅ Toggle Reaction - Ultra Robust
        /* window.toggleReaction = async function (threadId, messageId, userId, emoji) {
             console.log("🎯 toggleReaction appelé:", { threadId, messageId, userId, emoji });
 
             try {
                 const messageRef = doc(db, "messages", threadId, "thread", messageId);
 
                 await runTransaction(db, async (transaction) => {
                     const messageSnap = await transaction.get(messageRef);
 
                     if (!messageSnap.exists()) {
                         throw new Error("Message introuvable");
                     }
 
                     const data = messageSnap.data();
                     console.log("🔍 Données du message:", { id: messageId, reactions: data.reactions });
 
                     // ✅ Ultra robuste : Vérifier et initialiser à chaque étape
                     let reactions = data.reactions;
                     if (reactions === undefined || reactions === null || typeof reactions !== 'object') {
                         reactions = {};
                         console.warn("⚠️ reactions était undefined/null/non-object, initialisé à {}");
                     }
 
                     // ✅ Vérifier et initialiser reactions[emoji]
                     if (!Array.isArray(reactions[emoji])) {
                         reactions[emoji] = [];
                         console.log(`🔧 Initialisé reactions[${emoji}] comme tableau vide`);
                     }
 
                     // Toggle logic
                     if (reactions[emoji].includes(userId)) {
                         // Remove reaction
                         reactions[emoji] = reactions[emoji].filter(uid => uid !== userId);
                         if (reactions[emoji].length === 0) {
                             delete reactions[emoji];
                             console.log(`🗑️ Supprimé reactions[${emoji}] car vide`);
                         }
                         console.log("✅ Réaction retirée:", emoji);
                     } else {
                         // Clear other reactions from this user
                         for (const key in reactions) {
                             reactions[key] = reactions[key].filter(uid => uid !== userId);
                             if (reactions[key].length === 0) {
                                 delete reactions[key];
                                 console.log(`🗑️ Supprimé reactions[${key}] car vide`);
                             }
                         }
                         // Add new reaction
                         reactions[emoji].push(userId);
                         console.log("✅ Réaction ajoutée:", emoji);
                     }
 
                     // Mise à jour avec merge
                     console.log("🔄 Mise à jour Firestore avec reactions:", reactions);
                     transaction.set(messageRef, { reactions }, { merge: true });
                 });
 
                 // Son
                 const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBTGH0fPTgjMGHm7A7+OZURE');
                 audio.volume = 0.3;
                 audio.play().catch(() => { });
 
                 showToast("Réaction mise à jour !", "success");
 
             } catch (error) {
                 console.error("❌ Erreur toggleReaction:", error);
                 showToast("Erreur: " + error.message, "danger");
             }
         };
         */

        // ✅ Toggle Reaction - Ultra Robust FIXED
        window.toggleReaction = async function (threadId, messageId, userId, emoji) {
            console.log("🎯 toggleReaction appelé:", { threadId, messageId, userId, emoji });

            try {
                const messageRef = doc(db, "messages", threadId, "thread", messageId);

                await runTransaction(db, async (transaction) => {
                    const messageSnap = await transaction.get(messageRef);
                    if (!messageSnap.exists()) throw new Error("Message introuvable");

                    const data = messageSnap.data();
                    console.log("🔍 Données du message:", { id: messageId, reactions: data.reactions });

                    let reactions = data.reactions;
                    if (reactions === undefined || reactions === null || typeof reactions !== 'object') {
                        reactions = {};
                        console.warn("⚠️ reactions était undefined/null/non-object, initialisé à {}");
                    }

                    if (!Array.isArray(reactions[emoji])) {
                        reactions[emoji] = [];
                        console.log(`🔧 Initialisé reactions[${emoji}] comme tableau vide`);
                    }

                    if (reactions[emoji].includes(userId)) {
                        // Remove reaction
                        reactions[emoji] = reactions[emoji].filter(uid => uid !== userId);
                        if (reactions[emoji].length === 0) {
                            delete reactions[emoji];
                            console.log(`🗑️ Supprimé reactions[${emoji}] car vide`);
                        }
                        console.log("✅ Réaction retirée:", emoji);
                    } else {
                        // Clear other reactions from this user
                        for (const key in reactions) {
                            reactions[key] = reactions[key].filter(uid => uid !== userId);
                            if (reactions[key].length === 0) {
                                delete reactions[key];
                                console.log(`🗑️ Supprimé reactions[${key}] car vide`);
                            }
                        }

                        // ✅ Vérification supplémentaire juste avant le push
                        if (!Array.isArray(reactions[emoji])) {
                            reactions[emoji] = [];
                            console.log(`🔧 Réinitialisé reactions[${emoji}] juste avant push`);
                        }

                        reactions[emoji].push(userId);
                        console.log("✅ Réaction ajoutée:", emoji);
                    }

                    transaction.set(messageRef, { reactions }, { merge: true });
                    console.log("🔄 Mise à jour Firestore avec reactions:", reactions);
                });

                // ✅ Effet sonore
                const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBTGH0fPTgjMGHm7A7+OZURE');
                audio.play().catch(() => { });

                showToast("Réaction mise à jour !", "success");
                // Réinitialiser l'interface utilisateur si nécessaire
            } catch (error) {
                console.error("❌ Erreur toggleReaction:", error);
                showToast("Erreur: " + error.message, "danger");
            }
        };

        // ✅ Render Reactions
        window.renderReactions = function (reactions, currentUserId, messageId, threadId) {
            // ✅ Handle undefined/null reactions
            reactions = reactions || {};
            console.log("🔍 renderReactions appelé:", { messageId, reactions });

            if (Object.keys(reactions).length === 0) return '';

            let html = '<div class="message-reactions d-flex flex-wrap gap-2 mt-2">';

            for (const [emoji, users] of Object.entries(reactions)) {
                const count = Array.isArray(users) ? users.length : 0;
                const hasReacted = Array.isArray(users) && users.includes(currentUserId);
                const classList = `reaction-badge${hasReacted ? ' active' : ''}`;

                html += `
            <button class="${classList}" 
                    onclick="window.toggleReaction('${threadId}', '${messageId}', '${currentUserId}', '${emoji}')"
                    title="${count} personne${count > 1 ? 's' : ''}"
                    aria-label="${hasReacted ? 'Retirer la réaction' : 'Ajouter la réaction'} ${emoji}">
                <span class="reaction-emoji">${emoji}</span>
                <span class="reaction-count">${count}</span>
            </button>
        `;
            }

            html += '</div>';
            return html;
        };

        // ============================================
        // 📌 ÉPINGLAGE
        // ============================================

        window.togglePinMessage = async function (threadId, messageId) {
            console.log("🎯 togglePinMessage appelé:", { threadId, messageId });

            try {
                const threadRef = doc(db, "messages", threadId);
                const threadSnap = await getDoc(threadRef);

                if (!threadSnap.exists()) {
                    throw new Error("Conversation introuvable");
                }

                const data = threadSnap.data();
                let pinnedMessages = data.pinnedMessages || [];

                if (pinnedMessages.includes(messageId)) {
                    pinnedMessages = pinnedMessages.filter(id => id !== messageId);
                    await updateDoc(threadRef, { pinnedMessages });
                    console.log("✅ Message désépinglé");
                    showToast("Message désépinglé", "info");
                } else {
                    if (pinnedMessages.length >= 3) {
                        showToast("Maximum 3 messages épinglés", "warning");
                        return;
                    }
                    pinnedMessages.push(messageId);
                    await updateDoc(threadRef, { pinnedMessages });
                    console.log("✅ Message épinglé");
                    showToast("Message épinglé !", "success");
                }

                await window.renderPinnedMessages(threadId, pinnedMessages);

            } catch (error) {
                console.error("❌ Erreur togglePinMessage:", error);
                showToast("Erreur: " + error.message, "danger");
            }
        };

        // ✅ Render Pinned Messages
        window.renderPinnedMessages = async function (threadId, pinnedMessageIds) {
            const container = document.getElementById("pinnedMessagesContainer");
            if (!container) return;

            if (!pinnedMessageIds || pinnedMessageIds.length === 0) {
                container.innerHTML = '';
                container.classList.add('d-none');
                return;
            }

            container.classList.remove('d-none');
            container.innerHTML = '<div class="pinned-header"><i class="bi bi-pin-angle-fill"></i> Messages épinglés</div>';

            for (const msgId of pinnedMessageIds) {
                try {
                    const msgSnap = await getDoc(doc(db, "messages", threadId, "thread", msgId));
                    if (msgSnap.exists()) {
                        const msg = msgSnap.data();
                        const preview = msg.content.substring(0, 60) + (msg.content.length > 60 ? '...' : '');

                        const pinnedDiv = document.createElement('div');
                        pinnedDiv.className = 'pinned-message glass-effect hover-lift';
                        pinnedDiv.innerHTML = `
                    <div class="pinned-content" onclick="window.scrollToMessage('${msgId}')">
                        <strong>${escapeHtml(msg.senderName)}:</strong> ${escapeHtml(preview)}
                    </div>
                    <button onclick="window.togglePinMessage('${threadId}', '${msgId}')" 
                            class="btn btn-sm btn-outline-danger"
                            title="Désépingler"
                            aria-label="Désépingler le message">
                        <i class="bi bi-x"></i>
                    </button>
                `;
                        container.appendChild(pinnedDiv);
                    }
                } catch (error) {
                    console.error("Erreur chargement message épinglé:", error);
                }
            }
        };

        // ✅ Scroll to Message
        window.scrollToMessage = function (messageId) {
            const messageEl = document.querySelector(`[data-message-id="${messageId}"]`);
            if (messageEl) {
                messageEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
                messageEl.classList.add('search-active');
                setTimeout(() => messageEl.classList.remove('search-active'), 2000);
            }
        };

        // ============================================
        // ✅ Message Creation (Ensure reactions field)
        // ============================================

        document.getElementById("replyMessageForm")?.addEventListener("submit", async (e) => {
            e.preventDefault();

            const content = document.getElementById("messageInput")?.value.trim();
            if (!content || !currentInboxThreadId) return;

            const user = auth.currentUser;
            const threadId = currentInboxThreadId;

            // Stop typing indicator
            notifyTyping(threadId, user.uid, false);

            try {
                const threadRef = doc(db, "messages", threadId);
                const threadSnap = await getDoc(threadRef);

                if (!threadSnap.exists()) {
                    throw new Error("Thread introuvable.");
                }

                const threadData = threadSnap.data();
                const recipientId = threadData.participants.find(id => id !== user.uid);

                // Create new message with reactions field
                await addDoc(collection(threadRef, "thread"), {
                    content,
                    senderId: user.uid,
                    senderName: user.displayName || 'Anonyme',
                    createdAt: Timestamp.now(),
                    reactions: {}, // Ensure reactions field is initialized
                    isPinned: false // Ensure pinning field is initialized
                });

                // Update thread metadata
                await updateDoc(threadRef, {
                    lastMessageContent: content,
                    lastMessageTime: Timestamp.now(),
                    lastMessageSenderId: user.uid,
                    lastMessageRecipientId: recipientId,
                    lastMessageRead: false
                });

                // Notify recipient
                if (typeof triggerNotificationEvent === "function") {
                    await triggerNotificationEvent(recipientId, {
                        message: `Nouveau message de <strong>${user.displayName || 'Anonyme'}</strong>`,
                        type: "new_message",
                        link: `/inbox/${threadId}`
                    });
                }

                // Reset input
                document.getElementById("messageInput").value = '';
                showToast("Message envoyé !", "success");
                playChatSound('send');

            } catch (error) {
                console.error("Erreur envoi message:", error);
                showToast("Erreur: " + error.message, "danger");
            }
        });

        // ============================================
        // 🎨 CRÉATION DU MESSAGE - VERSION AMÉLIORÉE
        // ============================================


        window.createMessageElement = function (msg, isMe, currentUserId, threadId, avatarUrl, isSameSender) {
            console.log("🔍 createMessageElement appelé:", { messageId: msg.id, reactions: msg.reactions });

            const msgWrapper = document.createElement('div');
            msgWrapper.className = `message-wrapper d-flex align-items-end ${isSameSender ? 'mt-1' : 'mt-3'} ${isMe ? 'justify-content-end' : 'justify-content-start'}`;
            msgWrapper.setAttribute('data-message-id', msg.id);
            msgWrapper.classList.add('position-relative');

            // Avatar for received messages
            if (!isMe) {
                if (avatarUrl) {
                    msgWrapper.innerHTML += `
                <img src="${avatarUrl}" 
                     class="rounded-circle me-2 message-avatar ${isSameSender ? 'invisible' : ''}" 
                     alt="Avatar de l'utilisateur"
                     style="width: 32px; height: 32px; object-fit: cover; border: 2px solid var(--chat-border);">
            `;
                } else {
                    msgWrapper.innerHTML += `
                <div class="d-flex align-items-center justify-content-center rounded-circle me-2 message-avatar ${isSameSender ? 'invisible' : ''}" 
                     style="width: 32px; height: 32px; background: linear-gradient(135deg, var(--chat-muted) 0%, var(--chat-border) 100%);">
                    <i class="bi bi-person text-white" style="font-size: 16px;"></i>
                </div>
            `;
                }
            }

            // Message Bubble
            const msgBubble = document.createElement('div');
            msgBubble.className = `message-bubble ${isMe ? 'message-bubble-sent' : 'message-bubble-received'} shadow-sm`;
            msgBubble.innerHTML = `
        <div class="message-text">${escapeHtml(msg.content)}</div>
        <div class="message-time text-end mt-1">${formatDateShort(msg.createdAt)}</div>
        ${window.renderReactions(msg.reactions || {}, currentUserId, msg.id, threadId)}
    `;

            // Action Buttons
            const actionsDiv = document.createElement('div');
            actionsDiv.className = 'message-actions d-flex align-items-center gap-2 glass-effect';
            actionsDiv.innerHTML = `
        <button class="message-action-btn react-btn" 
                onclick="window.showReactionMenu(event, '${threadId}', '${msg.id}', '${currentUserId}')"
                title="Réagir"
                aria-label="Ajouter une réaction">
            <i class="bi bi-emoji-smile"></i>
        </button>
        <button class="message-action-btn pin-btn ${msg.isPinned ? 'active' : ''}" 
                onclick="window.togglePinMessage('${threadId}', '${msg.id}')"
                title="${msg.isPinned ? 'Désépingler' : 'Épingler'}"
                aria-label="${msg.isPinned ? 'Désépingler le message' : 'Épingler le message'}">
            <i class="bi ${msg.isPinned ? 'bi-pin-fill' : 'bi-pin-angle'}"></i>
        </button>
    `;

            msgWrapper.addEventListener('mouseenter', () => {
                actionsDiv.style.opacity = '1';
                actionsDiv.style.transform = `translateY(-50%) ${isMe ? 'translateX(-4px)' : 'translateX(4px)'}`;
            });
            msgWrapper.addEventListener('mouseleave', () => {
                actionsDiv.style.opacity = '0';
                actionsDiv.style.transform = 'translateY(-50%)';
            });

            msgBubble.appendChild(actionsDiv);
            msgWrapper.appendChild(msgBubble);

            // Avatar for sent messages
            if (isMe) {
                if (avatarUrl) {
                    msgWrapper.innerHTML += `
                <img src="${avatarUrl}" 
                     class="rounded-circle ms-2 message-avatar ${isSameSender ? 'invisible' : ''}" 
                     alt="Votre avatar"
                     style="width: 32px; height: 32px; object-fit: cover; border: 2px solid var(--chat-primary);">
            `;
                } else {
                    msgWrapper.innerHTML += `
                <div class="d-flex align-items-center justify-content-center rounded-circle ms-2 message-avatar ${isSameSender ? 'invisible' : ''}" 
                     style="width: 32px; height: 32px; background: linear-gradient(135deg, var(--chat-primary) 0%, var(--chat-secondary) 100%);">
                    <i class="bi bi-person-fill text-white" style="font-size: 16px;"></i>
                </div>
            `;
                }
            }

            // Search highlight
            if (msg.isSearchResult) {
                msgBubble.classList.add('search-highlight');
                if (msg.isActiveSearchResult) {
                    msgWrapper.classList.add('search-active');
                }
            }

            return msgWrapper;
        };

        // ============================================
        // 🔧 Migration Script for Existing Messages
        // ============================================

        async function migrateMessagesToIncludeReactions() {
            console.log("🚀 Lancement de la migration des messages...");
            try {
                const threadsQuery = query(collection(db, "messages"));
                const threadsSnapshot = await getDocs(threadsQuery);

                for (const threadDoc of threadsSnapshot.docs) {
                    const threadId = threadDoc.id;
                    const messagesQuery = query(collection(db, "messages", threadId, "thread"));
                    const messagesSnapshot = await getDocs(messagesQuery);

                    for (const messageDoc of messagesSnapshot.docs) {
                        const messageData = messageDoc.data();
                        if (messageData.reactions === undefined || messageData.reactions === null) {
                            console.log(`🔧 Migration du message ${messageDoc.id} dans thread ${threadId}`);
                            await updateDoc(doc(db, "messages", threadId, "thread", messageDoc.id), {
                                reactions: {},
                                isPinned: false // Also ensure isPinned is set
                            });
                            console.log(`✅ Message ${messageDoc.id} migré avec reactions: {} et isPinned: false`);
                        }
                    }
                }
                console.log("🎉 Migration terminée avec succès !");
            } catch (error) {
                console.error("❌ Erreur lors de la migration:", error);
            }
        }

        // Exécuter la migration au démarrage
        migrateMessagesToIncludeReactions();

        // ============================================
        // ✅ VÉRIFICATION FINALE
        // ============================================

        console.log("✅ Toutes les fonctions sont maintenant globales:");
        console.log("- window.showReactionMenu:", typeof window.showReactionMenu);
        console.log("- window.toggleReaction:", typeof window.toggleReaction);
        console.log("- window.togglePinMessage:", typeof window.togglePinMessage);
        console.log("- window.renderReactions:", typeof window.renderReactions);
        console.log("- window.createMessageElement:", typeof window.createMessageElement);
        console.log("🎉 Tout est prêt ! Testez maintenant les boutons.");



        function playReactionSound() {
            const audio = new Audio('data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdJivrJBhNjVgodDbq2EcBj+a2/LDciUFLIHO8tiJNwgZaLvt559NEAxQp+PwtmMcBjiR1/LMeSwFJHfH8N2QQAoUXrTp66hVFApGn+DyvmwhBTGH0fPTgjMGHm7A7+OZURE');
            audio.volume = 0.3;
            audio.play().catch(() => { });
        }


        // ============================================
        // 🔔 SYSTÈME DE SONS ET NOTIFICATIONS
        // ============================================

        // Sons encodés en base64 (pas besoin de fichiers externes)
        // 🔊 Définition des fichiers sons
        const CHAT_SOUNDS = {
            // Send: A light, airy "swoosh" sound (0.5-1 second)
            // Characteristics: Rising pitch, smooth, satisfying, like a message flying off
            send: 'data:audio/wav;base64,//vQZAAP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAETEFNRTMuMTAw',
            // Receive: A gentle, melodic "ding" or pluck sound (0.5-0.8 seconds)
            // Characteristics: Soft, welcoming, non-intrusive, like a bell or harp note
            receive: 'data:audio/wav;base64,//vQZAAP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAETEFNRTMuMTAw',
            // Reaction: A short, playful "pop" or sparkle sound (0.3-0.5 seconds)
            // Characteristics: Bright, quick, fun, like a small bubble pop or emoji tap
            reaction: 'data:audio/wav;base64,//vQZAAP8AAAaQAAAAgAAA0gAAABAAABpAAAACAAADSAAAAETEFNRTMuMTAw'
        };

        // Précharger les sons
        const audioCache = {};
        Object.keys(CHAT_SOUNDS).forEach(key => {
            audioCache[key] = new Audio(CHAT_SOUNDS[key]);
            audioCache[key].volume = 0.8;
            audioCache[key].load();
        });


        // Jouer un son
        function playChatSound(soundType) {
            if (!soundSettings.enabled) return;

            const audio = audioCache[soundType];
            if (audio) {
                audio.volume = soundSettings.volume;
                audio.currentTime = 0; // Réinitialiser pour permettre plusieurs sons rapides
                audio.play().catch(err => console.log('Autoplay bloqué:', err));
            }
        }





        // Paramètres des sons (stockés dans localStorage)
        const soundSettings = {
            enabled: localStorage.getItem('chatSoundsEnabled') !== 'false',
            volume: parseFloat(localStorage.getItem('chatSoundsVolume') || '0.5')
        };


        // Toggle sons (pour les paramètres)
        function toggleChatSounds(enabled) {
            soundSettings.enabled = enabled;
            localStorage.setItem('chatSoundsEnabled', enabled);
            showToast(enabled ? '🔊 Sons activés' : '🔇 Sons désactivés', 'info');
        }

        // Changer le volume
        function setChatVolume(volume) {
            soundSettings.volume = Math.max(0, Math.min(1, volume));
            localStorage.setItem('chatSoundsVolume', soundSettings.volume);
            Object.values(audioCache).forEach(audio => {
                audio.volume = soundSettings.volume;
            });
        }

        // ============================================
        // 🔴 BADGE DE NOUVEAUX MESSAGES NON LUS
        // ============================================

        let unreadMessageCount = 0;

        // Mettre à jour le badge de nouveaux messages
        function updateUnreadBadge() {
            const badge = document.getElementById('newMessagesBadge');
            const scrollBtn = document.getElementById('scrollToBottomBtn');

            if (unreadMessageCount > 0) {
                if (badge) {
                    badge.textContent = unreadMessageCount;
                    badge.classList.remove('d-none');
                }
                if (scrollBtn) {
                    scrollBtn.classList.remove('d-none');
                }
            } else {
                if (badge) badge.classList.add('d-none');
                if (scrollBtn) scrollBtn.classList.add('d-none');
            }
        }

        // Détecter si l'utilisateur est en bas du chat
        function isScrolledToBottom(container) {
            const threshold = 100; // pixels de tolérance
            return container.scrollHeight - container.clientHeight <= container.scrollTop + threshold;
        }

        // ============================================
        // 📢 NOTIFICATIONS DE BUREAU (Desktop)
        // ============================================

        // Demander la permission pour les notifications
        function requestNotificationPermission() {
            if (!('Notification' in window)) {
                console.log('Ce navigateur ne supporte pas les notifications');
                return;
            }

            if (Notification.permission === 'default') {
                Notification.requestPermission().then(permission => {
                    if (permission === 'granted') {
                        showToast('✅ Notifications activées', 'success');
                    }
                });
            }
        }

        // Afficher une notification de bureau
        function showDesktopNotification(title, body, icon) {
            if (Notification.permission !== 'granted') return;

            // Ne pas notifier si l'onglet est actif
            if (document.hasFocus()) return;

            const notification = new Notification(title, {
                body: body,
                icon: icon || 'https://ui-avatars.com/api/?name=Chat&background=667eea&color=fff',
                badge: 'https://ui-avatars.com/api/?name=C&background=667eea&color=fff&size=96',
                tag: 'chat-message', // Remplace les anciennes notifications
                requireInteraction: false,
                silent: false
            });

            // Cliquer sur la notification focus la fenêtre
            notification.onclick = () => {
                window.focus();
                notification.close();
            };

            // Auto-fermer après 5 secondes
            setTimeout(() => notification.close(), 5000);
        }

        // ============================================
        // 🎯 INTÉGRATION DANS viewInboxThread
        // ============================================

        // Modifier la fonction de listener des messages pour ajouter les sons
        function setupMessageListener(threadId, currentUserId, logContainer) {
            let isInitialLoad = true;

            const q = query(
                collection(db, "messages", threadId, "thread"),
                orderBy("createdAt", "asc")
            );

            return onSnapshot(q, (snapshot) => {
                const wasScrolledToBottom = isScrolledToBottom(logContainer);

                snapshot.docChanges().forEach((change) => {
                    if (change.type === 'added') {
                        const msg = { id: change.doc.id, ...change.doc.data() };
                        const isMe = msg.senderId === currentUserId;

                        // Ne pas jouer de son au chargement initial
                        if (!isInitialLoad) {
                            if (isMe) {
                                playChatSound('send');
                            } else {
                                playChatSound('receive');

                                // Notification desktop si pas en focus
                                if (!document.hasFocus()) {
                                    showDesktopNotification(
                                        msg.senderName || 'Nouveau message',
                                        msg.content.substring(0, 100),
                                        null
                                    );
                                }

                                // Incrémenter le compteur si pas scrollé en bas
                                if (!wasScrolledToBottom) {
                                    unreadMessageCount++;
                                    updateUnreadBadge();
                                }
                            }

                            // Animation de nouveau message
                            setTimeout(() => {
                                const msgEl = document.querySelector(`[data-message-id="${msg.id}"]`);
                                if (msgEl) {
                                    msgEl.classList.add('new-message');
                                }
                            }, 100);
                        }
                    }
                });

                isInitialLoad = false;

                // Réinitialiser le compteur si scrollé en bas
                if (wasScrolledToBottom) {
                    unreadMessageCount = 0;
                    updateUnreadBadge();
                    logContainer.scrollTop = logContainer.scrollHeight;
                }
            });
        }

        // ============================================
        // 🎨 HTML À AJOUTER AU CHAT
        // ============================================

        function addChatUIElements() {
            // Badge de nouveaux messages (flottant en bas)
            const messageContainer = document.getElementById('messageLogContainer');
            if (messageContainer && !document.getElementById('newMessagesBadge')) {
                const badge = document.createElement('div');
                badge.id = 'scrollToBottomBtn';
                badge.className = 'd-none';
                badge.style.cssText = `
                   position: absolute;
                   bottom: 20px;
                   right: 20px;
                   z-index: 50;
                   cursor: pointer;
                   animation: bounceIn 0.3s;
                `;

                // Icône bouton scroll bas
                badge.innerHTML = `
            <div id="newMessagesBadge"
                style="
                    position: relative;
                    display: inline-flex;
                    align-items: center;
                    justify-content: center;
                    background: #667eea;
                    color: white;
                    font-weight: bold;
                    border-radius: 50%;
                    width: 40px;
                    height: 40px;
                    box-shadow: 0 4px 10px rgba(0,0,0,0.3);
                    transition: transform 0.2s ease;
                ">
                <i class="bi bi-arrow-down-short" style="font-size: 1.4rem;"></i>
                <span id="badgeCount"
                    style="
                        position: absolute;
                        top: -5px;
                        right: -5px;
                        background: red;
                        color: white;
                        border-radius: 50%;
                        font-size: 0.7rem;
                        width: 18px;
                        height: 18px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                    "
                    class="d-none"
                >0</span>
            </div>
        `;
                messageContainer.appendChild(badge);
                messageContainer.classList.add('chat-container');
                console.log('✅ Chat UI elements added');

                // Action : cliquer pour aller tout en bas
                badge.addEventListener('click', () => {
                    messageContainer.scrollTo({
                        top: messageContainer.scrollHeight,
                        behavior: 'smooth'
                    });
                    unreadMessageCount = 0;
                    updateUnreadBadge();
                });
            }

            // Interface des paramètres sons / notifications
            const settingsContainer = document.getElementById('chatSettingsPanel');
            if (settingsContainer && !document.getElementById('chatSoundToggle')) {
                settingsContainer.innerHTML += `
            <div class="border-top pt-3 mt-3">
                <h5 class="fw-bold mb-2"> Notifications & Sons</h5>
                
                <div class="form-check form-switch mb-2">
                    <input class="form-check-input" type="checkbox" id="chatSoundToggle" ${soundSettings.enabled ? 'checked' : ''}>
                    <label class="form-check-label" for="chatSoundToggle">Activer les sons</label>
                </div>

                <div class="mb-3">
                    <label for="chatVolumeRange" class="form-label">Volume</label>
                    <input type="range" class="form-range" min="0" max="1" step="0.05"
                           id="chatVolumeRange" value="${soundSettings.volume}">
                </div>

                <button class="btn btn-outline-primary btn-sm" id="enableDesktopNotifBtn">
                    Activer les notifications de bureau
                </button>
            </div>
        `;

                // Gestion du toggle sons
                document.getElementById('chatSoundToggle').addEventListener('change', e => {
                    toggleChatSounds(e.target.checked);
                });

                // Gestion du volume
                document.getElementById('chatVolumeRange').addEventListener('input', e => {
                    setChatVolume(parseFloat(e.target.value));
                });

                // Activer notifications desktop
                document.getElementById('enableDesktopNotifBtn').addEventListener('click', requestNotificationPermission);
            }
        }

        // ============================================
        // 🧠 GESTION AUTO DU COMPTEUR EN SCROLL
        // ============================================

        function handleScrollUnread(logContainer) {
            logContainer.addEventListener('scroll', () => {
                if (isScrolledToBottom(logContainer)) {
                    unreadMessageCount = 0;
                    updateUnreadBadge();
                }
            });
        }

        // ============================================
        // 🚀 INITIALISATION À L’OUVERTURE DU CHAT
        // ===========================================

        document.addEventListener('DOMContentLoaded', () => {
            const logContainer = document.getElementById('messageLogContainer');

            if (logContainer) {
                // Initialize chat UI with default grid pattern
                addChatUIElements();
                handleScrollUnread(logContainer);
                setChatBackgroundPattern('grid'); // Set default pattern

                // Add pattern toggle buttons to settings panel (if it exists)
                const settingsPanel = document.getElementById('chatSettingsPanel');
                if (settingsPanel) {
                    setupPatternToggles();
                }
            } else {
                console.error('❌ messageLogContainer not found in DOM');
            }
        });

        // Function to set chat background pattern
        function setChatBackgroundPattern(pattern) {
            const logContainer = document.getElementById('messageLogContainer');
            if (!logContainer) {
                console.error('❌ Cannot set pattern: messageLogContainer not found');
                return;
            }

            // Remove existing pattern classes
            logContainer.classList.remove('grid-pattern', 'wave-pattern', 'no-pattern');

            // Apply selected pattern (or no pattern)
            if (pattern === 'grid' || pattern === 'wave') {
                logContainer.classList.add(`${pattern}-pattern`);
                console.log(`✅ Applied ${pattern} pattern to messageLogContainer`);
            } else {
                logContainer.classList.add('no-pattern');
                console.log('✅ Removed background pattern');
            }
        }

        // Function to set up pattern toggle buttons in settings panel
        function setupPatternToggles() {
            const patterns = [
                { id: 'patternGridBtn', pattern: 'grid', label: 'Grid Pattern' },
                { id: 'patternWaveBtn', pattern: 'wave', label: 'Wave Pattern' },
                { id: 'patternNoneBtn', pattern: 'none', label: 'No Pattern' }
            ];

            const settingsPanel = document.getElementById('chatSettingsPanel');
            if (!settingsPanel) return;

            // Create pattern selection UI
            const patternContainer = document.createElement('div');
            patternContainer.className = 'pattern-selector';
            patternContainer.innerHTML = `
        <h6 class="d-flex align-items-center gap-2 mb-3">
            <i class="bi bi-grid"></i> Chat Background Pattern
        </h6>
        <div class="d-flex gap-2 flex-wrap">
            ${patterns.map(p => `
                <button id="${p.id}" class="btn btn-sm btn-outline-primary pattern-btn" 
                        aria-label="Set ${p.label}">
                    ${p.label}
                </button>
            `).join('')}
        </div>
    `;

            settingsPanel.appendChild(patternContainer);

            // Add event listeners for pattern buttons
            patterns.forEach(({ id, pattern }) => {
                const btn = document.getElementById(id);
                if (btn) {
                    btn.addEventListener('click', () => {
                        setChatBackgroundPattern(pattern);
                        // Update active state
                        document.querySelectorAll('.pattern-btn').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                    });
                }
            });

            console.log('✅ Pattern toggle buttons initialized');
        }



        // ============================================
        // 🔍 4. RECHERCHE DANS LES MESSAGES
        // ============================================

        let searchResults = [];
        let currentSearchIndex = 0;

        // Assurez-vous que toutes ces fonctions sont bien définies dans votre script
        window.navigateToSearchResult = navigateToSearchResult;
        window.closeSearch = closeSearch;
        window.searchMessages = searchMessages; // Optionnel, mais bonne pratique si vous exposez des outils

        // Rechercher dans les messages
        async function searchMessages(threadId, searchQuery) {
            const searchInput = document.getElementById('messageSearchInput');
            const resultsCount = document.getElementById('searchResultsCount');

            if (!searchQuery || searchQuery.length < 2) {
                clearSearchHighlights();
                resultsCount.textContent = '';
                return;
            }

            try {
                const messagesQuery = query(
                    collection(db, "messages", threadId, "thread"),
                    orderBy("createdAt", "asc")
                );
                const snapshot = await getDocs(messagesQuery);

                searchResults = [];

                snapshot.docs.forEach(doc => {
                    const data = doc.data();
                    if (data.content.toLowerCase().includes(searchQuery.toLowerCase())) {
                        searchResults.push({
                            id: doc.id,
                            content: data.content
                        });
                    }
                });

                if (searchResults.length > 0) {
                    resultsCount.textContent = `${searchResults.length} résultat${searchResults.length > 1 ? 's' : ''}`;
                    currentSearchIndex = 0;
                    highlightSearchResults(searchQuery);
                    navigateToSearchResult(0);
                } else {
                    resultsCount.textContent = 'Aucun résultat';
                    clearSearchHighlights();
                }
            } catch (error) {
                console.error("Erreur de recherche:", error);
                showToast("Erreur lors de la recherche", "danger");
            }
        }

        // Surligner les résultats
        function highlightSearchResults(searchQuery) {
            clearSearchHighlights();

            const messages = document.querySelectorAll('.message-text');
            const regex = new RegExp(`(${escapeRegex(searchQuery)})`, 'gi');

            messages.forEach(msgEl => {
                const originalText = msgEl.textContent;
                if (originalText.toLowerCase().includes(searchQuery.toLowerCase())) {
                    msgEl.innerHTML = originalText.replace(regex, '<mark class="search-highlight">$1</mark>');
                }
            });
        }

        function clearSearchHighlights() {
            document.querySelectorAll('.search-highlight').forEach(el => {
                const parent = el.parentNode;
                parent.replaceChild(document.createTextNode(el.textContent), el);
            });
            document.querySelectorAll('.search-active').forEach(el => {
                el.classList.remove('search-active');
            });
        }

        // Naviguer entre les résultats
        function navigateToSearchResult(direction) {
            if (searchResults.length === 0) return;

            currentSearchIndex += direction;
            if (currentSearchIndex < 0) currentSearchIndex = searchResults.length - 1;
            if (currentSearchIndex >= searchResults.length) currentSearchIndex = 0;

            const resultId = searchResults[currentSearchIndex].id;
            const messageEl = document.querySelector(`[data-message-id="${resultId}"]`);

            if (messageEl) {
                document.querySelectorAll('.search-active').forEach(el => {
                    el.classList.remove('search-active');
                });

                messageEl.classList.add('search-active');
                messageEl.scrollIntoView({ behavior: 'smooth', block: 'center' });

                document.getElementById('searchResultsCount').textContent =
                    `${currentSearchIndex + 1}/${searchResults.length}`;
            }
        }

        function escapeRegex(string) {
            return string.replace(/[.*+?^${ }()|[\]\\]/g, '\\$&');
        }


        //============== GROUPS ======================//
        // ============================================
        // 👥 SYSTÈME DE GROUPES - MESSAGERIE
        // ============================================

        let currentGroupId = null;
        let unsubscribeGroupMessages = null;
        let unsubscribeGroupsList = null;
        let unsubscribeGroupInvitations = null;

        // ============================================
        // 📋 1. ÉCOUTER LES GROUPES DE L'UTILISATEUR
        // ============================================

        function listenForUserGroups(userId) {
            if (unsubscribeGroupsList) unsubscribeGroupsList();
            if (unsubscribeGroupInvitations) unsubscribeGroupInvitations();

            // Écouter les groupes dont l'utilisateur est membre
            const groupsQuery = query(
                collection(db, "groups"),
                where("members", "array-contains", userId)
            );

            unsubscribeGroupsList = onSnapshot(groupsQuery, async (snapshot) => {
                console.log('📊 Groups loaded:', snapshot.size);
                const groups = snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

                // Écouter aussi les invitations de groupe
                listenForGroupInvitations(userId, groups);
            });
        }

        // ============================================
        // 📨 2. ÉCOUTER LES INVITATIONS DE GROUPE
        // ============================================

        function listenForGroupInvitations(userId, existingGroups) {
            const invitationsQuery = query(
                collection(db, "groupInvitations"),
                where("recipientId", "==", userId),
                where("status", "==", "pending")
            );

            unsubscribeGroupInvitations = onSnapshot(invitationsQuery, async (snapshot) => {
                console.log('📨 Group invitations:', snapshot.size);

                const invitations = snapshot.docs.map(doc => ({
                    id: doc.id,
                    type: 'group_invite',
                    ...doc.data()
                }));

                // Combiner groupes et invitations
                const allItems = [...invitations, ...existingGroups];
                await renderGroupsList(allItems, userId);
            }, (error) => {
                console.error('❌ Error listening to group invitations:', error);
            });
        }

        // ============================================
        // 🎨 3. AFFICHER LA LISTE DES GROUPES
        // ============================================

        async function renderGroupsList(items, currentUserId) {
            const container = document.getElementById("groupsListContainer");
            if (!container) {
                console.error('❌ Container not found: groupsListContainer');
                return;
            }

            console.log('🎨 Rendering groups list with', items.length, 'items');
            container.innerHTML = "";

            if (items.length === 0) {
                container.innerHTML = `
            <div class="text-center text-muted p-5">
                <i class="bi bi-people fs-1 d-block mb-3"></i>
                <p>Aucun groupe trouvé.</p>
                <button class="btn btn-primary mt-2" data-bs-toggle="modal" data-bs-target="#createGroupModal">
                    <i class="bi bi-plus-circle me-2"></i>Créer un groupe
                </button>
            </div>`;
                return;
            }

            // Séparer les invitations et les groupes
            const invitations = items.filter(item => item.type === 'group_invite');
            const groups = items.filter(item => !item.type || item.type !== 'group_invite');

            console.log('📋 Separated:', { invitations: invitations.length, groups: groups.length });

            // Afficher les invitations en premier
            if (invitations.length > 0) {
                const headerInvites = document.createElement('div');
                headerInvites.className = 'text-muted small fw-bold mb-2 mt-3';
                headerInvites.innerHTML = '<i class="bi bi-bell-fill text-warning me-2"></i>INVITATIONS DE GROUPE';
                container.appendChild(headerInvites);

                invitations.forEach(invite => {
                    const inviteCard = document.createElement("div");
                    inviteCard.className = `card card-modern hover-lift p-3 border-warning border-2 mb-3`;
                    inviteCard.setAttribute('data-invite-id', invite.id);

                    inviteCard.innerHTML = `
                <div class="d-flex align-items-start">
                    <i class="bi bi-people-fill fs-2 me-3 text-warning"></i>
                    <div class="flex-grow-1">
                        <h6 class="mb-1 fw-bold text-warning">
                            <i class="bi bi-envelope-fill me-1"></i>
                            Invitation de ${escapeHtml(invite.senderName || 'Utilisateur')}
                        </h6>
                        <p class="mb-1"><strong>Groupe:</strong> ${escapeHtml(invite.groupName)}</p>
                        <p class="mb-2 text-muted small">"${escapeHtml(invite.message || 'Rejoignez notre groupe !')}"</p>
                        <small class="text-muted">Reçu: ${invite.createdAt ? timeAgo(invite.createdAt.toDate()) : 'Récemment'}</small>
                    </div>
                    <div class="text-end ms-2 flex-shrink-0">
                        <button class="btn btn-sm btn-success mb-2 d-block w-100" 
                                onclick="acceptGroupInvitation('${invite.id}')">
                            <i class="bi bi-check-circle me-1"></i>Accepter
                        </button>
                        <button class="btn btn-sm btn-danger d-block w-100" 
                                onclick="rejectGroupInvitation('${invite.id}')">
                            <i class="bi bi-x-circle me-1"></i>Rejeter
                        </button>
                    </div>
                </div>
            `;
                    container.appendChild(inviteCard);
                });
            }

            // Afficher les groupes
            if (groups.length > 0) {
                const headerGroups = document.createElement('div');
                headerGroups.className = 'text-muted small fw-bold mb-2 mt-4';
                headerGroups.innerHTML = '<i class="bi bi-people-fill text-primary me-2"></i>MES GROUPES';
                container.appendChild(headerGroups);

                // Trier par dernière activité
                groups.sort((a, b) => {
                    const timeA = a.lastMessageTime ? a.lastMessageTime.toDate() : new Date(0);
                    const timeB = b.lastMessageTime ? b.lastMessageTime.toDate() : new Date(0);
                    return timeB - timeA;
                });

                groups.forEach(group => {
                    const isAdmin = group.adminId === currentUserId;
                    const memberCount = group.members ? group.members.length : 0;
                    const hasUnread = group.lastMessageSenderId &&
                        group.lastMessageSenderId !== currentUserId &&
                        !group.lastMessageRead;

                    const groupCard = document.createElement("div");
                    groupCard.className = `card card-modern hover-lift p-3 mb-3 ${hasUnread ? 'border-primary border-2' : ''}`;
                    groupCard.style.cursor = 'pointer';
                    groupCard.setAttribute('data-group-id', group.id);
                    groupCard.onclick = () => viewGroupChat(group.id);

                    const avatarHtml = group.avatarURL
                        ? `<img src="${group.avatarURL}" alt="${escapeHtml(group.name)}" 
                    class="rounded-circle me-3" 
                    style="width: 48px; height: 48px; object-fit: cover; border: 2px solid #e9ecef;">`
                        : `<div class="d-flex align-items-center justify-content-center rounded-circle me-3"
                    style="width: 48px; height: 48px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                    <i class="bi bi-people-fill text-white fs-4"></i>
                </div>`;

                    groupCard.innerHTML = `
                <div class="d-flex align-items-center">
                    ${avatarHtml}
                    <div class="flex-grow-1">
                        <h6 class="mb-0 ${hasUnread ? 'fw-bold text-primary' : ''}">
                            ${escapeHtml(group.name)}
                            ${isAdmin ? '<span class="badge bg-success ms-2" style="font-size: 0.7rem;">Admin</span>' : ''}
                        </h6>
                        <small class="text-muted">
                            <i class="bi bi-people me-1"></i>${memberCount} membre${memberCount > 1 ? 's' : ''}
                        </small>
                        ${group.lastMessageContent ? `
                            <div class="text-muted small mt-1">
                                <i class="bi bi-chat-dots me-1"></i>
                                ${escapeHtml(group.lastMessageContent.substring(0, 50))}${group.lastMessageContent.length > 50 ? '...' : ''}
                            </div>
                        ` : ''}
                    </div>
                    <div class="text-end">
                        <small class="text-muted">
                            ${group.lastMessageTime ? timeAgo(group.lastMessageTime.toDate()) : 'Nouveau'}
                        </small>
                        ${hasUnread ? '<span class="badge bg-danger ms-2">Nouveau</span>' : ''}
                    </div>
                </div>
            `;
                    container.appendChild(groupCard);
                });
            }
        }

        // ============================================
        // 🧪 SCRIPT DE TEST ET DÉMONSTRATION
        // Système de Groupes - Messagerie
        // ============================================

        console.log("🧪 Mode Test - Système de Groupes");

        // ============================================
        // 📊 FONCTION DE DIAGNOSTIC
        // ============================================

        window.diagnoseGroupsSystem = async function () {
            console.log("🔍 === DIAGNOSTIC DU SYSTÈME DE GROUPES ===");

            const checks = {
                auth: false,
                firebase: false,
                collections: false,
                ui: false,
                functions: false
            };

            // 1. Vérifier l'authentification
            try {
                const user = auth.currentUser;
                if (user) {
                    console.log("✅ Utilisateur connecté:", user.email);
                    checks.auth = true;
                } else {
                    console.log("❌ Aucun utilisateur connecté");
                }
            } catch (e) {
                console.error("❌ Erreur auth:", e);
            }

            // 2. Vérifier Firebase
            try {
                if (typeof db !== 'undefined' && db) {
                    console.log("✅ Firestore initialisé");
                    checks.firebase = true;
                } else {
                    console.log("❌ Firestore non initialisé");
                }
            } catch (e) {
                console.error("❌ Erreur Firestore:", e);
            }

            // 3. Vérifier les collections
            if (checks.auth && checks.firebase) {
                try {
                    const user = auth.currentUser;

                    // Compter les groupes
                    const groupsQuery = query(
                        collection(db, "groups"),
                        where("members", "array-contains", user.uid)
                    );
                    const groupsSnap = await getDocs(groupsQuery);
                    console.log(`✅ ${groupsSnap.size} groupe(s) trouvé(s)`);

                    // Compter les invitations
                    const invitesQuery = query(
                        collection(db, "groupInvitations"),
                        where("recipientId", "==", user.uid),
                        where("status", "==", "pending")
                    );
                    const invitesSnap = await getDocs(invitesQuery);
                    console.log(`✅ ${invitesSnap.size} invitation(s) en attente`);

                    checks.collections = true;
                } catch (e) {
                    console.error("❌ Erreur lecture collections:", e);
                }
            }

            // 4. Vérifier les éléments UI
            const uiElements = [
                'groupsView',
                'groupsList',
                'groupChatView',
                'groupsListContainer',
                'groupMessagesContainer',
                'createGroupModal',
                'inviteMembersModal',
                'groupSettingsModal'
            ];

            let missingElements = [];
            uiElements.forEach(id => {
                if (!document.getElementById(id)) {
                    missingElements.push(id);
                }
            });

            if (missingElements.length === 0) {
                console.log("✅ Tous les éléments UI sont présents");
                checks.ui = true;
            } else {
                console.log("❌ Éléments UI manquants:", missingElements);
            }

            // 5. Vérifier les fonctions
            const functions = [
                'listenForUserGroups',
                'viewGroupChat',
                'acceptGroupInvitation',
                'rejectGroupInvitation',
                'removeMemberFromGroup',
                'leaveGroup',
                'deleteGroup'
            ];

            let missingFunctions = [];
            functions.forEach(func => {
                if (typeof window[func] === 'undefined' && typeof eval(func) === 'undefined') {
                    missingFunctions.push(func);
                }
            });

            if (missingFunctions.length === 0) {
                console.log("✅ Toutes les fonctions sont définies");
                checks.functions = true;
            } else {
                console.log("❌ Fonctions manquantes:", missingFunctions);
            }

            // Résumé
            console.log("\n📋 === RÉSUMÉ DU DIAGNOSTIC ===");
            const allChecks = Object.values(checks).every(v => v === true);
            if (allChecks) {
                console.log("✅ SYSTÈME OPÉRATIONNEL - Tous les tests passés !");
            } else {
                console.log("⚠️ PROBLÈMES DÉTECTÉS - Vérifiez les erreurs ci-dessus");
                console.log("État des vérifications:", checks);
            }

            return checks;
        };

        window.debugGroupInvitation = async function (recipientId) {
            console.log("🔍 === DIAGNOSTIC DES INVITATIONS DE GROUPE ===\n");

            const user = auth.currentUser;
            if (!user) {
                console.error("❌ Pas d'utilisateur connecté");
                return;
            }

            console.log("✅ Utilisateur:", user.uid, user.email);

            // 1. Vérifier que currentGroupId est défini
            console.log("\n1️⃣ Vérification du groupe actuel:");
            if (!currentGroupId) {
                console.error("❌ currentGroupId n'est pas défini. Ouvrez d'abord un groupe.");
                return;
            }
            console.log("✅ Group ID:", currentGroupId);

            // 2. Vérifier que le groupe existe
            console.log("\n2️⃣ Vérification de l'existence du groupe:");
            try {
                const groupRef = doc(db, "groups", currentGroupId);
                const groupSnap = await getDoc(groupRef);

                if (!groupSnap.exists()) {
                    console.error("❌ Le groupe n'existe pas!");
                    return;
                }

                const groupData = groupSnap.data();
                console.log("✅ Groupe trouvé:", groupData.name);
                console.log("   Membres:", groupData.members);
                console.log("   Admin:", groupData.adminId);

                // 3. Vérifier que l'utilisateur est membre
                console.log("\n3️⃣ Vérification de l'appartenance:");
                if (!groupData.members.includes(user.uid)) {
                    console.error("❌ Vous n'êtes pas membre de ce groupe!");
                    console.log("   Vos UID:", user.uid);
                    console.log("   Membres du groupe:", groupData.members);
                    return;
                }
                console.log("✅ Vous êtes membre du groupe");

                // 4. Vérifier le destinataire
                console.log("\n4️⃣ Vérification du destinataire:");
                if (!recipientId) {
                    console.error("❌ Aucun destinataire spécifié");
                    return;
                }

                const recipientRef = doc(db, "users", recipientId);
                const recipientSnap = await getDoc(recipientRef);

                if (!recipientSnap.exists()) {
                    console.error("❌ Destinataire introuvable!");
                    return;
                }

                const recipientData = recipientSnap.data();
                console.log("✅ Destinataire trouvé:", recipientData.name || recipientData.email);

                // 5. Vérifier si le destinataire est déjà membre
                console.log("\n5️⃣ Vérification si déjà membre:");
                if (groupData.members.includes(recipientId)) {
                    console.error("⚠️ Le destinataire est déjà membre du groupe!");
                    return;
                }
                console.log("✅ Le destinataire n'est pas encore membre");

                // 6. Vérifier les invitations existantes
                console.log("\n6️⃣ Vérification des invitations existantes:");
                const existingInvitesQuery = query(
                    collection(db, "groupInvitations"),
                    where("groupId", "==", currentGroupId),
                    where("recipientId", "==", recipientId),
                    where("status", "==", "pending")
                );

                const existingSnap = await getDocs(existingInvitesQuery);
                if (!existingSnap.empty) {
                    console.error("⚠️ Une invitation est déjà en attente pour cet utilisateur");
                    existingSnap.forEach(doc => {
                        console.log("   Invitation ID:", doc.id, doc.data());
                    });
                    return;
                }
                console.log("✅ Aucune invitation en attente");

                // 7. Créer les données d'invitation
                console.log("\n7️⃣ Préparation des données d'invitation:");
                const invitationData = {
                    groupId: currentGroupId,
                    groupName: groupData.name,
                    senderId: user.uid,
                    senderName: user.displayName || user.email || 'Anonyme',
                    recipientId: recipientId,
                    recipientName: recipientData.name || recipientData.email,
                    message: "Rejoignez notre groupe !",
                    status: 'pending',
                    createdAt: Timestamp.now()
                };

                console.log("✅ Données préparées:");
                console.log(JSON.stringify(invitationData, null, 2));

                // 8. Tester la création
                console.log("\n8️⃣ Test de création de l'invitation:");
                try {
                    const inviteRef = await addDoc(collection(db, "groupInvitations"), invitationData);
                    console.log("✅✅✅ INVITATION CRÉÉE AVEC SUCCÈS!");
                    console.log("   ID:", inviteRef.id);
                    return inviteRef.id;
                } catch (error) {
                    console.error("❌ ERREUR LORS DE LA CRÉATION:");
                    console.error("   Code:", error.code);
                    console.error("   Message:", error.message);
                    console.error("   Détails complets:", error);

                    // Analyse de l'erreur
                    if (error.code === 'permission-denied') {
                        console.log("\n🔍 ANALYSE DE L'ERREUR DE PERMISSION:");
                        console.log("Les règles Firestore bloquent la création.");
                        console.log("\nVérifiez que:");
                        console.log("1. Les règles sont bien déployées");
                        console.log("2. request.resource.data.senderId == request.auth.uid");
                        console.log("3. Le groupe existe: exists(/databases/.../groups/...)");
                        console.log("4. Vous êtes membre: request.auth.uid in get(...).data.members");
                    }
                }

            } catch (error) {
                console.error("❌ Erreur générale:", error);
            }
        };

        // ============================================
        // 🧪 TEST RAPIDE
        // ============================================

        window.quickTestInvitation = async function () {
            console.log("🧪 === TEST RAPIDE ===\n");

            // 1. Trouver un utilisateur à inviter
            const usersQuery = query(collection(db, "users"), limit(5));
            const usersSnap = await getDocs(usersQuery);

            console.log("👥 Utilisateurs disponibles:");
            usersSnap.forEach((doc, index) => {
                const data = doc.data();
                console.log(`${index + 1}. ${data.name || data.email} (${doc.id})`);
            });

            if (usersSnap.empty) {
                console.error("❌ Aucun utilisateur trouvé");
                return;
            }

            // Prendre le premier utilisateur différent de nous
            const user = auth.currentUser;
            let targetUser = null;

            for (const doc of usersSnap.docs) {
                if (doc.id !== user.uid) {
                    targetUser = { id: doc.id, ...doc.data() };
                    break;
                }
            }

            if (!targetUser) {
                console.error("❌ Pas d'autre utilisateur disponible");
                return;
            }

            console.log("\n🎯 Utilisateur sélectionné:", targetUser.name || targetUser.email);
            console.log("\n🔍 Lancement du diagnostic...\n");

            await debugGroupInvitation(targetUser.id);
        };

        // ============================================
        // 📊 LISTER TOUTES LES INVITATIONS
        // ============================================

        window.listAllInvitations = async function () {
            console.log("📊 === TOUTES LES INVITATIONS ===\n");

            try {
                const invitesSnap = await getDocs(collection(db, "groupInvitations"));

                console.log(`Total: ${invitesSnap.size} invitation(s)\n`);

                invitesSnap.forEach((doc, index) => {
                    const data = doc.data();
                    console.log(`${index + 1}. ID: ${doc.id}`);
                    console.log(`   Groupe: ${data.groupName}`);
                    console.log(`   De: ${data.senderName} (${data.senderId})`);
                    console.log(`   À: ${data.recipientName} (${data.recipientId})`);
                    console.log(`   Status: ${data.status}`);
                    console.log(`   Date: ${data.createdAt?.toDate()}\n`);
                });

            } catch (error) {
                console.error("❌ Erreur:", error);
            }
        };

        console.log("✅ Scripts de débogage chargés!");
        console.log("\n📝 Commandes disponibles:");
        console.log("  - debugGroupInvitation('userId')  // Diagnostic complet");
        console.log("  - quickTestInvitation()           // Test automatique");
        console.log("  - listAllInvitations()            // Lister toutes les invitations");

        // ============================================
        // 🎯 FONCTIONS DE TEST UNITAIRE
        // ============================================

        // Test 1: Créer un groupe de test
        window.testCreateGroup = async function () {
            console.log("🧪 Test: Création d'un groupe");

            const user = auth.currentUser;
            if (!user) {
                console.error("❌ Utilisateur non connecté");
                return false;
            }

            try {
                const testGroupData = {
                    name: `Test Group ${Date.now()}`,
                    description: "Groupe créé automatiquement pour les tests",
                    adminId: user.uid,
                    members: [user.uid],
                    memberNames: {
                        [user.uid]: user.displayName || user.email || "Test User"
                    },
                    createdAt: Timestamp.now(),
                    lastMessageContent: null,
                    lastMessageTime: null,
                    lastMessageSenderId: null,
                    avatarURL: null
                };

                const groupRef = await addDoc(collection(db, "groups"), testGroupData);
                console.log("✅ Groupe de test créé avec ID:", groupRef.id);

                // Ajouter un message de test
                await addDoc(collection(db, "groups", groupRef.id, "messages"), {
                    content: "🧪 Message de test automatique",
                    senderId: 'system',
                    senderName: 'Système de Test',
                    createdAt: Timestamp.now(),
                    reactions: {},
                    isSystemMessage: true
                });

                console.log("✅ Message de test ajouté");
                return groupRef.id;

            } catch (error) {
                console.error("❌ Erreur test création:", error);
                return false;
            }
        };

        // Test 2: Créer une invitation de test
        window.testCreateInvitation = async function (targetUserId) {
            console.log("🧪 Test: Création d'une invitation");

            const user = auth.currentUser;
            if (!user) {
                console.error("❌ Utilisateur non connecté");
                return false;
            }

            if (!targetUserId) {
                console.error("❌ ID utilisateur cible requis");
                return false;
            }

            try {
                // Créer d'abord un groupe
                const groupId = await testCreateGroup();
                if (!groupId) throw new Error("Impossible de créer le groupe de test");

                const groupSnap = await getDoc(doc(db, "groups", groupId));
                const groupData = groupSnap.data();

                // Récupérer infos utilisateur cible
                const targetUserSnap = await getDoc(doc(db, "users", targetUserId));
                if (!targetUserSnap.exists()) throw new Error("Utilisateur cible introuvable");
                const targetUserData = targetUserSnap.data();

                // Créer l'invitation
                const invitationData = {
                    groupId: groupId,
                    groupName: groupData.name,
                    senderId: user.uid,
                    senderName: user.displayName || user.email || 'Test User',
                    recipientId: targetUserId,
                    recipientName: targetUserData.name || targetUserData.email,
                    message: "🧪 Invitation de test automatique",
                    status: 'pending',
                    createdAt: Timestamp.now()
                };

                const inviteRef = await addDoc(collection(db, "groupInvitations"), invitationData);
                console.log("✅ Invitation de test créée avec ID:", inviteRef.id);
                return inviteRef.id;

            } catch (error) {
                console.error("❌ Erreur test invitation:", error);
                return false;
            }
        };

        // Test 3: Lister tous les groupes de l'utilisateur
        window.testListUserGroups = async function () {
            console.log("🧪 Test: Liste des groupes");

            const user = auth.currentUser;
            if (!user) {
                console.error("❌ Utilisateur non connecté");
                return;
            }

            try {
                const groupsQuery = query(
                    collection(db, "groups"),
                    where("members", "array-contains", user.uid)
                );

                const snapshot = await getDocs(groupsQuery);
                console.log(`📊 ${snapshot.size} groupe(s) trouvé(s):`);

                snapshot.forEach(doc => {
                    const data = doc.data();
                    console.log(`  - ${data.name} (${data.members.length} membres)`);
                    console.log(`    Admin: ${data.adminId === user.uid ? 'Vous' : data.memberNames[data.adminId]}`);
                });

                return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            } catch (error) {
                console.error("❌ Erreur test liste:", error);
            }
        };

        // Test 4: Lister les invitations en attente
        window.testListPendingInvitations = async function () {
            console.log("🧪 Test: Invitations en attente");

            const user = auth.currentUser;
            if (!user) {
                console.error("❌ Utilisateur non connecté");
                return;
            }

            try {
                const invitesQuery = query(
                    collection(db, "groupInvitations"),
                    where("recipientId", "==", user.uid),
                    where("status", "==", "pending")
                );

                const snapshot = await getDocs(invitesQuery);
                console.log(`📧 ${snapshot.size} invitation(s) en attente:`);

                snapshot.forEach(doc => {
                    const data = doc.data();
                    console.log(`  - ${data.groupName} de ${data.senderName}`);
                });

                return snapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));

            } catch (error) {
                console.error("❌ Erreur test invitations:", error);
            }
        };

        // Test 5: Nettoyer les données de test
        window.cleanupTestData = async function () {
            console.log("🧹 Nettoyage des données de test...");

            const user = auth.currentUser;
            if (!user) {
                console.error("❌ Utilisateur non connecté");
                return;
            }

            try {
                // Supprimer les groupes de test
                const groupsQuery = query(
                    collection(db, "groups"),
                    where("adminId", "==", user.uid)
                );

                const groupsSnap = await getDocs(groupsQuery);
                let deletedGroups = 0;

                for (const groupDoc of groupsSnap.docs) {
                    const data = groupDoc.data();
                    if (data.name.includes('Test Group')) {
                        // Supprimer les messages
                        const messagesSnap = await getDocs(
                            collection(db, "groups", groupDoc.id, "messages")
                        );
                        for (const msgDoc of messagesSnap.docs) await deleteDoc(msgDoc.ref);

                        // Supprimer le groupe
                        await deleteDoc(groupDoc.ref);
                        deletedGroups++;
                        console.log(`  ✅ Groupe supprimé: ${data.name}`);
                    }
                }

                // Supprimer les invitations de test
                const invitesQuery = query(
                    collection(db, "groupInvitations"),
                    where("senderId", "==", user.uid)
                );

                const invitesSnap = await getDocs(invitesQuery);
                let deletedInvites = 0;

                for (const inviteDoc of invitesSnap.docs) {
                    const data = inviteDoc.data();
                    if (data.message.includes('test')) {
                        await deleteDoc(inviteDoc.ref);
                        deletedInvites++;
                        console.log(`  ✅ Invitation supprimée`);
                    }
                }

                console.log(`\n✅ Nettoyage terminé: ${deletedGroups} groupe(s), ${deletedInvites} invitation(s)`);

            } catch (error) {
                console.error("❌ Erreur nettoyage:", error);
            }
        };

        // ============================================
        // 🎮 DÉMO INTERACTIVE
        // ============================================

        window.runGroupsDemo = async function () {
            console.log("🎮 === DÉMONSTRATION DU SYSTÈME DE GROUPES ===\n");

            // Étape 1: Diagnostic
            console.log("📋 Étape 1: Diagnostic du système");
            const checks = await diagnoseGroupsSystem();

            if (!Object.values(checks).every(v => v === true)) {
                console.error("❌ Le système n'est pas opérationnel. Arrêt de la démo.");
                return;
            }

            console.log("\n⏱️ Pause de 2 secondes...\n");
            await new Promise(resolve => setTimeout(resolve, 2000));

            // Étape 2: Lister les groupes existants
            console.log("📋 Étape 2: Liste des groupes existants");
            await testListUserGroups();

            console.log("\n⏱️ Pause de 2 secondes...\n");
            await new Promise(resolve => setTimeout(resolve, 2000));

            // Étape 3: Lister les invitations
            console.log("📋 Étape 3: Liste des invitations en attente");
            await testListPendingInvitations();

            console.log("\n⏱️ Pause de 2 secondes...\n");
            await new Promise(resolve => setTimeout(resolve, 2000));

            // Étape 4: Créer un groupe de test
            console.log("📋 Étape 4: Création d'un groupe de test");
            const groupId = await testCreateGroup();

            if (groupId) {
                console.log(`✅ Groupe créé: ${groupId}`);
                console.log("💡 Vous pouvez maintenant le voir dans l'interface !");
            }

            console.log("\n🎉 === DÉMONSTRATION TERMINÉE ===");
            console.log("💡 Commandes disponibles:");
            console.log("  - diagnoseGroupsSystem()");
            console.log("  - testCreateGroup()");
            console.log("  - testListUserGroups()");
            console.log("  - testListPendingInvitations()");
            console.log("  - cleanupTestData()");
        };

        // ============================================
        // 🔧 UTILITAIRES DE DÉVELOPPEMENT
        // ============================================

        // Activer le mode debug
        window.debugGroupsMode = true;

        window.logDebug = function (...args) {
            if (window.debugGroupsMode) console.log("[DEBUG]", ...args);
        };

        // ============================================
        // ✅ 4. ACCEPTER UNE INVITATION DE GROUPE
        // ============================================

        window.acceptGroupInvitation = async function (inviteId) {
            const user = auth.currentUser;
            if (!user) {
                showToast("Vous devez être connecté.", "warning");
                return;
            }

            console.log('✅ Accepting group invitation:', inviteId);

            const inviteCard = document.querySelector(`[data-invite-id="${inviteId}"]`);
            if (inviteCard) {
                inviteCard.style.opacity = '0.6';
                inviteCard.style.pointerEvents = 'none';
            }

            try {
                const inviteRef = doc(db, "groupInvitations", inviteId);
                const inviteSnap = await getDoc(inviteRef);

                if (!inviteSnap.exists()) {
                    throw new Error("Invitation introuvable.");
                }

                const inviteData = inviteSnap.data();

                if (inviteData.status !== 'pending') {
                    throw new Error("Cette invitation a déjà été traitée.");
                }

                const groupId = inviteData.groupId;
                const groupRef = doc(db, "groups", groupId);

                // Transaction pour ajouter le membre et supprimer l'invitation
                await runTransaction(db, async (transaction) => {
                    const groupSnap = await transaction.get(groupRef);

                    if (!groupSnap.exists()) {
                        throw new Error("Groupe introuvable.");
                    }

                    const groupData = groupSnap.data();
                    const members = groupData.members || [];

                    if (members.includes(user.uid)) {
                        throw new Error("Vous êtes déjà membre de ce groupe.");
                    }

                    // Ajouter le membre
                    members.push(user.uid);

                    // Mettre à jour les noms des membres
                    const memberNames = groupData.memberNames || {};
                    memberNames[user.uid] = user.displayName || user.email || "Anonyme";

                    transaction.update(groupRef, {
                        members: members,
                        memberNames: memberNames
                    });

                    // Supprimer l'invitation
                    transaction.delete(inviteRef);
                });

                console.log('✅ Successfully joined group!');
                showToast("Vous avez rejoint le groupe !", "success");

                // Notifier l'admin
                const groupSnap = await getDoc(groupRef);
                if (groupSnap.exists()) {
                    const groupData = groupSnap.data();
                    if (typeof triggerNotificationEvent === "function") {
                        await triggerNotificationEvent(groupData.adminId, {
                            message: `<strong>${user.displayName || 'Un utilisateur'}</strong> a rejoint le groupe <strong>${groupData.name}</strong>`,
                            type: "group_member_joined",
                            link: "/groups"
                        });
                    }
                }

            } catch (error) {
                console.error("❌ Erreur:", error);
                showToast("Erreur: " + error.message, "danger");

                if (inviteCard) {
                    inviteCard.style.opacity = '1';
                    inviteCard.style.pointerEvents = 'auto';
                }
            }
        };

        // ============================================
        // ❌ 5. REJETER UNE INVITATION DE GROUPE
        // ============================================

        window.rejectGroupInvitation = async function (inviteId) {
            if (!confirm("Voulez-vous vraiment rejeter cette invitation ?")) {
                return;
            }

            const user = auth.currentUser;
            if (!user) {
                showToast("Vous devez être connecté.", "warning");
                return;
            }

            console.log('❌ Rejecting group invitation:', inviteId);

            const inviteCard = document.querySelector(`[data-invite-id="${inviteId}"]`);
            if (inviteCard) {
                inviteCard.style.opacity = '0.6';
                inviteCard.style.pointerEvents = 'none';
            }

            try {
                const inviteRef = doc(db, "groupInvitations", inviteId);
                const inviteSnap = await getDoc(inviteRef);

                if (!inviteSnap.exists()) {
                    throw new Error("Invitation introuvable.");
                }

                const inviteData = inviteSnap.data();
                await deleteDoc(inviteRef);

                console.log('✅ Invitation deleted');
                showToast("Invitation rejetée.", "info");

                // Notifier l'expéditeur
                if (typeof triggerNotificationEvent === "function") {
                    await triggerNotificationEvent(inviteData.senderId, {
                        message: `Votre invitation au groupe a été déclinée.`,
                        type: "group_invite_rejected",
                        link: "/groups"
                    });
                }

                if (inviteCard) {
                    inviteCard.style.transition = 'all 0.3s ease';
                    inviteCard.style.transform = 'translateX(-100%)';
                    inviteCard.style.opacity = '0';
                    setTimeout(() => inviteCard.remove(), 300);
                }

            } catch (error) {
                console.error("❌ Erreur:", error);
                showToast("Erreur: " + error.message, "danger");

                if (inviteCard) {
                    inviteCard.style.opacity = '1';
                    inviteCard.style.pointerEvents = 'auto';
                }
            }
        };


        // ============================================
        // 💬 6. AFFICHER LE CHAT DU GROUPE
        // ============================================

        async function viewGroupChat(groupId) {
            document.getElementById("groupsList").classList.add("d-none");
            document.getElementById("groupChatView").classList.remove("d-none");
            currentGroupId = groupId;

            if (unsubscribeGroupMessages) {
                unsubscribeGroupMessages();
                unsubscribeGroupMessages = null;
            }

            const user = auth.currentUser;
            const groupRef = doc(db, "groups", groupId);
            const groupSnap = await getDoc(groupRef);

            if (!groupSnap.exists()) {
                showToast("Groupe introuvable", "danger");
                return;
            }

            const groupData = groupSnap.data();
            const isAdmin = groupData.adminId === user.uid;

            // Mettre à jour le header
            document.getElementById("groupChatTitle").textContent = groupData.name;
            document.getElementById("groupMemberCount").textContent = `${groupData.members.length} membre${groupData.members.length > 1 ? 's' : ''}`;

            // Bouton paramètres (visible uniquement pour l'admin)
            const settingsBtn = document.getElementById("groupSettingsBtn");
            if (settingsBtn) {
                settingsBtn.classList.toggle('d-none', !isAdmin);
                settingsBtn.onclick = () => openGroupSettings(groupId);
            }

            // Charger les messages
            const messagesContainer = document.getElementById("groupMessagesContainer");
            messagesContainer.innerHTML = '<div class="text-center text-muted p-3"><div class="spinner-border spinner-border-sm text-primary me-2"></div>Chargement...</div>';

            // Écouter les messages en temps réel
            const messagesQuery = query(
                collection(db, "groups", groupId, "messages"),
                orderBy("createdAt", "asc")
            );

            unsubscribeGroupMessages = onSnapshot(messagesQuery, async (snapshot) => {
                messagesContainer.innerHTML = '';

                if (snapshot.empty) {
                    messagesContainer.innerHTML = '<div class="text-center text-muted p-4"><i class="bi bi-chat-dots fs-1 d-block mb-2"></i>Soyez le premier à envoyer un message !</div>';
                    return;
                }

                // Récupérer les avatars
                const avatarsMap = {};
                for (const memberId of groupData.members) {
                    if (!avatarsMap[memberId]) {
                        try {
                            const userDoc = await getDoc(doc(db, "users", memberId));
                            if (userDoc.exists()) {
                                avatarsMap[memberId] = userDoc.data().photoURL || null;
                            }
                        } catch (e) {
                            console.error("Error fetching avatar:", e);
                        }
                    }
                }

                let lastSenderId = null;

                snapshot.forEach((docSnap) => {
                    const msg = { id: docSnap.id, ...docSnap.data() };
                    const isMe = msg.senderId === user.uid;
                    const avatarUrl = avatarsMap[msg.senderId];
                    const isSameSender = lastSenderId === msg.senderId;
                    lastSenderId = msg.senderId;

                    const messageEl = createGroupMessageElement(msg, isMe, user.uid, groupId, avatarUrl, isSameSender);
                    messagesContainer.appendChild(messageEl);
                });

                // Auto-scroll
                messagesContainer.scrollTop = messagesContainer.scrollHeight;

                // Jouer le son pour les nouveaux messages
                if (!snapshot.metadata.hasPendingWrites) {
                    const lastMsg = snapshot.docs[snapshot.docs.length - 1]?.data();
                    if (lastMsg && lastMsg.senderId !== user.uid) {
                        playChatSound('receive');
                    }
                }
            });
        }

        // ============================================
        // 🎨 7. CRÉER L'ÉLÉMENT MESSAGE DE GROUPE
        // ============================================

        function createGroupMessageElement(msg, isMe, currentUserId, groupId, avatarUrl, isSameSender) {
            const msgWrapper = document.createElement('div');
            msgWrapper.className = `message-wrapper d-flex align-items-end ${isSameSender ? 'mt-1' : 'mt-3'} ${isMe ? 'justify-content-end' : 'justify-content-start'}`;
            msgWrapper.setAttribute('data-message-id', msg.id);

            // Avatar (pour les messages reçus)
            if (!isMe) {
                if (avatarUrl) {
                    msgWrapper.innerHTML += `
                <img src="${avatarUrl}" 
                     class="rounded-circle me-2 message-avatar ${isSameSender ? 'invisible' : ''}" 
                     alt="Avatar"
                     style="width: 32px; height: 32px; object-fit: cover; border: 2px solid #e9ecef;">
            `;
                } else {
                    msgWrapper.innerHTML += `
                <div class="d-flex align-items-center justify-content-center rounded-circle me-2 message-avatar ${isSameSender ? 'invisible' : ''}" 
                     style="width: 32px; height: 32px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                    <i class="bi bi-person text-white" style="font-size: 16px;"></i>
                </div>
            `;
                }
            }

            // Bulle de message
            const msgBubble = document.createElement('div');
            msgBubble.className = `message-bubble ${isMe ? 'message-bubble-sent' : 'message-bubble-received'} shadow-sm`;

            // Nom de l'expéditeur (sauf pour nos propres messages)
            const senderNameHtml = !isMe && !isSameSender
                ? `<div class="message-sender-name">${escapeHtml(msg.senderName || 'Anonyme')}</div>`
                : '';

            msgBubble.innerHTML = `
        ${senderNameHtml}
        <div class="message-text">${escapeHtml(msg.content)}</div>
        <div class="message-time text-end mt-1">${formatDateShort(msg.createdAt)}</div>
        ${window.renderReactions ? window.renderReactions(msg.reactions || {}, currentUserId, msg.id, groupId) : ''}
    `;

            msgWrapper.appendChild(msgBubble);

            // Avatar (pour nos messages)
            if (isMe) {
                if (avatarUrl) {
                    msgWrapper.innerHTML += `
                <img src="${avatarUrl}" 
                     class="rounded-circle ms-2 message-avatar ${isSameSender ? 'invisible' : ''}" 
                     alt="Votre avatar"
                     style="width: 32px; height: 32px; object-fit: cover; border: 2px solid #667eea;">
            `;
                } else {
                    msgWrapper.innerHTML += `
                <div class="d-flex align-items-center justify-content-center rounded-circle ms-2 message-avatar ${isSameSender ? 'invisible' : ''}" 
                     style="width: 32px; height: 32px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);">
                    <i class="bi bi-person-fill text-white" style="font-size: 16px;"></i>
                </div>
            `;
                }
            }

            return msgWrapper;
        }

        // ============================================
        // 📤 8. ENVOYER UN MESSAGE DANS LE GROUPE
        // ============================================

        document.getElementById("groupMessageForm")?.addEventListener("submit", async (e) => {
            e.preventDefault();

            const content = document.getElementById("groupMessageInput")?.value.trim();
            if (!content || !currentGroupId) return;

            const user = auth.currentUser;

            try {
                const groupRef = doc(db, "groups", currentGroupId);

                // Créer le message
                await addDoc(collection(groupRef, "messages"), {
                    content,
                    senderId: user.uid,
                    senderName: user.displayName || 'Anonyme',
                    createdAt: Timestamp.now(),
                    reactions: {}
                });

                // Mettre à jour les métadonnées du groupe
                await updateDoc(groupRef, {
                    lastMessageContent: content,
                    lastMessageTime: Timestamp.now(),
                    lastMessageSenderId: user.uid
                });

                // Reset input
                document.getElementById("groupMessageInput").value = '';
                showToast("Message envoyé !", "success");
                playChatSound('send');

            } catch (error) {
                console.error("Erreur envoi message:", error);
                showToast("Erreur: " + error.message, "danger");
            }
        });

        // ============================================
        // ⚙️ 9. PARAMÈTRES DU GROUPE (ADMIN SEULEMENT)
        // ============================================

        async function openGroupSettings(groupId) {
            // Charger les données du groupe
            const groupRef = doc(db, "groups", groupId);
            const groupSnap = await getDoc(groupRef);

            if (!groupSnap.exists()) {
                showToast("Groupe introuvable", "danger");
                return;
            }

            const groupData = groupSnap.data();

            // Afficher le modal avec les informations
            const modal = new bootstrap.Modal(document.getElementById("groupSettingsModal"));

            document.getElementById("settingsGroupName").value = groupData.name;
            document.getElementById("settingsGroupDescription").value = groupData.description || '';

            // Afficher la liste des membres
            const membersList = document.getElementById("groupMembersList");
            membersList.innerHTML = '<div class="text-center"><div class="spinner-border spinner-border-sm"></div></div>';

            // Charger les membres
            const membersHtml = await Promise.all(
                groupData.members.map(async (memberId) => {
                    const isAdmin = memberId === groupData.adminId;
                    const userDoc = await getDoc(doc(db, "users", memberId));
                    const userData = userDoc.exists() ? userDoc.data() : {};
                    const userName = userData.name || userData.email || 'Utilisateur';

                    return `
                <div class="list-group-item d-flex justify-content-between align-items-center">
                    <div>
                        <strong>${escapeHtml(userName)}</strong>
                        ${isAdmin ? '<span class="badge bg-success ms-2">Admin</span>' : ''}
                    </div>
                    ${!isAdmin && groupData.adminId === auth.currentUser.uid ? `
                        <button class="btn btn-sm btn-danger" onclick="removeMemberFromGroup('${groupId}', '${memberId}')">
                            <i class="bi bi-x-circle"></i> Retirer
                        </button>
                    ` : ''}
                </div>
            `;
                })
            );

            membersList.innerHTML = membersHtml.join('');
            modal.show();
        }

        // Sauvegarder les modifications
        document.getElementById("saveGroupSettingsBtn")?.addEventListener("click", async () => {
            const groupName = document.getElementById("settingsGroupName").value.trim();
            const groupDescription = document.getElementById("settingsGroupDescription").value.trim();

            if (!groupName) {
                showToast("Le nom du groupe est requis", "warning");
                return;
            }

            try {
                await updateDoc(doc(db, "groups", currentGroupId), {
                    name: groupName,
                    description: groupDescription
                });

                showToast("Paramètres mis à jour !", "success");
                bootstrap.Modal.getInstance(document.getElementById("groupSettingsModal")).hide();

                // Rafraîchir l'affichage
                viewGroupChat(currentGroupId);

            } catch (error) {
                console.error("Erreur:", error);
                showToast("Erreur: " + error.message, "danger");
            }
        });

        // Retour à la liste des groupes
        document.getElementById("backToGroupsList")?.addEventListener("click", () => {
            document.getElementById("groupChatView").classList.add("d-none");
            document.getElementById("groupsList").classList.remove("d-none");
            currentGroupId = null;

            if (unsubscribeGroupMessages) {
                unsubscribeGroupMessages();
                unsubscribeGroupMessages = null;
            }
        });

        console.log("✅ Système de groupes chargé avec succès !");

        //============== GROUPS LISTNERS ==============//
        // ============================================
        // 📝 CRÉATION DE GROUPE
        // ============================================

        document.getElementById("createGroupForm")?.addEventListener("submit", async (e) => {
            e.preventDefault();

            const user = auth.currentUser;
            if (!user) {
                showToast("Vous devez être connecté.", "warning");
                return;
            }

            const groupName = document.getElementById("groupName").value.trim();
            const groupDescription = document.getElementById("groupDescription").value.trim();

            if (!groupName) {
                showToast("Le nom du groupe est requis.", "warning");
                return;
            }

            try {
                console.log('📝 Creating new group:', groupName);

                // Créer le document du groupe
                const groupData = {
                    name: groupName,
                    description: groupDescription,
                    adminId: user.uid,
                    members: [user.uid],
                    memberNames: {
                        [user.uid]: user.displayName || user.email || "Anonyme"
                    },
                    createdAt: Timestamp.now(),
                    lastMessageContent: null,
                    lastMessageTime: null,
                    lastMessageSenderId: null,
                    avatarURL: null
                };

                const groupRef = await addDoc(collection(db, "groups"), groupData);
                console.log('✅ Group created with ID:', groupRef.id);

                // Premier message système
                await addDoc(collection(db, "groups", groupRef.id, "messages"), {
                    content: `🎉 ${user.displayName || 'Un utilisateur'} a créé ce groupe !`,
                    senderId: 'system',
                    senderName: 'Système',
                    createdAt: Timestamp.now(),
                    reactions: {},
                    isSystemMessage: true
                });

                showToast("Groupe créé avec succès !", "success");

                // Fermer le modal
                const modal = bootstrap.Modal.getInstance(document.getElementById("createGroupModal"));
                modal.hide();

                // Reset le formulaire
                document.getElementById("createGroupForm").reset();

                // Ouvrir le nouveau groupe
                setTimeout(() => {
                    viewGroupChat(groupRef.id);
                }, 500);

            } catch (error) {
                console.error("❌ Erreur création groupe:", error);
                showToast("Erreur: " + error.message, "danger");
            }
        });

        // ============================================
        // 🔍 RECHERCHE DE MEMBRES POUR INVITATION
        // ============================================

        const memberSearch = document.getElementById("memberSearch");
        const memberSearchResults = document.getElementById("memberSearchResults");
        const selectedMemberId = document.getElementById("selectedMemberId");
        const sendInviteBtn = document.getElementById("sendInviteBtn");

        let memberSearchTimeout = null;

        memberSearch?.addEventListener('input', (e) => {
            clearTimeout(memberSearchTimeout);
            const searchQuery = e.target.value.trim();

            if (searchQuery.length < 2) {
                memberSearchResults.style.display = 'none';
                return;
            }

            memberSearchTimeout = setTimeout(() => {
                searchMembersToInvite(searchQuery);
            }, 300);
        });

        async function searchMembersToInvite(searchQuery) {
            const user = auth.currentUser;
            if (!user) return;

            try {
                // Récupérer les membres actuels du groupe
                const groupRef = doc(db, "groups", currentGroupId);
                const groupSnap = await getDoc(groupRef);
                const currentMembers = groupSnap.exists() ? groupSnap.data().members : [];

                // Rechercher par nom
                const q1 = query(
                    collection(db, "users"),
                    where("name", ">=", searchQuery),
                    where("name", "<=", searchQuery + '\uf8ff'),
                    limit(5)
                );

                // Rechercher par email
                const q2 = query(
                    collection(db, "users"),
                    where("email", "==", searchQuery),
                    limit(5)
                );

                const [snap1, snap2] = await Promise.all([getDocs(q1), getDocs(q2)]);

                let results = [];
                const foundIds = new Set();

                // Combiner les résultats en excluant l'utilisateur actuel et les membres existants
                snap1.forEach(doc => {
                    if (doc.id !== user.uid && !currentMembers.includes(doc.id)) {
                        results.push({ id: doc.id, ...doc.data() });
                        foundIds.add(doc.id);
                    }
                });

                snap2.forEach(doc => {
                    if (doc.id !== user.uid && !currentMembers.includes(doc.id) && !foundIds.has(doc.id)) {
                        results.push({ id: doc.id, ...doc.data() });
                    }
                });

                renderMemberSearchResults(results);

            } catch (error) {
                console.error('Erreur recherche membres:', error);
                showToast('Erreur lors de la recherche', 'danger');
            }
        }


        function renderMemberSearchResults(results) {
            if (!memberSearchResults) return;

            memberSearchResults.innerHTML = '';

            if (results.length === 0) {
                memberSearchResults.innerHTML = `
            <div class="list-group-item disabled">
                <i class="bi bi-search me-2"></i>Aucun utilisateur trouvé
            </div>
        `;
                memberSearchResults.style.display = 'block';
                return;
            }

            results.forEach(user => {
                const item = document.createElement('button');
                item.type = 'button';
                item.className = 'list-group-item list-group-item-action search-result-item';

                const avatarHtml = user.photoURL
                    ? `<img src="${user.photoURL}" class="rounded-circle me-2" style="width: 32px; height: 32px; object-fit: cover;">`
                    : `<i class="bi bi-person-circle fs-4 me-2"></i>`;

                item.innerHTML = `
            <div class="d-flex align-items-center">
                ${avatarHtml}
                <div>
                    <strong>${escapeHtml(user.name || 'Utilisateur')}</strong>
                    <small class="text-muted d-block">${escapeHtml(user.email)}</small>
                </div>
            </div>
        `;

                item.onclick = () => selectMemberToInvite(user.id, user.name || user.email);
                memberSearchResults.appendChild(item);
            });

            memberSearchResults.style.display = 'block';
        }

        function selectMemberToInvite(userId, userName) {
            selectedMemberId.value = userId;
            memberSearch.value = userName;
            memberSearchResults.style.display = 'none';
            sendInviteBtn.disabled = false;

            // Afficher la confirmation
            document.getElementById("selectedMemberDisplay").classList.remove('d-none');
            document.getElementById("selectedMemberName").textContent = userName;
        }

        // Reset quand le modal se ferme
        document.getElementById("inviteMembersModal")?.addEventListener('hidden.bs.modal', () => {
            selectedMemberId.value = '';
            memberSearch.value = '';
            document.getElementById("invitationMessage").value = '';
            memberSearchResults.style.display = 'none';
            sendInviteBtn.disabled = true;
            document.getElementById("selectedMemberDisplay").classList.add('d-none');
        });

        // ============================================
        // 📤 ENVOYER UNE INVITATION DE GROUPE
        // ============================================

        document.getElementById("inviteMembersForm")?.addEventListener("submit", async (e) => {
            e.preventDefault();

            const user = auth.currentUser;
            const recipientId = selectedMemberId.value;
            const message = document.getElementById("invitationMessage").value.trim() || "Rejoignez notre groupe !";

            if (!user || !recipientId || !currentGroupId) {
                showToast("Informations manquantes.", "warning");
                return;
            }

            try {
                console.log('📤 Sending group invitation:', { recipientId, groupId: currentGroupId });

                // Récupérer les infos du groupe
                const groupRef = doc(db, "groups", currentGroupId);
                const groupSnap = await getDoc(groupRef);

                if (!groupSnap.exists()) {
                    throw new Error("Groupe introuvable.");
                }

                const groupData = groupSnap.data();

                // Vérifier que l'utilisateur n'est pas déjà membre
                if (groupData.members.includes(recipientId)) {
                    showToast("Cet utilisateur est déjà membre du groupe.", "info");
                    return;
                }

                // Vérifier s'il n'y a pas déjà une invitation en attente
                const existingInviteQ = query(
                    collection(db, "groupInvitations"),
                    where("groupId", "==", currentGroupId),
                    where("recipientId", "==", recipientId),
                    where("status", "==", "pending")
                );

                const existingInvites = await getDocs(existingInviteQ);
                if (!existingInvites.empty) {
                    showToast("Une invitation est déjà en attente pour cet utilisateur.", "info");
                    return;
                }

                // Récupérer les infos du destinataire
                const recipientDoc = await getDoc(doc(db, "users", recipientId));
                if (!recipientDoc.exists()) {
                    throw new Error("Utilisateur destinataire introuvable.");
                }

                const recipientData = recipientDoc.data();

                // Créer l'invitation
                const invitationData = {
                    groupId: currentGroupId,
                    groupName: groupData.name,
                    senderId: user.uid,
                    senderName: user.displayName || user.email || 'Anonyme',
                    recipientId: recipientId,
                    recipientName: recipientData.name || recipientData.email,
                    message: message,
                    status: 'pending',
                    createdAt: Timestamp.now()
                };

                await addDoc(collection(db, "groupInvitations"), invitationData);
                console.log('✅ Group invitation sent!');

                // Notifier le destinataire
                if (typeof triggerNotificationEvent === "function") {
                    await triggerNotificationEvent(recipientId, {
                        message: `<strong>${user.displayName || 'Un utilisateur'}</strong> vous invite à rejoindre le groupe <strong>${groupData.name}</strong>`,
                        type: "group_invitation",
                        link: "/groups"
                    });
                }

                showToast("Invitation envoyée avec succès !", "success");

                // Fermer le modal
                const modal = bootstrap.Modal.getInstance(document.getElementById("inviteMembersModal"));
                modal.hide();

            } catch (error) {
                console.error("❌ Erreur envoi invitation:", error);
                showToast("Erreur: " + error.message, "danger");
            }
        });

        // ============================================
        // 🗑️ RETIRER UN MEMBRE DU GROUPE (ADMIN)
        // ============================================

        window.removeMemberFromGroup = async function (groupId, memberId) {
            if (!confirm("Voulez-vous vraiment retirer ce membre du groupe ?")) {
                return;
            }

            const user = auth.currentUser;
            if (!user) return;

            try {
                const groupRef = doc(db, "groups", groupId);
                const groupSnap = await getDoc(groupRef);

                if (!groupSnap.exists()) {
                    throw new Error("Groupe introuvable.");
                }

                const groupData = groupSnap.data();

                // Vérifier que l'utilisateur est admin
                if (groupData.adminId !== user.uid) {
                    throw new Error("Seul l'administrateur peut retirer des membres.");
                }

                // Retirer le membre
                const updatedMembers = groupData.members.filter(id => id !== memberId);
                const updatedMemberNames = { ...groupData.memberNames };
                delete updatedMemberNames[memberId];

                await updateDoc(groupRef, {
                    members: updatedMembers,
                    memberNames: updatedMemberNames
                });

                // Message système
                await addDoc(collection(db, "groups", groupId, "messages"), {
                    content: `👋 ${groupData.memberNames[memberId] || 'Un membre'} a été retiré du groupe`,
                    senderId: 'system',
                    senderName: 'Système',
                    createdAt: Timestamp.now(),
                    reactions: {},
                    isSystemMessage: true
                });

                showToast("Membre retiré du groupe.", "success");

                // Rafraîchir l'affichage
                openGroupSettings(groupId);

                // Notifier le membre retiré
                if (typeof triggerNotificationEvent === "function") {
                    await triggerNotificationEvent(memberId, {
                        message: `Vous avez été retiré du groupe <strong>${groupData.name}</strong>`,
                        type: "group_removed",
                        link: "/groups"
                    });
                }

            } catch (error) {
                console.error("❌ Erreur:", error);
                showToast("Erreur: " + error.message, "danger");
            }
        };


        // ============================================
        // 🚪 QUITTER UN GROUPE (MEMBRE)
        // ============================================

        window.leaveGroup = async function (groupId) {
            if (!confirm("Voulez-vous vraiment quitter ce groupe ?")) {
                return;
            }

            const user = auth.currentUser;
            if (!user) return;

            try {
                const groupRef = doc(db, "groups", groupId);
                const groupSnap = await getDoc(groupRef);

                if (!groupSnap.exists()) {
                    throw new Error("Groupe introuvable.");
                }

                const groupData = groupSnap.data();

                // L'admin ne peut pas quitter (il doit d'abord transférer ou supprimer)
                if (groupData.adminId === user.uid) {
                    showToast("En tant qu'admin, vous devez transférer l'administration ou supprimer le groupe.", "warning");
                    return;
                }

                // Retirer l'utilisateur
                const updatedMembers = groupData.members.filter(id => id !== user.uid);
                const updatedMemberNames = { ...groupData.memberNames };
                delete updatedMemberNames[user.uid];

                await updateDoc(groupRef, {
                    members: updatedMembers,
                    memberNames: updatedMemberNames
                });

                // Message système
                await addDoc(collection(db, "groups", groupId, "messages"), {
                    content: `👋 ${user.displayName || 'Un membre'} a quitté le groupe`,
                    senderId: 'system',
                    senderName: 'Système',
                    createdAt: Timestamp.now(),
                    reactions: {},
                    isSystemMessage: true
                });

                showToast("Vous avez quitté le groupe.", "success");

                // Retour à la liste
                document.getElementById("groupChatView").classList.add("d-none");
                document.getElementById("groupsList").classList.remove("d-none");

            } catch (error) {
                console.error("❌ Erreur:", error);
                showToast("Erreur: " + error.message, "danger");
            }
        };

        // ============================================
        // 🗑️ SUPPRIMER UN GROUPE (ADMIN SEULEMENT)
        // ============================================

        window.deleteGroup = async function (groupId) {
            const confirmation = prompt('Pour supprimer ce groupe, tapez "SUPPRIMER" :');

            if (confirmation !== 'SUPPRIMER') {
                return;
            }

            const user = auth.currentUser;
            if (!user) return;

            try {
                const groupRef = doc(db, "groups", groupId);
                const groupSnap = await getDoc(groupRef);

                if (!groupSnap.exists()) {
                    throw new Error("Groupe introuvable.");
                }

                const groupData = groupSnap.data();

                // Vérifier que l'utilisateur est admin
                if (groupData.adminId !== user.uid) {
                    throw new Error("Seul l'administrateur peut supprimer le groupe.");
                }

                // Supprimer tous les messages
                const messagesQuery = query(collection(db, "groups", groupId, "messages"));
                const messagesSnap = await getDocs(messagesQuery);

                const deletePromises = messagesSnap.docs.map(doc => deleteDoc(doc.ref));
                await Promise.all(deletePromises);

                // Supprimer le groupe
                await deleteDoc(groupRef);

                showToast("Groupe supprimé avec succès.", "success");

                // Retour à la liste
                document.getElementById("groupChatView").classList.add("d-none");
                document.getElementById("groupsList").classList.remove("d-none");

                // Notifier les membres
                if (typeof triggerNotificationEvent === "function") {
                    groupData.members.forEach(memberId => {
                        if (memberId !== user.uid) {
                            triggerNotificationEvent(memberId, {
                                message: `Le groupe <strong>${groupData.name}</strong> a été supprimé`,
                                type: "group_deleted",
                                link: "/groups"
                            });
                        }
                    });
                }

            } catch (error) {
                console.error("❌ Erreur:", error);
                showToast("Erreur: " + error.message, "danger");
            }
        };

        console.log("✅ Système de création et d'invitation de groupes chargé !");

        // ============================================
        //=========== Progress ========================

        async function renderProgress() {
            const user = auth.currentUser;
            const progressView = document.getElementById("progressView");

            // Destroy previous chart instances to prevent memory leaks
            if (progressDonutChart) progressDonutChart.destroy();
            if (progressByCourseChart) progressByCourseChart.destroy();
            if (activityLineChart) activityLineChart.destroy();

            if (!user) {
                progressView.innerHTML =
                    '<div class="text-center text-muted p-5"><i class="bi bi-lock fs-1"></i><p class="mt-2">Veuillez vous connecter pour voir votre progression.</p></div>';
                return;
            }

            // --- DATA PREPARATION ---
            const completed = Object.values(userProgress).filter(
                (p) => p === 100
            ).length;
            const inProgress = Object.values(userProgress).filter(
                (p) => p > 0 && p < 100
            ).length;
            const notStarted = allFiles.length - completed - inProgress;

            // Update KPIs
            document.getElementById("kpiCompleted").textContent = completed;
            document.getElementById("kpiInProgress").textContent = inProgress;

            // Data for the Bar Chart (only show courses with progress > 0)
            const coursesWithProgress = allFiles
                .map((file) => ({
                    name: file.name,
                    progress: userProgress[file.id] || 0,
                }))
                .filter((course) => course.progress > 0)
                .sort((a, b) => a.progress - b.progress);

            // --- CHART.JS GLOBAL CONFIG ---
            // Use theme variables for chart colors and fonts
            const style = getComputedStyle(document.body);
            const brandColor = style.getPropertyValue("--brand").trim();
            const accentColor = style.getPropertyValue("--accent").trim();
            const successColor = style.getPropertyValue("--success").trim();
            const warningColor = style.getPropertyValue("--warning").trim();
            const dangerColor = style.getPropertyValue("--danger").trim();
            const textColor = style.getPropertyValue("--text").trim();
            const gridColor = style.getPropertyValue("--border").trim();

            Chart.defaults.color = textColor;
            Chart.defaults.font.family = "'Inter', sans-serif";
            Chart.defaults.plugins.legend.position = "bottom";

            // --- 1. OVERALL PROGRESS DONUT CHART ---
            const donutCtx = document
                .getElementById("progressDonutChart")
                .getContext("2d");
            progressDonutChart = new Chart(donutCtx, {
                type: "doughnut",
                data: {
                    labels: ["Terminés", "En cours", "Non commencés"],
                    datasets: [
                        {
                            data: [completed, inProgress, notStarted],
                            backgroundColor: [successColor, warningColor, dangerColor],
                            borderColor: style.getPropertyValue("--surface").trim(),
                            borderWidth: 4,
                            hoverOffset: 8,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    cutout: "70%",
                    plugins: {
                        legend: { display: true },
                        tooltip: {
                            callbacks: {
                                label: (context) => `${context.label}: ${context.raw} cours`,
                            },
                        },
                    },
                },
            });

            // --- 2. PROGRESS BY COURSE BAR CHART ---
            const barCtx = document
                .getElementById("progressByCourseChart")
                .getContext("2d");
            progressByCourseChart = new Chart(barCtx, {
                type: "bar",
                data: {
                    labels: coursesWithProgress.map(
                        (c) => c.name.substring(0, 30) + (c.name.length > 30 ? "..." : "")
                    ),
                    datasets: [
                        {
                            label: "Progression (%)",
                            data: coursesWithProgress.map((c) => c.progress),
                            backgroundColor: brandColor,
                            borderRadius: 4,
                        },
                    ],
                },
                options: {
                    indexAxis: "y", // Horizontal bars
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            beginAtZero: true,
                            max: 100,
                            grid: { color: gridColor },
                        },
                        y: {
                            grid: { display: false },
                        },
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: (context) => `${context.raw}%`,
                            },
                        },
                    },
                },
            });

            // --- 3. RECENT ACTIVITY LINE CHART ---
            // NOTE: This uses randomly generated data for demonstration.
            // A real implementation would require storing timestamps of user actions.
            const lineCtx = document
                .getElementById("activityLineChart")
                .getContext("2d");
            const activityLabels = Array.from({ length: 7 }, (_, i) => {
                const d = new Date();
                d.setDate(d.getDate() - i);
                return d.toLocaleDateString("fr-FR", {
                    weekday: "short",
                    day: "numeric",
                });
            }).reverse();

            const gradient = lineCtx.createLinearGradient(0, 0, 0, 250);
            gradient.addColorStop(0, `${accentColor}80`); // 50% opacity
            gradient.addColorStop(1, `${accentColor}00`); // 0% opacity

            activityLineChart = new Chart(lineCtx, {
                type: "line",
                data: {
                    labels: activityLabels,
                    datasets: [
                        {
                            label: "Actions complétées",
                            data: Array.from({ length: 7 }, () =>
                                Math.floor(Math.random() * 5)
                            ), // FAKE DATA
                            fill: true,
                            backgroundColor: gradient,
                            borderColor: accentColor,
                            tension: 0.4, // Makes the line smooth
                            pointBackgroundColor: accentColor,
                            pointBorderColor: style.getPropertyValue("--surface").trim(),
                            pointHoverRadius: 7,
                            pointRadius: 5,
                        },
                    ],
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        y: {
                            beginAtZero: true,
                            grid: { color: gridColor },
                            ticks: {
                                precision: 0, // Only show whole numbers
                            },
                        },
                        x: {
                            grid: { display: false },
                        },
                    },
                    plugins: {
                        legend: { display: false },
                    },
                },
            });
        }

        // START: NEW FUNCTION FOR SETTINGS VIEW
        function renderSettings() {
            const user = auth.currentUser;
            const settingsWrapper = document.getElementById(
                "accountSettingsWrapper"
            );
            const passwordCard = document.getElementById('passwordSettingsCard');

            const photoPreview = document.getElementById('profilePhotoPreview');
            const btnRemove = document.getElementById('btnRemovePhoto');
            const photoUrlInput = document.getElementById('photoUrlInput'); // NOUVEAU INPUT
            if (user) {
                settingsWrapper.style.display = "block";
                document.getElementById("accountName").value = user.displayName || "";
                document.getElementById("accountEmail").value = user.email || "";

                const photoURL = user.photoURL || '';
                photoUrlInput.value = photoURL;

                // Afficher la photo de profil (avec fallback vers UI Avatars)
                const userPhotoUrl = photoURL || `https://ui-avatars.com/api/?name=${encodeURIComponent(user.displayName || user.email)}`;
                photoPreview.src = userPhotoUrl;


                // Afficher le bouton de suppression uniquement si une photo personnalisée existe
                if (user.photoURL && !user.photoURL.includes('ui-avatars.com')) {
                    btnRemove.classList.remove('d-none');
                } else {
                    btnRemove.classList.add('d-none');
                }
                // Check if user signed up with email/password
                const isPasswordProvider = user.providerData.some(
                    (provider) => provider.providerId === "password"
                );

                if (isPasswordProvider) {
                    passwordCard.style.display = "block";
                } else {
                    passwordCard.style.display = "none";
                }
            } else {
                // Hide settings if no user is logged in
                settingsWrapper.style.display = "none";
            }
        }

        // END: NEW FUNCTION

        function updateStats() {
            const total = allFiles.length;
            const completed = Object.values(userProgress).filter(
                (p) => p === 100
            ).length;
            const inProgress = Object.values(userProgress).filter(
                (p) => p > 0 && p < 100
            ).length;

            document.getElementById("totalCourses").innerText = total;
            document.getElementById("completedCourses").innerText = completed;
            document.getElementById("inProgressCourses").innerText = inProgress;

        }


        function filterCourses(query) {
            const cards = document.querySelectorAll(
                "#coursesGrid .col-xl-3, #coursesGrid .col-lg-4, #coursesGrid .col-md-6"
            );
            cards.forEach((card) => {
                const title =
                    card.querySelector(".card-title")?.innerText.toLowerCase() || "";
                card.style.display = title.includes(query) ? "" : "none";
            });
        }

        function showToast(message, type = "info") {
            const toastContainer = document.getElementById("toastContainer");

            const icons = {
                success: "bi-check-circle-fill",
                danger: "bi-exclamation-triangle-fill",
                warning: "bi-exclamation-triangle-fill",
                info: "bi-info-circle-fill",
            };
            const icon = icons[type] || icons.info;

            // Create the wrapper for Bootstrap's Toast component
            const toastEl = document.createElement("div");
            toastEl.className = `toast custom-toast alert-${type}`; // Use 'toast'

            toastEl.setAttribute("role", "alert");
            toastEl.setAttribute("aria-live", "assertive");
            toastEl.setAttribute("aria-atomic", "true");

            toastEl.innerHTML = `
            <div class="d-flex">
                <div class="toast-body d-flex align-items-center">
                    <i class="bi ${icon} me-2 fs-5"></i>
                    <span class="fw-semibold me-auto">${message}</span>
                </div>
                <button type="button" class="btn-close me-2 m-auto"
                    data-bs-dismiss="toast" aria-label="Close"></button>
            </div>
            `;

            toastContainer.appendChild(toastEl);

            // Create a new Bootstrap Toast instance
            const bsToast = new bootstrap.Toast(toastEl, {
                delay: 5000, // Auto-hide after 5 seconds
                autohide: true,
            });

            // When the toast is hidden, remove it from the DOM to prevent clutter
            toastEl.addEventListener("hidden.bs.toast", () => {
                toastEl.remove();
            });

            // Show the toast!
            bsToast.show();
        }

        // Fonctions globales
        window.playVideo = function (fileId, title, url) {
            document.getElementById("videoTitle").innerText = escapeHtml(title);
            const container = document.getElementById("videoContainer");

            const videoId = extractVideoId(url);
            if (videoId) {
                // Source YouTube
                container.innerHTML = `<iframe src="https://www.youtube.com/embed/${videoId}?autoplay=1"
            frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>`;
                playlistPanel.classList.remove("d-none"); // Afficher l'historique pour YouTube
            } else if (fileId) {
                // Source Google Drive (Nécessite des permissions publiques ou token)
                container.innerHTML = `<iframe src="https://drive.google.com/file/d/${fileId}/preview"
            frameborder="0" allowfullscreen></iframe>`;
                playlistPanel.classList.add("d-none");
            } else {
                container.innerHTML = `<div class="p-5 text-center text-muted"><i class="bi bi-exclamation-triangle fs-1"></i>
            <p class="mt-2">Vidéo non disponible (Lien manquant).</p></div>`;
                playlistPanel.classList.add("d-none");
            }

            videoModal.show();

            // Enregistrer la progression au démarrage (1% pour marquer comme commencé)
            if ((userProgress[fileId] || 0) === 0) {
                saveUserProgress(fileId, 1);
            }
        };

        window.playYoutube = async function (type, id, title) {
            const container = document.getElementById("videoContainer");
            container.innerHTML =
                `<div class="d-flex h-100 align-items-center justify-content-center">
                < div class="loader" ></div >
            </div > `;

            // The side panel is now ALWAYS the history panel
            playlistPanel.classList.remove("d-none");
            playlistPanel.classList.add("d-flex");
            renderVideoHistory();

            let videoIdToPlay = id;

            if (type === "playlist") {
                // For a playlist, we fetch the *first* video's ID to start playing
                try {
                    const url =
                        `https://www.googleapis.com/youtube/v3/playlistItems?part=snippet&maxResults=1&playlistId=${id}&key=${YOUTUBE_API_KEY}`;
                    const res = await fetch(url);
                    const data = await res.json();
                    if (data.items && data.items.length > 0) {
                        videoIdToPlay = data.items[0].snippet.resourceId.videoId;
                        // We could fetch the whole playlist and let the user navigate via

                    }
                } catch (err) {
                    console.error("Could not fetch first video of playlist:", err);
                    showToast("Impossible de charger la playlist.", "danger");
                    return;
                }
                // For playlists, we now just embed the whole list and let YouTube

                container.innerHTML = `<iframe
                src="https://www.youtube.com/embed/videoseries?list=${id}&autoplay=1"
                frameborder="0"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                allowfullscreen></iframe>`;
            } else {
                // For a single video, we add it to our history
                const videoData = {
                    videoId: id,
                    title: title,
                    thumbnailUrl: `https://img.youtube.com/vi/${id}/default.jpg`,
                };
                addVideoToHistory(videoData);
                container.innerHTML = `<iframe
                src="https://www.youtube.com/embed/${id}?autoplay=1" frameborder="0"
                allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                allowfullscreen></iframe>`;
            }

            document.getElementById("videoTitle").innerText = title;
            videoModal.show();
        };

        window.viewDocument = function (fileId, title) {
            document.getElementById("documentTitle").innerText = escapeHtml(title);
            const container = document.getElementById("documentContainer");

            // Si Drive bloque, l'utilisateur verra un message d'erreur ici.
            container.innerHTML = `<iframe src="https://drive.google.com/file/d/${fileId}/preview" frameborder="0"></iframe>`;

            documentModal.show();

            if ((userProgress[fileId] || 0) === 0) {
                saveUserProgress(fileId, 1);
            }
        };

        window.markComplete = function (fileId) {
            saveUserProgress(fileId, 100);
            renderCourses();
            renderDashboard();
            showToast("Cours marqué comme complété !", "success");
        };

        window.resumeCourse = function (fileId) {
            const file = allFiles.find((f) => f.id === fileId);
            if (!file) return;

            const meta = getFileMeta(file.mimeType);
            if (meta.kind === "video") {
                playVideo(file.id, file.name, file.webViewLink);
            } else {
                viewDocument(file.id, file.name, file.webViewLink, meta.kind);
            }

            const currentProgress = userProgress[fileId] || 0;
            if (currentProgress < 100) {
                saveUserProgress(fileId, Math.min(currentProgress + 25, 100));
            }
        };
        window.saveForLater = function (fileId) {
            const
                saved = JSON.parse(localStorage.getItem("savedCourses") || "[]"); if
                (!saved.includes(fileId)) {
                saved.push(fileId);
                localStorage.setItem("savedCourses", JSON.stringify(saved));
                showToast("Enregistré pour plus tard !", "info");
            }
        };

        /*window.openFolder = function (folderId, name) {
            if (!folderId) {
                showToast("ID de dossier invalide.", "danger");
                return;
            }
            folderPath.push({ id: folderId, name: name });
            currentFolderId = folderId;
            fetchDriveFolder(folderId);
        };*/

        window.openFolder = function (folderId, folderName) {
            folderPath.push({ id: folderId, name: folderName });
            currentFolderId = folderId;
            fetchDriveFolder(folderId);
        };

        document.getElementById('addContentForm')?.addEventListener('submit',
            async (e) => {
                e.preventDefault();
                const user = auth.currentUser;
                if (!user) {
                    showToast("Veuillez vous connecter pour contribuer.", "warning");
                    return;
                }

                const url = document.getElementById('contentUrl').value.trim();
                const type = document.getElementById('contentType').value;
                const title = document.getElementById('contentTitle').value.trim();
                const courseId = document.getElementById('contentCourse').value;

                let contentData = {
                    title: title || (type === 'link' ? url.substring(0, 50) + '...' :
                        ''),
                    url: url,
                    courseId: courseId || null, // Assurez-vous que c'est null si non
                    type: type,
                    userId: user.uid, // FIX CRITIQUE: Ajout du userId pour les règles
                    userName: user.displayName || 'Anonyme',
                    createdAt: Timestamp.now()
                };

                // Ajout des données de l'auteur pour un rendu immédiat
                contentData.authorPhotoURL = user.photoURL || null;
                contentData.isByAdmin = isAdmin;

                try {
                    if (type === 'youtube') {
                        const isPlaylist = url.includes('list=');
                        const id = isPlaylist ? extractPlaylistId(url) :
                            extractVideoId(url);
                        if (!id) throw new Error("URL YouTube invalide.");
                        contentData.youtubeType = isPlaylist ? 'playlist' : 'video';
                        contentData.id = id;
                        contentData.resourceId = id;
                        contentData.youtubeId = id; // Consistance
                    }
                    else if (type === 'gdrive_doc' || type === 'gdrive_video') {
                        const id = extractGoogleDriveId(url);
                        if (!id || id.length < 20) throw new Error("URL Google Driveinvalide ou ID non détecté."); contentData.gdriveId = id;
                        contentData.resourceId = id;
                    } else if (type === 'link') {
                        if
                            (!url.startsWith('http')) throw new Error("URL Web invalide.Doit commencer par http(s).");
                        contentData.resourceId = url;
                    }

                    else { throw new Error("Type de contenu inconnu."); }
                    addDoc(collection(db, 'contributed'), contentData);
                    showToast('Contenu ajouté avec succès !', 'success');
                    e.target.reset(); // Recharger la vue pour voir le nouveau
                    loadContributedContent();
                } catch (err) {


                    showToast('Erreur de soumission: ' + err.message, ' danger'); console.error("Erreur desoumission de contenu: ", err);
                }
            }); // Mettre à jour l'écouteurdu formulaire de paramètres de profil(ProfileSettingsForm)
        document.getElementById('profileSettingsForm')?.addEventListener('submit',
            async (e) => {
                e.preventDefault();
                const user = auth.currentUser;
                if (!user) return;

                const newName =
                    document.getElementById('accountName').value.trim();
                let newPhotoURL =
                    document.getElementById('photoUrlInput').value.trim();

                // 1. Validation de l'URL de la photo
                if (newPhotoURL && !newPhotoURL.startsWith('http')) {
                    showToast("Veuillez utiliser une URL HTTPS valide (commençant par http ou https).", 'warning');
                    return;
                }
                if (newPhotoURL === "") {
                    newPhotoURL = null;
                }

                const updates = {};
                let changed = false;

                if (newName !== user.displayName) {
                    updates.displayName = newName;
                    changed = true;
                }

                if (newPhotoURL !== user.photoURL) {
                    updates.photoURL = newPhotoURL;
                    changed = true;
                }

                try {
                    if (changed) {
                        await updateProfile(user, updates);


                        updateProfileUI(updates.photoURL === undefined ? user.photoURL :
                            updates.photoURL);

                        showToast('Profil mis à jour !', 'success');
                        renderSettings(); // Re-render les settings pour la cohérence
                    } else {
                        showToast('Aucune modification détectée.', 'info');
                    }

                } catch (error) {
                    showToast('Erreur lors de la mise à jour du profil.', 'danger');
                    console.error('Profile update failed:', error);
                }
            });
        // Filtre catégorie
        document
            .getElementById("categoryFilter")
            ?.addEventListener("change", (e) => {
                const value = e.target.value;
                const cards = document.querySelectorAll("#coursesGrid > div");

                cards.forEach((card) => {
                    if (value === "all") {
                        card.style.display = "";
                    } else {
                        const badge =
                            card.querySelector(".course-badge")?.innerText.toLowerCase() ||
                            "";
                        card.style.display = badge.includes(value) ? "" : "none";
                    }
                });
            });

        // Tri
        document.getElementById("sortBy")?.addEventListener("change",
            (e) => {
                const value = e.target.value;
                if (value === "Trier par nom") {
                    currentFiles.sort((a, b) => a.name.localeCompare(b.name));
                } else if (value === "Trier par date") {
                    currentFiles.sort(
                        (a, b) => new Date(b.modifiedTime) - new Date(a.modifiedTime)
                    );
                } else if (value === "Trier par type") {
                    currentFiles.sort((a, b) =>
                        a.mimeType.localeCompare(b.mimeType));
                }
                renderCourses();
            });

        function listenForNotifications(userId) {
            if (unsubscribeNotifications) unsubscribeNotifications();

            const notifQuery = query(
                collection(db, "users", userId, "notifications"),
                orderBy("createdAt", "desc")
            );

            unsubscribeNotifications = onSnapshot(notifQuery, (snapshot) => {
                const notifications = snapshot.docs.map((doc) => ({
                    id: doc.id,
                    ...doc.data(),
                }));
                console.log("Real-time notifications received:",
                    notifications);
                updateNotificationUI(notifications);
            });
        }

        function updateNotificationUI(notifications) {
            const notifCountBadge =
                document.getElementById("notifCount");
            const notifListContainer =
                document.getElementById("notifListContainer");

            const unreadCount = notifications.filter((n) =>
                !n.read).length;

            // Update the bell badge
            if (unreadCount > 0) {
                notifCountBadge.textContent = unreadCount;
                notifCountBadge.classList.remove("d-none");
            } else {
                notifCountBadge.classList.add("d-none");
            }

            // Update the dropdown list
            notifListContainer.innerHTML = "";
            if (notifications.length === 0) {
                notifListContainer.innerHTML =
                    `<div class="text-center text-muted p-4">Aucune notification
                                                            </div > `;
                return;
            }

            // Show the latest 5 notifications in the dropdown
            notifications.slice(0, 5).forEach((notif) => {
                const itemEl = document.createElement("a");
                itemEl.href = "#";
                itemEl.className = `list-group-item notification-item
            ${notif.read ? "" : "unread"
                    }`;
                itemEl.onclick = (e) => {
                    e.preventDefault();
                    handleNotificationClick(notif);
                };

                const icon = getNotificationIcon(notif.type);

                itemEl.innerHTML = `
            <div class="icon" style="color: ${icon.color};">${icon.html}
            </div>
            <div class="content flex-grow-1">
                ${notif.message}
                <div class="timestamp">${timeAgo(
                    notif.createdAt.toDate()
                )}</div>
            </div>
            `;
                notifListContainer.appendChild(itemEl);
            });
        }

        function getNotificationIcon(type) {
            switch (type) {
                case "new_reply":
                    return {
                        html: '<i class="bi bi-chat-dots-fill"></i>',
                        color: "var(--info)",
                    };
                case "new_content":
                    return {
                        html: '<i class="bi bi-cloud-arrow-up-fill"></i>',
                        color: "var(--success)",
                    };
                case "assignment_due":
                    return {
                        html: '<i class="bi bi-exclamation-triangle-fill"></i>',
                        color: "var(--warning)",
                    };
                default:
                    return {
                        html: '<i class="bi bi-info-circle-fill"></i>',
                        color: "var(--muted)",
                    };
            }
        }

        // --- FONCTION UTILITAIRE POUR METTRE À JOUR LE PROFIL
        GLOBALEMENT-- -
            function updateProfileUI(url) {
                const user = auth.currentUser;
                if (!user) return;

                // 1. Mise à jour de l'objet utilisateur Firebase
                updateProfile(user, { photoURL: url })
                    .then(() => {
                        // 2. Mise à jour des éléments DOM
                        const newUrl = url ||
                            `https://ui-avatars.com/api/?name=${encodeURIComponent(user.displayName
                                || user.email)}`;
                        document.getElementById('userPhoto').src = newUrl;
                        document.getElementById('profilePhotoPreview').src = newUrl;

                        document.getElementById('photoUrlInput').value = url || '';

                        showToast('Profil mis à jour !', 'success');
                    })
                    .catch(error => {
                        showToast('Erreur lors de la mise à jour du profil.',
                            'danger');
                        console.error('Update profile error:', error);
                    });
            }

        // --- ÉCOUTEURS D'UPLOAD ET DE SUPPRESSION ---

        document.getElementById('photoUploadInput')?.addEventListener('change',
            async (e) => {
                const user = auth.currentUser;
                const file = e.target.files[0];
                if (!user || !file) return;

                if (file.size > 2 * 1024 * 1024) { // Max 2MB
                    showToast("La taille du fichier ne doit pas dépasser 2 Mo.",
                        'warning');
                    return;
                }

                // Afficher un aperçu local pendant le téléchargement
                const reader = new FileReader();
                reader.onload = (e) => {
                    document.getElementById('profilePhotoPreview').src =
                        e.target.result;
                };
                reader.readAsDataURL(file);

                showToast("Téléchargement de l'image en cours...", 'info');

                try {

                    const photoRef = ref(storage, `profile_photos/${user.uid}`);

                    // 2. Télécharger le fichier
                    await uploadBytes(photoRef, file);

                    // 3. Obtenir l'URL publique
                    const downloadURL = await getDownloadURL(photoRef);

                    // 4. Mettre à jour l'utilisateur Firebase avec la nouvelle
                    // URL
                    await updateProfileUI(downloadURL); // ATTENDRE

                } catch (error) {
                    showToast('Échec du téléchargement de la photo: ' +
                        error.message, 'danger');
                    console.error('Photo upload error:', error);
                    // Revenir à la photo précédente en cas d'erreur
                    renderSettings();
                }
            });

        document.getElementById('btnRemovePhoto')?.addEventListener('click',
            async () => {
                const user = auth.currentUser;
                if (!user || !user.photoURL ||
                    user.photoURL.includes('ui-avatars.com')) return;

                if (!confirm("Voulez-vous vraiment supprimer votre photo deprofil ? ")) return;

                try {
                    // 1. Supprimer l'image du Storage
                    const photoRef = ref(storage, `profile_photos/${user.uid}`);
                    await deleteObject(photoRef);

                    // 2. Mettre à jour l'utilisateur pour supprimer l'URL de la
                    await updateProfileUI(null); // 'null' déclenche le fallback vers
                    ui - avatars

                    showToast('Photo supprimée avec succès.', 'info');

                } catch (error) {

                    if (error.code !== 'storage/object-not-found') {
                        showToast('Erreur lors de la suppression de la photo: ' +
                            error.message, 'danger');
                        console.error('Photo deletion error:', error);
                    }

                    await updateProfileUI(null);
                }
            });



        async function handleNotificationClick(notification) {
            const user = auth.currentUser;
            if (!user) return;

            // Mark as read in Firestore
            if (!notification.read) {
                const notifRef = doc(
                    db,
                    "users",
                    user.uid,
                    "notifications",
                    notification.id
                );
                await updateDoc(notifRef, { read: true });
            }

            // TODO: Navigate to the relevant page based on
            notification.link
            if (notification.link) {
                // e.g., if link is '/discussions/threadId123', parse and
                navigate
                console.log("Navigate to:", notification.link);
                showToast(`Navigation vers: ${notification.link}`, "info");
            }
        }

        document
            .getElementById("markAllAsReadBtn")
            .addEventListener("click", async () => {
                const user = auth.currentUser;
                if (!user) return;

                const notifQuery = query(
                    collection(db, "users", user.uid, "notifications"),
                    where("read", "==", false)
                );
                const snapshot = await getDocs(notifQuery);

                // Use a batch write for efficiency
                const batch = writeBatch(db);
                snapshot.docs.forEach((doc) => {
                    batch.update(doc.ref, { read: true });
                });
                await batch.commit();

                showToast(
                    "Toutes les notifications ont été marquées comme lues.",
                    "success"
                );
            });

        /* ============================================================================
   EDUCATION MEDIA VIEW - COMPLETE JAVASCRIPT LOGIC
   Advanced TMDB Integration with Enhanced Features
   ============================================================================ */

        // ============================================================================
        // CONFIGURATION & CONSTANTS
        // ============================================================================

        const TMDB_CONFIG = {
            API_KEY: '6f66b7643f2f68bc93087a25591ca78a',
            BASE_URL: 'https://api.themoviedb.org/3',
            IMAGE_URL: 'https://image.tmdb.org/t/p/',
            LANGUAGE: 'en-USA',
            CACHE_DURATION: 5 * 60 * 1000, // 5 minutes
        };

        // Enhanced Genre Mapping with Educational Focus
        const SUBJECT_GENRES = {
            history: {
                ids: [36, 10752, 99],
                name: 'Histoire',
                icon: '📜',
                description: 'Films historiques et documentaires'
            },
            science: {
                ids: [878, 99],
                name: 'Sciences',
                icon: '🔬',
                description: 'Science-fiction et documentaires scientifiques'
            },
            lang: {
                ids: [10769, 18],
                name: 'Langues',
                icon: '🌍',
                description: 'Contenus pour l\'apprentissage des langues'
            },
            tech: {
                ids: [878, 9648],
                name: 'Technologie',
                icon: '💻',
                description: 'Innovation et technologie'
            },
            art: {
                ids: [10402, 18],
                name: 'Arts',
                icon: '🎨',
                description: 'Arts visuels et créativité'
            },
            nature: {
                ids: [99, 10751],
                name: 'Nature',
                icon: '🌿',
                description: 'Environnement et nature'
            }
        };

        const GENRE_MAP = {
            28: 'Action', 12: 'Aventure', 16: 'Animation', 35: 'Comédie',
            80: 'Crime', 99: 'Documentaire', 18: 'Drame', 10751: 'Famille',
            14: 'Fantastique', 36: 'Histoire', 27: 'Horreur', 10402: 'Musique',
            9648: 'Mystère', 10749: 'Romance', 878: 'Science-Fiction',
            10770: 'Téléfilm', 53: 'Thriller', 10752: 'Guerre', 37: 'Western'
        };

        // ============================================================================
        // STATE MANAGEMENT
        // ============================================================================

        let eduMediaState = {
            currentPage: 1,
            totalPages: 1,
            currentFilter: '',
            currentSort: 'popularity',
            currentSearch: '',
            currentView: 'grid',
            allMedia: [],
            filteredMedia: [],
            cache: new Map(),
            watchlist: [],
            favorites: []
        };

        // ============================================================================
        // INITIALIZATION
        // ============================================================================

        function initEduMedia() {
            console.log('🎬 Initializing Education Media...');

            // Load saved preferences
            loadUserPreferences();

            // Setup all event listeners
            setupEventListeners();

            // Initial render
            renderEduMedia();

            // Update UI elements
            updateStatsMedia();
            updateLastUpdatedTime();

            console.log('✅ Education Media initialized successfully');
        }

        function loadUserPreferences() {
            try {
                const saved = localStorage.getItem('eduMediaPreferences');
                if (saved) {
                    const prefs = JSON.parse(saved);
                    eduMediaState.currentView = prefs.view || 'grid';
                    eduMediaState.currentSort = prefs.sort || 'popularity';
                    eduMediaState.watchlist = prefs.watchlist || [];
                    eduMediaState.favorites = prefs.favorites || [];
                }
            } catch (error) {
                console.warn('Could not load preferences:', error);
            }
        }

        function saveUserPreferences() {
            try {
                const prefs = {
                    view: eduMediaState.currentView,
                    sort: eduMediaState.currentSort,
                    watchlist: eduMediaState.watchlist,
                    favorites: eduMediaState.favorites
                };
                localStorage.setItem('eduMediaPreferences', JSON.stringify(prefs));
            } catch (error) {
                console.warn('Could not save preferences:', error);
            }
        }

        // ============================================================================
        // EVENT LISTENERS SETUP
        // ============================================================================

        function setupEventListeners() {
            // Filter dropdown
            const filterEl = document.getElementById('eduMediaFilter');
            if (filterEl) {
                filterEl.addEventListener('change', handleFilterChange);
            }

            // Sort dropdown
            const sortEl = document.getElementById('eduMediaSort');
            if (sortEl) {
                sortEl.addEventListener('change', handleSortChange);
            }

            // Search with debounce
            const searchEl = document.getElementById('eduMediaSearch');
            if (searchEl) {
                let searchTimeout;
                searchEl.addEventListener('input', (e) => {
                    clearTimeout(searchTimeout);
                    const clearBtn = document.getElementById('clearSearch');
                    if (clearBtn) {
                        clearBtn.style.display = e.target.value ? 'block' : 'none';
                    }
                    searchTimeout = setTimeout(() => {
                        eduMediaState.currentSearch = e.target.value;
                        eduMediaState.currentPage = 1;
                        renderEduMedia();
                    }, 500);
                });
            }

            // Clear search button
            const clearSearchEl = document.getElementById('clearSearch');
            if (clearSearchEl) {
                clearSearchEl.addEventListener('click', () => {
                    const searchInput = document.getElementById('eduMediaSearch');
                    if (searchInput) {
                        searchInput.value = '';
                        eduMediaState.currentSearch = '';
                        clearSearchEl.style.display = 'none';
                        renderEduMedia();
                    }
                });
            }

            // View toggle buttons
            document.querySelectorAll('.view-toggle-buttons button').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    document.querySelectorAll('.view-toggle-buttons button').forEach(b =>
                        b.classList.remove('active')
                    );
                    e.currentTarget.classList.add('active');
                    eduMediaState.currentView = e.currentTarget.dataset.view;
                    saveUserPreferences();
                    renderCurrentView();
                });
            });

            // Action buttons
            const refreshBtn = document.getElementById('eduMediaRefresh');
            if (refreshBtn) {
                refreshBtn.addEventListener('click', refreshMedia);
            }

            const shuffleBtn = document.getElementById('eduMediaShuffle');
            if (shuffleBtn) {
                shuffleBtn.addEventListener('click', shuffleMedia);
            }

            const resetBtn = document.getElementById('resetFilters');
            if (resetBtn) {
                resetBtn.addEventListener('click', resetFilters);
            }

            const loadMoreBtn = document.getElementById('loadMoreMedia');
            if (loadMoreBtn) {
                loadMoreBtn.addEventListener('click', loadMoreMedia);
            }

            // Modal actions
            setupModalEventListeners();
        }

        function setupModalEventListeners() {
            const addToFavBtn = document.getElementById('addToFavorites');
            if (addToFavBtn) {
                addToFavBtn.addEventListener('click', handleAddToFavorites);
            }

            const shareBtn = document.getElementById('shareMedia');
            if (shareBtn) {
                shareBtn.addEventListener('click', handleShareMedia);
            }

            // AI action buttons
            document.querySelectorAll('[data-ai-action]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    const action = e.currentTarget.dataset.aiAction;
                    handleAIAction(action);
                });
            });
        }

        // ============================================================================
        // EVENT HANDLERS
        // ============================================================================

        function handleFilterChange(e) {
            eduMediaState.currentFilter = e.target.value;
            eduMediaState.currentPage = 1;
            renderEduMedia();
        }

        function handleSortChange(e) {
            eduMediaState.currentSort = e.target.value;
            eduMediaState.currentPage = 1;
            saveUserPreferences();
            applyFiltersAndSort();
            renderCurrentView();
            updateMediaCount();
        }

        function handleAddToFavorites() {
            const modal = document.getElementById('eduMediaModal');
            if (!modal) return;

            const mediaId = modal.dataset.currentMediaId;
            const mediaTitle = document.getElementById('eduMediaTitle')?.textContent;

            if (!mediaId) return;

            const index = eduMediaState.favorites.indexOf(mediaId);
            const btn = document.getElementById('addToFavorites');

            if (index === -1) {
                eduMediaState.favorites.push(mediaId);
                if (btn) btn.innerHTML = '<i class="bi bi-heart-fill"></i>';
                showNotification(`"${mediaTitle}" ajouté aux favoris`, 'success');
            } else {
                eduMediaState.favorites.splice(index, 1);
                if (btn) btn.innerHTML = '<i class="bi bi-heart"></i>';
                showNotification(`"${mediaTitle}" retiré des favoris`, 'info');
            }

            saveUserPreferences();
        }

        function handleShareMedia() {
            const title = document.getElementById('eduMediaTitle')?.textContent;
            const modal = document.getElementById('eduMediaModal');
            const mediaId = modal?.dataset.currentMediaId;

            if (navigator.share && mediaId) {
                navigator.share({
                    title: `Découvrez: ${title}`,
                    text: `Je vous recommande ce contenu éducatif: ${title}`,
                    url: `https://www.themoviedb.org/movie/${mediaId}`
                }).catch(err => console.log('Share cancelled:', err));
            } else {
                // Fallback: copy to clipboard
                const url = `https://www.themoviedb.org/movie/${mediaId}`;
                navigator.clipboard.writeText(url).then(() => {
                    showNotification('Lien copié dans le presse-papiers', 'success');
                });
            }
        }

        function handleAIAction(action) {
            const title = document.getElementById('eduMediaTitle')?.textContent;
            const overview = document.getElementById('eduMediaDesc')?.textContent;

            switch (action) {
                case 'explain':
                    showNotification('Génération de l\'explication contextuelle...', 'info');
                    generateAIExplanation(title, overview);
                    break;
                case 'quiz':
                    showNotification('Création du quiz...', 'info');
                    generateAIQuiz(title, overview);
                    break;
                case 'resources':
                    showNotification('Recherche de ressources complémentaires...', 'info');
                    generateAIResources(title, overview);
                    break;
            }
        }

        // ============================================================================
        // CORE RENDERING FUNCTIONS
        // ============================================================================

        async function renderEduMedia() {
            const loader = document.getElementById('eduMediaLoader');
            const grid = document.getElementById('eduMediaGrid');
            const list = document.getElementById('eduMediaList');
            const cards = document.getElementById('eduMediaCards');
            const empty = document.getElementById('eduMediaEmpty');
            const loadMore = document.getElementById('loadMoreContainer');

            // Show loader and hide all views
            if (loader) loader.classList.remove('d-none');
            if (grid) grid.classList.add('d-none');
            if (list) list.classList.add('d-none');
            if (cards) cards.classList.add('d-none');
            if (empty) empty.classList.add('d-none');
            if (loadMore) loadMore.classList.add('d-none');

            try {
                // Fetch media from TMDB
                const media = await fetchTMDBMedia();
                eduMediaState.allMedia = media;

                // Apply filters and sorting
                applyFiltersAndSort();

                if (eduMediaState.filteredMedia.length === 0) {
                    showEmptyState();
                    return;
                }

                // Render based on current view
                renderCurrentView();

                // Update UI elements
                updateStatsMedia();
                updateMediaCount();
                updateLastUpdatedTime();

                // Show load more button if applicable
                if (eduMediaState.currentPage < eduMediaState.totalPages && loadMore) {
                    loadMore.classList.remove('d-none');
                }

            } catch (error) {
                console.error('❌ TMDB Fetch Error:', error);
                showErrorState(error);
            } finally {
                if (loader) loader.classList.add('d-none');
            }
        }

        async function fetchTMDBMedia() {
            const { currentFilter, currentSearch, currentPage } = eduMediaState;

            // Check cache first
            const cacheKey = `${currentFilter}-${currentSearch}-${currentPage}`;
            const cached = eduMediaState.cache.get(cacheKey);

            if (cached && Date.now() - cached.timestamp < TMDB_CONFIG.CACHE_DURATION) {
                console.log('📦 Using cached data');
                eduMediaState.totalPages = cached.totalPages;
                return cached.data;
            }

            let endpoint, params;

            if (currentSearch) {
                endpoint = 'search/movie';
                params = { query: currentSearch };
            } else if (currentFilter && SUBJECT_GENRES[currentFilter]) {
                endpoint = 'discover/movie';
                params = {
                    with_genres: SUBJECT_GENRES[currentFilter].ids.join(','),
                    'vote_count.gte': 100 // Quality filter
                };
            } else {
                endpoint = 'movie/popular';
                params = {};
            }

            const queryParams = new URLSearchParams({
                api_key: TMDB_CONFIG.API_KEY,
                language: TMDB_CONFIG.LANGUAGE,
                page: currentPage,
                ...params,
                sort_by: getSortParam(eduMediaState.currentSort)
            });

            const response = await fetch(`${TMDB_CONFIG.BASE_URL}/${endpoint}?${queryParams}`);

            if (!response.ok) {
                throw new Error(`TMDB API Error: ${response.status} ${response.statusText}`);
            }

            const data = await response.json();
            eduMediaState.totalPages = data.total_pages;

            const processedResults = data.results.map(item => ({
                id: item.id,
                title: item.title,
                overview: item.overview || 'Description non disponible',
                poster_path: item.poster_path,
                backdrop_path: item.backdrop_path,
                release_date: item.release_date,
                vote_average: item.vote_average || 0,
                vote_count: item.vote_count || 0,
                genre_ids: item.genre_ids || [],
                popularity: item.popularity || 0,
                media_type: 'movie'
            }));

            // Cache the results
            eduMediaState.cache.set(cacheKey, {
                data: processedResults,
                totalPages: data.total_pages,
                timestamp: Date.now()
            });

            return processedResults;
        }

        function getSortParam(sort) {
            const sortMap = {
                popularity: 'popularity.desc',
                release_date: 'release_date.desc',
                vote_average: 'vote_average.desc',
                title: 'title.asc'
            };
            return sortMap[sort] || 'popularity.desc';
        }

        // ============================================================================
        // FILTER & SORT LOGIC
        // ============================================================================

        function applyFiltersAndSort() {
            let filtered = [...eduMediaState.allMedia];

            // Apply subject filter
            if (eduMediaState.currentFilter && SUBJECT_GENRES[eduMediaState.currentFilter]) {
                const genreIds = SUBJECT_GENRES[eduMediaState.currentFilter].ids;
                filtered = filtered.filter(media =>
                    media.genre_ids.some(id => genreIds.includes(id))
                );
            }

            // Apply search filter
            if (eduMediaState.currentSearch) {
                const search = eduMediaState.currentSearch.toLowerCase();
                filtered = filtered.filter(media =>
                    media.title.toLowerCase().includes(search) ||
                    media.overview.toLowerCase().includes(search)
                );
            }

            // Apply sorting
            filtered.sort((a, b) => {
                switch (eduMediaState.currentSort) {
                    case 'release_date':
                        return new Date(b.release_date || 0) - new Date(a.release_date || 0);
                    case 'vote_average':
                        return (b.vote_average || 0) - (a.vote_average || 0);
                    case 'title':
                        return (a.title || '').localeCompare(b.title || '');
                    default: // popularity
                        return (b.popularity || 0) - (a.popularity || 0);
                }
            });

            eduMediaState.filteredMedia = filtered;
        }

        // ============================================================================
        // VIEW RENDERING
        // ============================================================================

        function renderCurrentView() {
            const grid = document.getElementById('eduMediaGrid');
            const list = document.getElementById('eduMediaList');
            const cards = document.getElementById('eduMediaCards');

            // Hide all views
            if (grid) grid.classList.add('d-none');
            if (list) list.classList.add('d-none');
            if (cards) cards.classList.add('d-none');

            switch (eduMediaState.currentView) {
                case 'grid':
                    renderGridView();
                    break;
                case 'list':
                    renderListView();
                    break;
                case 'cards':
                    renderCardsView();
                    break;
                default:
                    renderGridView();
            }
        }

        function renderGridView() {
            const grid = document.getElementById('eduMediaGrid');
            if (!grid) return;

            grid.innerHTML = eduMediaState.filteredMedia.map(media => `
                <div class="col-xl-3 col-lg-4 col-md-6">
                    <div class="edu-media-card" data-id="${media.id}" data-type="${media.media_type}">
                        <div class="card-image-wrapper">
                            <img 
                                src="${getImageUrl(media.poster_path, 'w500')}" 
                                alt="${escapeHtml(media.title)}" 
                                class="edu-media-poster"
                                loading="lazy"
                                onerror="this.src='https://via.placeholder.com/300x450/333/fff?text=Image+Non+Disponible'"
                            >
                            <div class="card-overlay">
                                <div class="overlay-content">
                                    <div class="rating-badge">
                                        <i class="bi bi-star-fill"></i> ${media.vote_average.toFixed(1)}
                                    </div>
                                    <button class="btn btn-primary btn-sm quick-view-btn" 
                                            onclick="event.stopPropagation(); EduMediaAPI.openQuickView(${media.id}, '${media.media_type}')">
                                        <i class="bi bi-eye"></i>
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div class="edu-media-info">
                            <h5 class="edu-media-title-card">${escapeHtml(media.title)}</h5>
                            <div class="edu-media-meta">
                                <span class="year">${getYear(media.release_date)}</span>
                            </div>
                        </div>
                    </div>
                </div>
            `).join('');

            attachCardEventListeners();
            grid.classList.remove('d-none');
        }


        function renderListView() {
            const list = document.getElementById('eduMediaList');
            if (!list) return;

            list.innerHTML = eduMediaState.filteredMedia.map(media => `
        <div class="edu-media-list-item" data-id="${media.id}" data-type="${media.media_type}">
            <div class="list-item-image">
                <img src="${getImageUrl(media.poster_path, 'w200')}" 
                     alt="${escapeHtml(media.title)}" 
                     loading="lazy"
                     onerror="this.src='https://via.placeholder.com/200x300/333/fff?text=No+Image'">
            </div>
            <div class="list-item-content">
                <div class="list-item-header">
                    <h5>${escapeHtml(media.title)}</h5>
                    <div class="list-item-meta">
                        <span class="year">${getYear(media.release_date)}</span>
                        <span class="rating"><i class="bi bi-star-fill"></i> ${media.vote_average.toFixed(1)}</span>
                        <span class="badge">${getSubjectFromGenres(media.genre_ids)}</span>
                    </div>
                </div>
                <p class="list-item-desc">${truncateText(media.overview, 200)}</p>
                <div class="list-item-actions">
                    <button class="btn btn-primary btn-sm" 
                            onclick="openEduMediaModal(${media.id}, '${media.media_type}', '${escapeHtml(media.title).replace(/'/g, "\\'")}')">
                        <i class="bi bi-play-fill"></i> Voir la bande-annonce
                    </button>
                    <button class="btn btn-outline-secondary btn-sm" 
                            onclick="addToWatchlist(${media.id})">
                        <i class="bi bi-bookmark"></i> Watchlist
                    </button>
                </div>
            </div>
        </div>
    `).join('');

            list.classList.remove('d-none');
        }

        function renderCardsView() {
            const cards = document.getElementById('eduMediaCards');
            if (!cards) return;

            cards.innerHTML = eduMediaState.filteredMedia.map(media => `
        <div class="col-md-6 col-lg-4">
            <div class="edu-media-card-large" data-id="${media.id}" data-type="${media.media_type}">
                <div class="card-large-image" 
                     style="background-image: linear-gradient(to bottom, rgba(0,0,0,0.3), rgba(0,0,0,0.8)), url('${getImageUrl(media.backdrop_path, 'w780')}')">
                    <div class="card-large-overlay">
                        <div class="card-large-content">
                            <h5>${escapeHtml(media.title)}</h5>
                            <p>${truncateText(media.overview, 150)}</p>
                            <div class="card-large-meta">
                                <span><i class="bi bi-calendar"></i> ${getYear(media.release_date)}</span>
                                <span><i class="bi bi-star-fill"></i> ${media.vote_average.toFixed(1)}</span>
                            </div>
                            <div class="card-large-actions">
                                <button class="btn btn-primary" 
                                        onclick="openEduMediaModal(${media.id}, '${media.media_type}', '${escapeHtml(media.title).replace(/'/g, "\\'")}')">
                                    <i class="bi bi-play-fill"></i> Regarder
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    `).join('');

            cards.classList.remove('d-none');
        }


        function attachCardEventListeners() {
            document.querySelectorAll('.edu-media-card').forEach(card => {
                card.addEventListener('click', (e) => {
                    // Don't trigger if clicking quick view button
                    if (e.target.closest('.quick-view-btn')) return;

                    const id = card.dataset.id;
                    const type = card.dataset.type;
                    const title = card.querySelector('.edu-media-title-card')?.textContent || 'Unknown';
                    //openEduMediaModal(id, type, title);
                    EduMediaAPI.openModal(id, type, title);
                });
            });
        }

        // ============================================================================
        // MODAL FUNCTIONALITY
        // ============================================================================

        async function openEduMediaModal(id, type, title) {
            const modalEl = document.getElementById('eduMediaModal');
            if (!modalEl) return;

            // Store current media ID
            modalEl.dataset.currentMediaId = id;
            modalEl.dataset.currentMediaType = type;

            const modal = new bootstrap.Modal(modalEl);

            try {
                // Show loading state
                showModalLoading(true);

                // Fetch all data in parallel
                const [details, videos, similar] = await Promise.all([
                    fetchMediaDetails(id, type),
                    fetchMediaVideos(id, type),
                    fetchSimilarMedia(id, type)
                ]);

                // Populate modal with data
                populateModalData(details, videos, similar);

                // Update favorites button state
                updateFavoritesButton(id);

                modal.show();

            } catch (error) {
                console.error('❌ Error opening modal:', error);
                showModalError(error);
            } finally {
                showModalLoading(false);
            }
        }

        async function fetchMediaDetails(id, type) {
            const response = await fetch(
                `${TMDB_CONFIG.BASE_URL}/${type}/${id}?api_key=${TMDB_CONFIG.API_KEY}&language=${TMDB_CONFIG.LANGUAGE}&append_to_response=credits`
            );

            if (!response.ok) {
                throw new Error(`Failed to fetch media details: ${response.status}`);
            }

            return await response.json();
        }

        async function fetchMediaVideos(id, type) {
            const response = await fetch(
                `${TMDB_CONFIG.BASE_URL}/${type}/${id}/videos?api_key=${TMDB_CONFIG.API_KEY}&language=fr`
            );

            if (!response.ok) return null;

            const data = await response.json();
            // Try to find French trailer first, then any trailer
            return data.results.find(v => v.type === 'Trailer' && v.site === 'YouTube') || null;
        }

        async function fetchSimilarMedia(id, type) {
            const response = await fetch(
                `${TMDB_CONFIG.BASE_URL}/${type}/${id}/similar?api_key=${TMDB_CONFIG.API_KEY}&language=${TMDB_CONFIG.LANGUAGE}&page=1`
            );

            if (!response.ok) return [];

            const data = await response.json();
            return data.results.slice(0, 4);
        }

        function populateModalData(details, trailer, similar) {
            // Basic info
            const titleEl = document.getElementById('eduMediaTitle');
            const yearEl = document.getElementById('eduMediaYear');
            const ratingEl = document.getElementById('eduMediaRating');
            const descEl = document.getElementById('eduMediaDesc');

            if (titleEl) titleEl.textContent = details.title || details.name || 'Titre inconnu';
            if (yearEl) yearEl.textContent = new Date(details.release_date || details.first_air_date).getFullYear() || 'N/A';
            if (ratingEl) ratingEl.textContent = `${(details.vote_average || 0).toFixed(1)}/10`;
            if (descEl) descEl.textContent = details.overview || 'Description non disponible';

            // Duration (if available)
            const durationEl = document.getElementById('eduMediaDuration');
            if (durationEl && details.runtime) {
                const hours = Math.floor(details.runtime / 60);
                const minutes = details.runtime % 60;
                durationEl.textContent = `${hours}h ${minutes}min`;
            } else if (durationEl) {
                durationEl.textContent = '';
            }

            // Video player
            const playerEl = document.getElementById('eduMediaPlayer');
            if (playerEl) {
                if (trailer) {
                    playerEl.innerHTML = `
                <iframe 
                    src="https://www.youtube.com/embed/${trailer.key}?autoplay=0&rel=0&modestbranding=1" 
                    frameborder="0" 
                    allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                    allowfullscreen
                    style="width:100%;height:100%;">
                </iframe>
            `;
                } else {
                    playerEl.innerHTML = `
                <div class="player-placeholder d-flex flex-column align-items-center justify-content-center h-100 bg-dark">
                    <i class="bi bi-film" style="font-size: 4rem; color: #666;"></i>
                    <p class="mt-3 text-muted">Bande-annonce non disponible</p>
                </div>
            `;
                }
            }

            // Genres
            const genresEl = document.getElementById('eduMediaGenres');
            if (genresEl && details.genres) {
                genresEl.textContent = details.genres.map(g => g.name).join(', ') || 'N/A';
            }

            // Language
            const languageEl = document.getElementById('eduMediaLanguage');
            if (languageEl && details.original_language) {
                languageEl.textContent = details.original_language.toUpperCase();
            }

            // Votes
            const votesEl = document.getElementById('eduMediaVotes');
            if (votesEl) {
                votesEl.textContent = `${(details.vote_average || 0).toFixed(1)} (${details.vote_count || 0} votes)`;
            }

            // Similar media
            const similarEl = document.getElementById('similarMedia');
            if (similarEl && similar && similar.length > 0) {
                similarEl.innerHTML = similar.map(media => `
            <div class="similar-item" 
                 onclick="openEduMediaModal(${media.id}, '${media.media_type || 'movie'}', '${escapeHtml(media.title || media.name).replace(/'/g, "\\'")}')">
                <img src="${getImageUrl(media.poster_path, 'w154')}" 
                     alt="${escapeHtml(media.title || media.name)}"
                     onerror="this.src='https://via.placeholder.com/154x231/333/fff?text=No+Image'">
                <span>${escapeHtml(media.title || media.name)}</span>
            </div>
        `).join('');
            } else if (similarEl) {
                similarEl.innerHTML = '<p class="text-muted">Aucun contenu similaire trouvé</p>';
            }
        }

        function showModalLoading(show) {
            const playerEl = document.getElementById('eduMediaPlayer');
            if (!playerEl) return;

            if (show) {
                playerEl.innerHTML = `
            <div class="d-flex flex-column align-items-center justify-content-center h-100 bg-dark">
                <div class="spinner-border text-primary mb-3"></div>
                <p class="text-muted">Chargement des détails...</p>
            </div>
        `;
            }
        }

        function showModalError(error) {
            showNotification(`Erreur: ${error.message}`, 'danger');
        }

        function updateFavoritesButton(mediaId) {
            const btn = document.getElementById('addToFavorites');
            if (!btn) return;

            const isFavorite = eduMediaState.favorites.includes(mediaId);
            btn.innerHTML = isFavorite ? '<i class="bi bi-heart-fill"></i>' : '<i class="bi bi-heart"></i>';
        }

        // ============================================================================
        // QUICK VIEW FUNCTIONALITY
        // ============================================================================

        function openQuickView(id, type) {
            const media = eduMediaState.allMedia.find(m => m.id == id);
            if (!media) return;

            const quickTitleEl = document.getElementById('quickViewTitle');
            const quickOverviewEl = document.getElementById('quickViewOverview');
            const quickPosterEl = document.getElementById('quickViewPoster');

            if (quickTitleEl) quickTitleEl.textContent = media.title;
            if (quickOverviewEl) quickOverviewEl.textContent = truncateText(media.overview, 200);
            if (quickPosterEl) quickPosterEl.src = getImageUrl(media.poster_path, 'w300');

            const quickModalEl = document.getElementById('quickViewModal');
            if (quickModalEl) {
                const quickModal = new bootstrap.Modal(quickModalEl);
                quickModal.show();
            }
        }

        // ============================================================================
        // WATCHLIST & FAVORITES
        // ============================================================================

        function addToWatchlist(mediaId) {
            const index = eduMediaState.watchlist.indexOf(mediaId);

            if (index === -1) {
                eduMediaState.watchlist.push(mediaId);
                showNotification('Ajouté à la watchlist', 'success');
            } else {
                eduMediaState.watchlist.splice(index, 1);
                showNotification('Retiré de la watchlist', 'info');
            }

            saveUserPreferences();
        }

        // ============================================================================
        // ACTION HANDLERS
        // ============================================================================

        async function refreshMedia() {
            const btn = document.getElementById('eduMediaRefresh');
            if (btn) {
                const originalHTML = btn.innerHTML;
                btn.innerHTML = '<i class="bi bi-arrow-clockwise spin"></i>';
                btn.disabled = true;
            }

            // Clear cache
            eduMediaState.cache.clear();
            eduMediaState.currentPage = 1;

            await renderEduMedia();

            if (btn) {
                btn.innerHTML = originalHTML;
                btn.disabled = false;
            }

            showNotification('Médias actualisés', 'success');
        }

        function shuffleMedia() {
            const shuffled = [...eduMediaState.filteredMedia].sort(() => Math.random() - 0.5);
            eduMediaState.filteredMedia = shuffled;
            renderCurrentView();
            showNotification('Médias mélangés aléatoirement !', 'success');
        }

        function resetFilters() {
            eduMediaState.currentFilter = '';
            eduMediaState.currentSearch = '';
            eduMediaState.currentSort = 'popularity';
            eduMediaState.currentPage = 1;

            const filterEl = document.getElementById('eduMediaFilter');
            const searchEl = document.getElementById('eduMediaSearch');
            const sortEl = document.getElementById('eduMediaSort');
            const clearSearchEl = document.getElementById('clearSearch');

            if (filterEl) filterEl.value = '';
            if (searchEl) searchEl.value = '';
            if (sortEl) sortEl.value = 'popularity';
            if (clearSearchEl) clearSearchEl.style.display = 'none';

            renderEduMedia();
            showNotification('Filtres réinitialisés', 'info');
        }

        async function loadMoreMedia() {
            const btn = document.getElementById('loadMoreMedia');
            if (!btn) return;

            const originalHTML = btn.innerHTML;
            btn.innerHTML = '<i class="bi bi-arrow-repeat spinner"></i> Chargement...';
            btn.disabled = true;

            try {
                eduMediaState.currentPage++;
                const newMedia = await fetchTMDBMedia();

                // Append new media to existing
                eduMediaState.allMedia = [...eduMediaState.allMedia, ...newMedia];
                applyFiltersAndSort();
                renderCurrentView();
                updateStatsMedia();
                updateMediaCount();

                // Hide button if no more pages
                if (eduMediaState.currentPage >= eduMediaState.totalPages) {
                    const container = document.getElementById('loadMoreContainer');
                    if (container) container.classList.add('d-none');
                }

                showNotification(`${newMedia.length} nouveaux médias chargés`, 'success');

            } catch (error) {
                console.error('Error loading more media:', error);
                showNotification('Erreur lors du chargement', 'danger');
                eduMediaState.currentPage--; // Revert page increment
            } finally {
                btn.innerHTML = originalHTML;
                btn.disabled = false;
            }
        }

        // ============================================================================
        // AI FEATURES (Placeholder implementations)
        // ============================================================================

        function generateAIExplanation(title, overview) {
            // This would integrate with your AI system
            console.log('AI Explanation requested for:', title);
            setTimeout(() => {
                showNotification('Fonction IA à implémenter avec votre système', 'info');
            }, 1000);
        }

        function generateAIQuiz(title, overview) {
            // This would integrate with your AI system
            console.log('AI Quiz requested for:', title);
            setTimeout(() => {
                showNotification('Fonction IA à implémenter avec votre système', 'info');
            }, 1000);
        }

        function generateAIResources(title, overview) {
            // This would integrate with your AI system
            console.log('AI Resources requested for:', title);
            setTimeout(() => {
                showNotification('Fonction IA à implémenter avec votre système', 'info');
            }, 1000);
        }

        // ============================================================================
        // UI UPDATE FUNCTIONS
        // ============================================================================

        function updateStatsMedia() {
            const totalEl = document.getElementById('totalMediaCount');
            const filterEl = document.getElementById('activeFilterCount');

            if (totalEl) totalEl.textContent = eduMediaState.allMedia.length;

            if (filterEl) {
                if (eduMediaState.currentFilter && SUBJECT_GENRES[eduMediaState.currentFilter]) {
                    filterEl.textContent = SUBJECT_GENRES[eduMediaState.currentFilter].name;
                } else {
                    filterEl.textContent = 'Aucun';
                }
            }
        }

        function updateMediaCount() {
            const countEl = document.getElementById('mediaCountText');
            if (!countEl) return;

            const count = eduMediaState.filteredMedia.length;
            countEl.textContent = `${count} média${count > 1 ? 's' : ''} trouvé${count > 1 ? 's' : ''}`;
        }

        function updateLastUpdatedTime() {
            const timeEl = document.getElementById('lastUpdated');
            if (timeEl) {
                timeEl.textContent = new Date().toLocaleTimeString('fr-FR');
            }
        }

        function updateProgress(percent) {
            const progressEl = document.getElementById('loadProgress');
            if (progressEl) {
                progressEl.style.width = `${percent}%`;
            }
        }

        // ============================================================================
        // STATE DISPLAY FUNCTIONS
        // ============================================================================

        function showEmptyState() {
            const emptyEl = document.getElementById('eduMediaEmpty');
            if (emptyEl) emptyEl.classList.remove('d-none');
        }

        function showErrorState(error) {
            const grid = document.getElementById('eduMediaGrid');
            if (!grid) return;

            grid.innerHTML = `
        <div class="col-12">
            <div class="alert alert-danger d-flex align-items-center" role="alert">
                <i class="bi bi-exclamation-triangle-fill me-3" style="font-size: 2rem;"></i>
                <div>
                    <h5 class="alert-heading mb-2">Erreur de chargement</h5>
                    <p class="mb-0">${escapeHtml(error.message)}</p>
                    <button class="btn btn-sm btn-outline-danger mt-2" onclick="refreshMedia()">
                        <i class="bi bi-arrow-clockwise"></i> Réessayer
                    </button>
                </div>
            </div>
        </div>
    `;
            grid.classList.remove('d-none');
        }

        function showNotification(message, type = 'info') {
            // Check if Bootstrap toast exists
            const toastContainer = document.getElementById('toastContainer');

            if (toastContainer) {
                const toastId = 'toast-' + Date.now();
                const iconMap = {
                    success: 'check-circle-fill',
                    danger: 'exclamation-triangle-fill',
                    warning: 'exclamation-circle-fill',
                    info: 'info-circle-fill'
                };

                const toastHTML = `
            <div id="${toastId}" class="toast align-items-center text-white bg-${type} border-0" role="alert">
                <div class="d-flex">
                    <div class="toast-body">
                        <i class="bi bi-${iconMap[type]} me-2"></i>
                        ${escapeHtml(message)}
                    </div>
                    <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
                </div>
            </div>
        `;

                toastContainer.insertAdjacentHTML('beforeend', toastHTML);
                const toastEl = document.getElementById(toastId);
                const toast = new bootstrap.Toast(toastEl, { delay: 3000 });
                toast.show();

                toastEl.addEventListener('hidden.bs.toast', () => toastEl.remove());
            } else {
                // Fallback to console
                console.log(`[${type.toUpperCase()}] ${message}`);
            }
        }

        // ============================================================================
        // UTILITY FUNCTIONS
        // ============================================================================

        function getImageUrl(path, size = 'w500') {
            if (!path) {
                return 'https://via.placeholder.com/500x750/1a1a1a/666?text=Image+Non+Disponible';
            }
            return `${TMDB_CONFIG.IMAGE_URL}${size}${path}`;
        }

        function truncateText(text, length) {
            if (!text) return '';
            return text.length > length ? text.substring(0, length) + '...' : text;
        }



        function getYear(dateString) {
            if (!dateString) return 'N/A';
            const year = dateString.substring(0, 4);
            return year || 'N/A';
        }

        function getSubjectFromGenres(genreIds) {
            if (!genreIds || genreIds.length === 0) return 'Général';

            for (const [subject, data] of Object.entries(SUBJECT_GENRES)) {
                if (genreIds.some(id => data.ids.includes(id))) {
                    return `${data.icon} ${data.name}`;
                }
            }
            return 'Général';
        }

        function getGenreName(genreId) {
            return GENRE_MAP[genreId] || 'Autre';
        }

        // ============================================================================
        // INTEGRATION WITH MAIN APP
        // ============================================================================

        // Function to be called from switchView
        function switchToEduMediaView() {
            initEduMedia();
        }

        // Export functions that need to be called from HTML
        window.openEduMediaModal = openEduMediaModal;
        window.openQuickView = openQuickView;
        window.addToWatchlist = addToWatchlist;
        window.refreshMedia = refreshMedia;

        // ============================================================================
        // INITIALIZATION ON DOM READY
        // ============================================================================

        // Auto-initialize if DOM is already loaded
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                console.log('📚 Education Media module loaded');
            });
        } else {
            console.log('📚 Education Media module loaded');
        }

        // ============================================================================
        // ADDITIONAL HELPER FUNCTIONS
        // ============================================================================

        /**
         * Debounce function for search input
         */
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }

        /**
         * Format number with commas
         */
        function formatNumber(num) {
            return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, " ");
        }

        /**
         * Get rating color based on score
         */
        function getRatingColor(rating) {
            if (rating >= 8) return '#4caf50'; // Green
            if (rating >= 6) return '#ff9800'; // Orange
            if (rating >= 4) return '#f44336'; // Red
            return '#9e9e9e'; // Gray
        }

        /**
         * Check if media is in watchlist
         */
        function isInWatchlist(mediaId) {
            return eduMediaState.watchlist.includes(mediaId);
        }

        /**
         * Check if media is in favorites
         */
        function isInFavorites(mediaId) {
            return eduMediaState.favorites.includes(mediaId);
        }

        /**
         * Get random media from current filtered list
         */
        function getRandomMedia() {
            if (eduMediaState.filteredMedia.length === 0) return null;
            const randomIndex = Math.floor(Math.random() * eduMediaState.filteredMedia.length);
            return eduMediaState.filteredMedia[randomIndex];
        }

        /**
         * Clear all caches
         */
        function clearAllCaches() {
            eduMediaState.cache.clear();
            showNotification('Cache vidé avec succès', 'success');
        }

        /**
         * Export watchlist/favorites as JSON
         */
        function exportUserData() {
            const data = {
                watchlist: eduMediaState.watchlist,
                favorites: eduMediaState.favorites,
                exportDate: new Date().toISOString()
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `edu-media-data-${Date.now()}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showNotification('Données exportées avec succès', 'success');
        }

        /**
         * Import watchlist/favorites from JSON
         */
        function importUserData(file) {
            const reader = new FileReader();

            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);

                    if (data.watchlist) eduMediaState.watchlist = data.watchlist;
                    if (data.favorites) eduMediaState.favorites = data.favorites;

                    saveUserPreferences();
                    showNotification('Données importées avec succès', 'success');
                } catch (error) {
                    showNotification('Erreur lors de l\'importation: ' + error.message, 'danger');
                }
            };

            reader.readAsText(file);
        }

        // ============================================================================
        // ADVANCED FEATURES
        // ============================================================================

        /**
         * Get media recommendations based on current preferences
         */
        async function getRecommendations() {
            if (eduMediaState.favorites.length === 0) {
                showNotification('Ajoutez d\'abord des favoris pour obtenir des recommandations', 'info');
                return;
            }

            try {
                // Get recommendations based on first favorite
                const firstFavorite = eduMediaState.favorites[0];
                const response = await fetch(
                    `${TMDB_CONFIG.BASE_URL}/movie/${firstFavorite}/recommendations?api_key=${TMDB_CONFIG.API_KEY}&language=${TMDB_CONFIG.LANGUAGE}`
                );

                if (!response.ok) throw new Error('Failed to fetch recommendations');

                const data = await response.json();

                if (data.results.length > 0) {
                    eduMediaState.allMedia = data.results.map(item => ({
                        id: item.id,
                        title: item.title,
                        overview: item.overview || 'Description non disponible',
                        poster_path: item.poster_path,
                        backdrop_path: item.backdrop_path,
                        release_date: item.release_date,
                        vote_average: item.vote_average || 0,
                        vote_count: item.vote_count || 0,
                        genre_ids: item.genre_ids || [],
                        popularity: item.popularity || 0,
                        media_type: 'movie'
                    }));

                    applyFiltersAndSort();
                    renderCurrentView();
                    updateStatsMedia();
                    updateMediaCount();

                    showNotification('Recommandations chargées avec succès', 'success');
                } else {
                    showNotification('Aucune recommandation trouvée', 'info');
                }

            } catch (error) {
                console.error('Error fetching recommendations:', error);
                showNotification('Erreur lors du chargement des recommandations', 'danger');
            }
        }

        /**
         * Search for specific actor/director
         */
        async function searchByPerson(personName) {
            try {
                // First, search for the person
                const personResponse = await fetch(
                    `${TMDB_CONFIG.BASE_URL}/search/person?api_key=${TMDB_CONFIG.API_KEY}&query=${encodeURIComponent(personName)}`
                );

                if (!personResponse.ok) throw new Error('Person search failed');

                const personData = await personResponse.json();

                if (personData.results.length === 0) {
                    showNotification('Personne non trouvée', 'warning');
                    return;
                }

                const personId = personData.results[0].id;

                // Get movies for this person
                const moviesResponse = await fetch(
                    `${TMDB_CONFIG.BASE_URL}/discover/movie?api_key=${TMDB_CONFIG.API_KEY}&with_people=${personId}&language=${TMDB_CONFIG.LANGUAGE}`
                );

                if (!moviesResponse.ok) throw new Error('Movies search failed');

                const moviesData = await moviesResponse.json();

                eduMediaState.allMedia = moviesData.results.map(item => ({
                    id: item.id,
                    title: item.title,
                    overview: item.overview || 'Description non disponible',
                    poster_path: item.poster_path,
                    backdrop_path: item.backdrop_path,
                    release_date: item.release_date,
                    vote_average: item.vote_average || 0,
                    vote_count: item.vote_count || 0,
                    genre_ids: item.genre_ids || [],
                    popularity: item.popularity || 0,
                    media_type: 'movie'
                }));

                applyFiltersAndSort();
                renderCurrentView();
                updateStatsMedia();
                updateMediaCount();

                showNotification(`Films avec ${personData.results[0].name} chargés`, 'success');

            } catch (error) {
                console.error('Error searching by person:', error);
                showNotification('Erreur lors de la recherche', 'danger');
            }
        }

        /**
         * Get trending media
         */
        async function loadTrending(timeWindow = 'week') {
            try {
                const response = await fetch(
                    `${TMDB_CONFIG.BASE_URL}/trending/movie/${timeWindow}?api_key=${TMDB_CONFIG.API_KEY}&language=${TMDB_CONFIG.LANGUAGE}`
                );

                if (!response.ok) throw new Error('Failed to fetch trending');

                const data = await response.json();

                eduMediaState.allMedia = data.results.map(item => ({
                    id: item.id,
                    title: item.title,
                    overview: item.overview || 'Description non disponible',
                    poster_path: item.poster_path,
                    backdrop_path: item.backdrop_path,
                    release_date: item.release_date,
                    vote_average: item.vote_average || 0,
                    vote_count: item.vote_count || 0,
                    genre_ids: item.genre_ids || [],
                    popularity: item.popularity || 0,
                    media_type: 'movie'
                }));

                applyFiltersAndSort();
                renderCurrentView();
                updateStatsMedia();
                updateMediaCount();

                showNotification('Tendances chargées avec succès', 'success');

            } catch (error) {
                console.error('Error loading trending:', error);
                showNotification('Erreur lors du chargement des tendances', 'danger');
            }
        }

        /**
         * Filter by year range
         */
        function filterByYearRange(startYear, endYear) {
            eduMediaState.filteredMedia = eduMediaState.allMedia.filter(media => {
                if (!media.release_date) return false;
                const year = parseInt(media.release_date.substring(0, 4));
                return year >= startYear && year <= endYear;
            });

            renderCurrentView();
            updateMediaCount();
        }

        /**
         * Filter by minimum rating
         */
        function filterByMinRating(minRating) {
            eduMediaState.filteredMedia = eduMediaState.allMedia.filter(media => {
                return media.vote_average >= minRating && media.vote_count >= 50;
            });

            renderCurrentView();
            updateMediaCount();
        }

        // ============================================================================
        // KEYBOARD SHORTCUTS
        // ============================================================================

        document.addEventListener('keydown', (e) => {
            // Only handle shortcuts when modal is not open
            const modalOpen = document.querySelector('.modal.show');
            if (modalOpen) return;

            // Check if we're in the edu-media view
            const eduMediaView = document.getElementById('edu-mediaView');
            if (!eduMediaView || eduMediaView.classList.contains('d-none')) return;

            switch (e.key) {
                case 'r':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        refreshMedia();
                    }
                    break;
                case 's':
                    if (e.ctrlKey || e.metaKey) {
                        e.preventDefault();
                        document.getElementById('eduMediaSearch')?.focus();
                    }
                    break;
                case 'Escape':
                    const searchEl = document.getElementById('eduMediaSearch');
                    if (searchEl && searchEl.value) {
                        searchEl.value = '';
                        eduMediaState.currentSearch = '';
                        renderEduMedia();
                    }
                    break;
            }
        });

        // ============================================================================
        // PERFORMANCE MONITORING
        // ============================================================================

        let performanceMetrics = {
            lastFetchTime: 0,
            averageFetchTime: 0,
            fetchCount: 0
        };

        function trackPerformance(operation, duration) {
            performanceMetrics.lastFetchTime = duration;
            performanceMetrics.fetchCount++;
            performanceMetrics.averageFetchTime =
                ((performanceMetrics.averageFetchTime * (performanceMetrics.fetchCount - 1)) + duration)
                / performanceMetrics.fetchCount;

            console.log(`⚡ ${operation} completed in ${duration}ms`);
        }

        // ============================================================================
        // ERROR RECOVERY
        // ============================================================================

        let retryCount = 0;
        const MAX_RETRIES = 3;

        async function fetchWithRetry(url, options = {}, retries = MAX_RETRIES) {
            try {
                const response = await fetch(url, options);
                if (!response.ok) throw new Error(`HTTP ${response.status}`);
                retryCount = 0; // Reset on success
                return response;
            } catch (error) {
                if (retries > 0) {
                    console.warn(`Retry attempt ${MAX_RETRIES - retries + 1}/${MAX_RETRIES}`);
                    await new Promise(resolve => setTimeout(resolve, 1000 * (MAX_RETRIES - retries + 1)));
                    return fetchWithRetry(url, options, retries - 1);
                }
                throw error;
            }
        }

        // ============================================================================
        // ANALYTICS (Optional - for tracking usage)
        // ============================================================================

        function trackEvent(eventName, eventData = {}) {
            console.log(`📊 Event: ${eventName}`, eventData);
            // Here you could send to your analytics service
        }

        // Track view changes
        const originalRenderCurrentView = renderCurrentView;
        renderCurrentView = function () {
            trackEvent('view_change', { view: eduMediaState.currentView });
            return originalRenderCurrentView.apply(this, arguments);
        };

        // Track modal opens
        const originalOpenModal = openEduMediaModal;
        openEduMediaModal = function (id, type, title) {
            trackEvent('modal_open', { mediaId: id, mediaType: type, title });
            return originalOpenModal.apply(this, arguments);
        };

        // ============================================================================
        // ACCESSIBILITY IMPROVEMENTS
        // ============================================================================

        /**
         * Announce changes to screen readers
         */
        function announceToScreenReader(message) {
            const announcement = document.createElement('div');
            announcement.setAttribute('role', 'status');
            announcement.setAttribute('aria-live', 'polite');
            announcement.setAttribute('aria-atomic', 'true');
            announcement.className = 'sr-only';
            announcement.textContent = message;

            document.body.appendChild(announcement);

            setTimeout(() => {
                document.body.removeChild(announcement);
            }, 1000);
        }

        // Update announcements on state changes
        const originalUpdateMediaCount = updateMediaCount;
        updateMediaCount = function () {
            const result = originalUpdateMediaCount.apply(this, arguments);
            const count = eduMediaState.filteredMedia.length;
            announceToScreenReader(`${count} média${count > 1 ? 's' : ''} trouvé${count > 1 ? 's' : ''}`);
            return result;
        };

        // ============================================================================
        // CLEANUP & MEMORY MANAGEMENT
        // ============================================================================

        /**
         * Clean up old cache entries
         */
        function cleanupCache() {
            const now = Date.now();
            const entriesToDelete = [];

            for (const [key, value] of eduMediaState.cache.entries()) {
                if (now - value.timestamp > TMDB_CONFIG.CACHE_DURATION) {
                    entriesToDelete.push(key);
                }
            }

            entriesToDelete.forEach(key => eduMediaState.cache.delete(key));

            if (entriesToDelete.length > 0) {
                console.log(`🧹 Cleaned up ${entriesToDelete.length} cache entries`);
            }
        }

        // Run cleanup every 5 minutes
        setInterval(cleanupCache, 5 * 60 * 1000);

        /**
         * Cleanup function to call when leaving the view
         */
        function cleanupEduMedia() {
            console.log('🧹 Cleaning up Education Media view');

            // Clear any active intervals or timeouts
            // Close any open modals
            const modalEl = document.getElementById('eduMediaModal');
            if (modalEl) {
                const modal = bootstrap.Modal.getInstance(modalEl);
                if (modal) modal.hide();
            }

            // Clear video players to stop playback
            const playerEl = document.getElementById('eduMediaPlayer');
            if (playerEl) {
                playerEl.innerHTML = '';
            }
        }

        // ============================================================================
        // EXPORT PUBLIC API
        // ============================================================================

        /*const EduMediaAPI = {
            init: initEduMedia,
            refresh: refreshMedia,
            shuffle: shuffleMedia,
            reset: resetFilters,
            loadMore: loadMoreMedia,
            openModal: openEduMediaModal,
            addToWatchlist: addToWatchlist,
            getRecommendations: getRecommendations,
            searchByPerson: searchByPerson,
            loadTrending: loadTrending,
            filterByYearRange: filterByYearRange,
            filterByMinRating: filterByMinRating,
            exportData: exportUserData,
            importData: importUserData,
            clearCache: clearAllCaches,
            cleanup: cleanupEduMedia,
            getState: () => ({ ...eduMediaState })
        };*/

        const EduMediaAPI = {
            init: initEduMedia,
            openModal: openEduMediaModal,
            openQuickView: openQuickView,
            addToWatchlist: addToWatchlist,
            refresh: refreshMedia,
            shuffle: shuffleMedia,
            reset: resetFilters,
            loadMore: loadMoreMedia,
            getRecommendations: getRecommendations,
            searchByPerson: searchByPerson,
            loadTrending: loadTrending,
            filterByYearRange: filterByYearRange,
            filterByMinRating: filterByMinRating,
            exportData: exportUserData,
            importData: importUserData,
            clearCache: clearAllCaches,
            cleanup: cleanupEduMedia,
            getState: () => ({ ...eduMediaState }) // Expose state safely
        };



        // Make API available globally
        window.EduMediaAPI = EduMediaAPI;

        console.log('✅ Education Media module fully loaded and ready');
        console.log('📚 Available functions:', Object.keys(EduMediaAPI));


        // Fonction pour mettre à jour la progression dans Firestore

        async function saveUserProgress(fileId, progress) {
            const user = auth.currentUser;
            if (!user) {
                showToast("Veuillez vous connecter pour enregistrer votre progression.", "warning");
                return;
            }

            userProgress[fileId] = progress;
            localStorage.setItem("userProgress", JSON.stringify(userProgress));

            try {
                const progressRef = doc(db, 'users', user.uid);

                // setDoc avec merge: true pour créer le document utilisateur s'il n'existe pas
                await setDoc(progressRef, {
                    progress: userProgress
                }, { merge: true });

                updateStats();

            } catch (error) {
                console.error("Erreur lors de l'enregistrement de la progression Firestore:", error);
            }
        }

        window.updateLocalProgress = function (fileId, progress) {
            userProgress[fileId] = progress;
            localStorage.setItem("userProgress", JSON.stringify(userProgress));
            updateStats(); // Met à jour le tableau de bord
        };
        /**
         * Creates a "raw" notification event in the public inbox.
         * This is a client-side trigger that other clients will
         listen for.
         * @param {string} targetUserId The ID of the user to notify.
            * @param {object} payload The notification data (message,
            type, link).
            */
        async function triggerNotificationEvent(targetUserId,
            payload) {
            if (!targetUserId || !auth.currentUser) return;
            try {
                await addDoc(collection(db, "notification_inbox"), {
                    ...payload,
                    targetUserId: targetUserId,
                    creatorName: auth.currentUser.displayName || "Anonyme",
                    createdAt: Timestamp.now(),
                });
            } catch (error) {
                console.error(`Failed to trigger notification event:`,
                    error);
            }
        }

        async function renderFullNotificationPage() {
            const container = document.getElementById("fullNotifList");
            if (!container) return;

            container.innerHTML =
                `<div class="text-center p-5">
                < div class="loader" ></div >
            </div > `;

            const user = auth.currentUser;
            if (!user) {
                container.innerHTML =
                    `<div class="text-center text-muted p-5"><iclass="bi bi-lock fs-1" ></i >
                    <p class="mt-2">Veuillez vous connecter pour voir vos
                        notifications.</p>
                                                            </div > `;
                return;
            }

            try {
                // Fetch ALL notifications for the user, ordered by date
                const notifQuery = query(
                    collection(db, "users", user.uid, "notifications"),
                    orderBy("createdAt", "desc")
                );
                const snapshot = await getDocs(notifQuery);

                if (snapshot.empty) {
                    container.innerHTML =
                        `<div class="text-center text-muted p-5"><i
                    class="bi bi-bell-slash fs-1" ></i >
                        <p class="mt-2">Vous n\'avez aucune notification pour le
                            moment.</p>
                                                            </div > `;
                    return;
                }

                container.innerHTML = ""; // Clear the loader

                snapshot.docs.forEach((doc) => {
                    const notif = { id: doc.id, ...doc.data() };

                    const itemEl = document.createElement("a");
                    itemEl.href = "#";
                    // Use the same CSS classes as the dropdown for a consistent
                    look
                    itemEl.className = `list-group-item notification-item
            ${notif.read ? "" : "unread"
                        }`;
                    itemEl.onclick = (e) => {
                        e.preventDefault();
                        handleNotificationClick(notif);
                        renderFullNotificationPage();
                    };

                    const icon = getNotificationIcon(notif.type);

                    itemEl.innerHTML = `
            <div class="icon" style="color: ${icon.color};">${icon.html}</div>
            <div class="content flex-grow-1">
                ${notif.message}
                <div class="timestamp">${timeAgo(notif.createdAt.toDate())}</div>
            </div>
                            <!-- Add a chevron to indicate it's clickable -->
            <i class="bi bi-chevron-right ms-auto text-muted"></i>
            `;
                    container.appendChild(itemEl);
                });
            } catch (error) {
                console.error("Error fetching full notification list:",
                    error);
                container.innerHTML =
                    `<div class="text-center text-danger p-5"><i class="bi bi-exclamation-triangle-fill fs-1" ></i >
                <p class="mt-2">Impossible de charger les notifications.
                </p>
            </div > `;
            }
        }

        function setTheme(theme) {
            localStorage.setItem("theme", theme);
            if (theme === "system") {
                document.body.removeAttribute("data-theme");
            } else {
                document.body.setAttribute("data-theme", theme);
            }
        }

        function loadTheme() {
            const theme = localStorage.getItem("theme") || "system";
            const select = document.getElementById("themeSelect");
            if (select) select.value = theme;
            setTheme(theme);
            loadBackgroundImage();
        }


        // ====================================================================
        // YOUTUBE MUSIC INTEGRATION (V7.0 - Version Corrigée et Optimisée)
        // ====================================================================
        // YouTube Music Controller with Real YouTube API Integration
        window.YouTubeMusicController = {
            isInitialized: false,
            currentPlaylist: null,
            searchResults: [],
            player: null,
            apiKey: YOUTUBE_API_KEY, // Use the same API key from your constants

            initMusicView: function () {
                console.log("Initializing Music View with YouTube API...");

                if (!this.apiKey) {
                    this.showApiKeyError();
                    return;
                }

                this.renderInitialContent();
                this.attachEventListeners();
                this.isInitialized = true;
                this.loadPopularContent();
            },

            showApiKeyError: function () {
                const musicContent = document.getElementById('musicContent');
                if (musicContent) {
                    musicContent.innerHTML = `
                <div class="col-12 text-center py-5">
                    <i class="bi bi-exclamation-triangle fs-1 text-danger"></i>
                    <h4 class="mt-3">Clé API YouTube manquante</h4>
                    <p class="text-muted">La clé API YouTube n'est pas configurée. Impossible de charger le contenu musical.</p>
                    <div class="mt-4">
                        <button class="btn btn-primary me-2" onclick="location.reload()">
                            <i class="bi bi-arrow-clockwise"></i> Réessayer
                        </button>
                        <button class="btn btn-outline-secondary" onclick="switchView('settings')">
                            <i class="bi bi-gear"></i> Paramètres
                        </button>
                    </div>
                </div>
            `;
                }
            },

            attachEventListeners: function () {
                // Search functionality
                const searchInput = document.getElementById('musicSearchInput');
                const searchBtn = document.getElementById('musicSearchBtn');
                const backBtn = document.getElementById('backToMusicList');
                const connectBtn = document.getElementById('connectYouTubeBtn');

                if (searchInput) {
                    searchInput.addEventListener('input', (e) => {
                        this.debouncedSearch(e.target.value);
                    });
                    searchInput.addEventListener('keypress', (e) => {
                        if (e.key === 'Enter') {
                            this.searchMusic(e.target.value);
                        }
                    });
                }

                if (searchBtn) {
                    searchBtn.addEventListener('click', () => {
                        this.searchMusic(searchInput?.value || '');
                    });
                }

                if (backBtn) {
                    backBtn.addEventListener('click', () => {
                        this.showMainView();
                    });
                }

                if (connectBtn) {
                    connectBtn.addEventListener('click', () => {
                        this.connectYouTubeAccount();
                    });
                }
            },

            debouncedSearch: function (query) {
                clearTimeout(this.debounceTimer);
                this.debounceTimer = setTimeout(() => {
                    if (query && query.length > 2) {
                        this.searchMusic(query);
                    } else if (!query || query.length === 0) {
                        this.loadPopularContent();
                    }
                }, 800);
            },

            renderInitialContent: function () {
                const musicContent = document.getElementById('musicContent');
                if (!musicContent) return;

                musicContent.innerHTML = `
            <div class="col-12">
                <div class="row g-4" id="musicPlaylistsGrid">
                    <div class="col-12 text-center py-5">
                        <div class="spinner-border text-primary"></div>
                        <p class="mt-2">Chargement du contenu musical...</p>
                    </div>
                </div>
            </div>
        `;
            },

            // REAL YOUTUBE API CALLS
            async makeYouTubeAPIRequest(endpoint, params = {}) {
                const baseUrl = 'https://www.googleapis.com/youtube/v3';
                const defaultParams = {
                    key: this.apiKey,
                    part: 'snippet,contentDetails',
                    maxResults: 20
                };

                const allParams = { ...defaultParams, ...params };
                const queryString = new URLSearchParams(allParams).toString();

                try {
                    const response = await fetch(`${baseUrl}/${endpoint}?${queryString}`);

                    if (!response.ok) {
                        throw new Error(`YouTube API error: ${response.status} ${response.statusText}`);
                    }

                    return await response.json();
                } catch (error) {
                    console.error('YouTube API request failed:', error);
                    throw error;
                }
            },

            async loadPopularContent() {
                const grid = document.getElementById('musicPlaylistsGrid');
                if (!grid) return;

                try {
                    // Get popular music playlists
                    const playlistsData = await this.makeYouTubeAPIRequest('search', {
                        q: 'music study focus programming lofi chill',
                        type: 'playlist',
                        order: 'viewCount'
                    });

                    if (!playlistsData.items || playlistsData.items.length === 0) {
                        this.showFallbackContent();
                        return;
                    }

                    // Get details for each playlist
                    const playlistsWithDetails = await Promise.all(
                        playlistsData.items.slice(0, 8).map(async (item) => {
                            try {
                                const playlistDetails = await this.makeYouTubeAPIRequest('playlists', {
                                    id: item.id.playlistId
                                });

                                return {
                                    id: item.id.playlistId,
                                    title: item.snippet.title,
                                    description: item.snippet.description,
                                    thumbnail: item.snippet.thumbnails?.medium?.url || item.snippet.thumbnails?.default?.url,
                                    channel: item.snippet.channelTitle,
                                    videoCount: playlistDetails.items[0]?.contentDetails?.itemCount || 'N/A'
                                };
                            } catch (error) {
                                console.error('Error fetching playlist details:', error);
                                return null;
                            }
                        })
                    );

                    const validPlaylists = playlistsWithDetails.filter(p => p !== null);

                    if (validPlaylists.length === 0) {
                        this.showFallbackContent();
                        return;
                    }

                    this.displayPopularPlaylists(validPlaylists);
                    this.showRecentHistory();

                } catch (error) {
                    console.error('Error loading popular content:', error);
                    this.showError('Erreur de chargement du contenu populaire', error);
                }
            },

            displayPopularPlaylists: function (playlists) {
                const grid = document.getElementById('musicPlaylistsGrid');
                if (!grid) return;

                grid.innerHTML = playlists.map(playlist => `
            <div class="col-xl-3 col-lg-4 col-md-6">
                <div class="card card-modern playlist-card h-100" 
                     onclick="YouTubeMusicController.openPlaylist('${playlist.id}', '${this.escapeString(playlist.title)}')">
                    <img src="${playlist.thumbnail}" 
                         class="card-img-top" 
                         alt="${this.escapeString(playlist.title)}" 
                         style="height: 200px; object-fit: cover;"
                         onerror="this.src='https://via.placeholder.com/300x200/6c757d/ffffff?text=Image+Non+Disponible'">
                    <div class="card-body d-flex flex-column">
                        <h6 class="card-title" title="${this.escapeString(playlist.title)}">
                            ${this.truncateText(playlist.title, 50)}
                        </h6>
                        <p class="card-text text-muted small flex-grow-1">
                            ${this.truncateText(playlist.description, 80)}
                        </p>
                        <div class="d-flex justify-content-between align-items-center mt-auto">
                            <small class="text-muted">
                                <i class="bi bi-music-note-list"></i> 
                                ${playlist.videoCount} vidéos
                            </small>
                            <small class="text-muted" title="${playlist.channel}">
                                <i class="bi bi-person"></i> 
                                ${this.truncateText(playlist.channel, 15)}
                            </small>
                        </div>
                    </div>
                </div>
            </div>
        `).join('');
            },

            async searchMusic(query) {
                if (!query || query.trim().length < 2) {
                    this.loadPopularContent();
                    return;
                }

                const musicContent = document.getElementById('musicContent');
                if (!musicContent) return;

                musicContent.innerHTML = `
            <div class="col-12">
                <div class="d-flex justify-content-between align-items-center mb-4">
                    <h5>Résultats pour: "${query}"</h5>
                    <button class="btn btn-outline-secondary btn-sm" onclick="YouTubeMusicController.loadPopularContent()">
                        <i class="bi bi-arrow-left"></i> Retour
                    </button>
                </div>
                <div class="row g-4" id="searchResultsGrid">
                    <div class="col-12 text-center py-4">
                        <div class="spinner-border text-primary"></div>
                        <p class="mt-2">Recherche de "${query}"...</p>
                    </div>
                </div>
            </div>
        `;

                try {
                    // Search for both playlists and videos
                    const [playlistsData, videosData] = await Promise.all([
                        this.makeYouTubeAPIRequest('search', {
                            q: query + ' music playlist',
                            type: 'playlist',
                            videoCategoryId: '10'
                        }),
                        this.makeYouTubeAPIRequest('search', {
                            q: query + ' music',
                            type: 'video',
                            videoCategoryId: '10'
                        })
                    ]);

                    const results = [];

                    // Process playlists
                    if (playlistsData.items) {
                        for (const item of playlistsData.items.slice(0, 6)) {
                            try {
                                const playlistDetails = await this.makeYouTubeAPIRequest('playlists', {
                                    id: item.id.playlistId
                                });

                                results.push({
                                    type: 'playlist',
                                    id: item.id.playlistId,
                                    title: item.snippet.title,
                                    description: item.snippet.description,
                                    thumbnail: item.snippet.thumbnails?.medium?.url,
                                    channel: item.snippet.channelTitle,
                                    videoCount: playlistDetails.items[0]?.contentDetails?.itemCount || 'N/A'
                                });
                            } catch (error) {
                                console.error('Error fetching playlist details:', error);
                            }
                        }
                    }

                    // Process videos
                    if (videosData.items) {
                        videosData.items.slice(0, 6).forEach(item => {
                            results.push({
                                type: 'video',
                                id: item.id.videoId,
                                title: item.snippet.title,
                                description: item.snippet.description,
                                thumbnail: item.snippet.thumbnails?.medium?.url,
                                channel: item.snippet.channelTitle,
                                duration: 'Video' // You can get duration from video details API if needed
                            });
                        });
                    }

                    this.displaySearchResults(results, query);

                } catch (error) {
                    console.error('Search error:', error);
                    this.showError('Erreur de recherche', error);
                }
            },

            displaySearchResults: function (results, query) {
                const grid = document.getElementById('searchResultsGrid');
                if (!grid) return;

                if (results.length === 0) {
                    grid.innerHTML = `
                <div class="col-12 text-center py-5">
                    <i class="bi bi-search fs-1 text-muted"></i>
                    <h5 class="mt-3">Aucun résultat trouvé</h5>
                    <p class="text-muted">Aucun contenu trouvé pour "${query}"</p>
                    <button class="btn btn-primary mt-2" onclick="YouTubeMusicController.loadPopularContent()">
                        Voir le contenu populaire
                    </button>
                </div>
            `;
                    return;
                }

                grid.innerHTML = results.map(item => {
                    const escapedTitle = this.escapeString(item.title);
                    const truncatedTitle = this.truncateText(item.title, 60);
                    const truncatedDesc = this.truncateText(item.description, 100);

                    if (item.type === 'playlist') {
                        return `
                    <div class="col-xl-4 col-lg-6">
                        <div class="card card-modern playlist-card h-100" 
                             onclick="YouTubeMusicController.openPlaylist('${item.id}', '${escapedTitle}')">
                            <img src="${item.thumbnail}" 
                                 class="card-img-top" 
                                 alt="${escapedTitle}"
                                 style="height: 200px; object-fit: cover;"
                                 onerror="this.src='https://via.placeholder.com/300x200/6c757d/ffffff?text=Playlist'">
                            <div class="card-body d-flex flex-column">
                                <h6 class="card-title">
                                    <i class="bi bi-music-note-list text-primary me-2"></i>
                                    ${truncatedTitle}
                                </h6>
                                <p class="card-text text-muted small flex-grow-1">
                                    ${truncatedDesc}
                                </p>
                                <div class="d-flex justify-content-between align-items-center mt-auto">
                                    <small class="text-muted">
                                        <i class="bi bi-collection-play"></i> 
                                        ${item.videoCount} vidéos
                                    </small>
                                    <small class="text-muted" title="${item.channel}">
                                        ${this.truncateText(item.channel, 20)}
                                    </small>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                    } else {
                        return `
                    <div class="col-xl-4 col-lg-6">
                        <div class="card card-modern h-100" 
                             onclick="YouTubeMusicController.playVideo('${item.id}', '${escapedTitle}')">
                            <img src="${item.thumbnail}" 
                                 class="card-img-top" 
                                 alt="${escapedTitle}"
                                 style="height: 200px; object-fit: cover;"
                                 onerror="this.src='https://via.placeholder.com/300x200/6c757d/ffffff?text=Video'">
                            <div class="card-body d-flex flex-column">
                                <h6 class="card-title">
                                    <i class="bi bi-play-btn text-danger me-2"></i>
                                    ${truncatedTitle}
                                </h6>
                                <p class="card-text text-muted small flex-grow-1">
                                    ${truncatedDesc}
                                </p>
                                <div class="d-flex justify-content-between align-items-center mt-auto">
                                    <small class="text-muted">
                                        <i class="bi bi-play-circle"></i> Vidéo
                                    </small>
                                    <small class="text-muted" title="${item.channel}">
                                        ${this.truncateText(item.channel, 20)}
                                    </small>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
                    }
                }).join('');
            },

            async openPlaylist(playlistId, playlistTitle) {
                this.currentPlaylist = { id: playlistId, title: playlistTitle };

                document.getElementById('musicContent').classList.add('d-none');
                document.getElementById('playlistDetail').classList.remove('d-none');
                document.getElementById('playlistTitle').textContent = playlistTitle;

                await this.loadPlaylistVideos(playlistId);
            },

            async loadPlaylistVideos(playlistId) {
                const grid = document.getElementById('playlistVideosGrid');
                if (!grid) return;

                grid.innerHTML = `
            <div class="col-12 text-center py-4">
                <div class="spinner-border text-primary"></div>
                <p class="mt-2">Chargement des vidéos de la playlist...</p>
            </div>
        `;

                try {
                    const playlistItems = await this.makeYouTubeAPIRequest('playlistItems', {
                        playlistId: playlistId,
                        maxResults: 50
                    });

                    if (!playlistItems.items || playlistItems.items.length === 0) {
                        grid.innerHTML = `
                    <div class="col-12 text-center py-5">
                        <i class="bi bi-music-note-list fs-1 text-muted"></i>
                        <p class="mt-2">Cette playlist est vide</p>
                    </div>
                `;
                        return;
                    }

                    this.displayPlaylistVideos(playlistItems.items);

                } catch (error) {
                    console.error('Playlist load error:', error);
                    grid.innerHTML = `
                <div class="col-12 text-center py-5">
                    <i class="bi bi-exclamation-triangle fs-1 text-danger"></i>
                    <p class="mt-2">Erreur de chargement de la playlist</p>
                    <button class="btn btn-outline-primary mt-2" onclick="YouTubeMusicController.loadPlaylistVideos('${playlistId}')">
                        <i class="bi bi-arrow-clockwise"></i> Réessayer
                    </button>
                </div>
            `;
                }
            },

            displayPlaylistVideos: function (videos) {
                const grid = document.getElementById('playlistVideosGrid');
                if (!grid) return;

                grid.innerHTML = videos.map(item => {
                    const video = item.snippet;
                    const escapedTitle = this.escapeString(video.title);
                    const truncatedTitle = this.truncateText(video.title, 70);

                    return `
                <div class="col-lg-6">
                    <div class="playlist-video-item card card-modern" 
                         onclick="YouTubeMusicController.playVideo('${video.resourceId.videoId}', '${escapedTitle}')">
                        <div class="card-body d-flex align-items-center">
                            <img src="${video.thumbnails?.default?.url}" 
                                 alt="${escapedTitle}"
                                 style="width: 80px; height: 60px; object-fit: cover; border-radius: 6px;"
                                 onerror="this.src='https://via.placeholder.com/80x60/6c757d/ffffff?text=Video'">
                            <div class="ms-3 flex-grow-1">
                                <h6 class="mb-1 small" title="${escapedTitle}">
                                    ${truncatedTitle}
                                </h6>
                                <small class="text-muted">
                                    <i class="bi bi-person"></i> ${video.channelTitle}
                                </small>
                            </div>
                            <i class="bi bi-play-circle fs-4 text-primary"></i>
                        </div>
                    </div>
                </div>
            `;
                }).join('');
            },

            playVideo: function (videoId, title) {
                // Add to play history
                this.addToPlayHistory({
                    videoId: videoId,
                    title: title,
                    thumbnail: `https://img.youtube.com/vi/${videoId}/default.jpg`,
                    timestamp: new Date().toISOString()
                });

                // Initialize music player
                this.initializeMusicPlayer();

                // Load and play the video
                this.loadVideoInPlayer(videoId, title);

                // Show notification
                showToast(`🎵 Lecture: ${this.truncateText(title, 40)}`, 'success');
            },

            initializeMusicPlayer: function () {
                const playerFixed = document.getElementById('musicPlayerFixed');
                if (playerFixed) {
                    playerFixed.style.display = 'flex';
                }
                this.attachPlayerControls();
            },

            loadVideoInPlayer: function (videoId, title) {
                document.getElementById('trackTitle').textContent = title;
                document.getElementById('trackArtist').textContent = 'YouTube Music';

                const thumbnail = document.getElementById('trackThumbnail');
                thumbnail.src = `https://img.youtube.com/vi/${videoId}/default.jpg`;
                thumbnail.style.display = 'block';
                thumbnail.onerror = function () {
                    this.style.display = 'none';
                };

                // Initialize YouTube IFrame Player API
                if (!this.player) {
                    this.player = new YT.Player('playerEmbed', {
                        height: '0',
                        width: '0',
                        videoId: videoId,
                        events: {
                            onReady: (event) => event.target.playVideo()
                        }
                    });
                } else {
                    this.player.loadVideoById(videoId);
                }
            },


            showMainView: function () {
                document.getElementById('playlistDetail').classList.add('d-none');
                document.getElementById('musicContent').classList.remove('d-none');
                this.currentPlaylist = null;
                this.loadPopularContent();
            },

            connectYouTubeAccount: function () {
                showToast('Fonctionnalité de connexion YouTube à venir...', 'info');
                // Future implementation for OAuth
            },

            // Utility functions
            escapeString: function (str) {
                return str.replace(/'/g, "\\'").replace(/"/g, '\\"');
            },

            truncateText: function (text, maxLength) {
                if (text.length <= maxLength) return text;
                return text.substring(0, maxLength) + '...';
            },

            showError: function (message, error) {
                const grid = document.getElementById('searchResultsGrid') || document.getElementById('musicPlaylistsGrid');
                if (grid) {
                    grid.innerHTML = `
                <div class="col-12 text-center py-5">
                    <i class="bi bi-exclamation-triangle fs-1 text-danger"></i>
                    <h5 class="mt-3">${message}</h5>
                    <p class="text-muted">${error.message}</p>
                    <button class="btn btn-outline-primary mt-2" onclick="YouTubeMusicController.loadPopularContent()">
                        <i class="bi bi-arrow-clockwise"></i> Réessayer
                    </button>
                </div>
            `;
                }
            },

            showFallbackContent: function () {
                const grid = document.getElementById('musicPlaylistsGrid');
                if (grid) {
                    grid.innerHTML = `
                <div class="col-12 text-center py-5">
                    <i class="bi bi-music-note-beamed fs-1 text-muted"></i>
                    <h5 class="mt-3">Contenu musical non disponible</h5>
                    <p class="text-muted">Impossible de charger les playlists pour le moment.</p>
                    <button class="btn btn-primary mt-2" onclick="YouTubeMusicController.loadPopularContent()">
                        <i class="bi bi-arrow-clockwise"></i> Réessayer
                    </button>
                </div>
            `;
                }
            },

            showRecentHistory: function () {
                const history = this.getPlayHistory();
                if (history.length > 0) {
                    const grid = document.getElementById('musicPlaylistsGrid');
                    if (grid) {
                        grid.innerHTML += `
                    <div class="col-12 mt-5">
                        <h5 class="mb-3 border-bottom pb-2">
                            <i class="bi bi-clock-history text-primary me-2"></i>
                            Récemment écouté
                        </h5>
                        <div class="row g-3">
                            ${history.slice(0, 6).map(item => `
                                <div class="col-lg-4 col-md-6">
                                    <div class="card card-modern hover-lift" 
                                         onclick="YouTubeMusicController.playVideoFromHistory('${item.videoId}', '${this.escapeString(item.title)}')">
                                        <div class="card-body d-flex align-items-center">
                                            <img src="${item.thumbnail}" 
                                                 alt="${this.escapeString(item.title)}"
                                                 style="width: 60px; height: 60px; object-fit: cover; border-radius: 8px;"
                                                 onerror="this.style.display='none'">
                                            <div class="ms-3 flex-grow-1">
                                                <h6 class="mb-0 small" title="${this.escapeString(item.title)}">
                                                    ${this.truncateText(item.title, 40)}
                                                </h6>
                                                <small class="text-muted">${this.formatTimeAgo(item.timestamp)}</small>
                                            </div>
                                            <i class="bi bi-play-circle text-primary fs-5"></i>
                                        </div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                    }
                }
            },

            playVideoFromHistory: function (videoId, title) {
                this.playVideo(videoId, title);
            },

            // Player controls (simplified for demo)
            togglePlayPause: function () {
                const btn = document.getElementById('btnPlay');
                if (btn) {
                    const isPlaying = btn.classList.contains('playing');
                    if (isPlaying) {
                        btn.innerHTML = '<i class="bi bi-play-circle-fill"></i>';
                        btn.classList.remove('playing');
                    } else {
                        btn.innerHTML = '<i class="bi bi-pause-circle-fill"></i>';
                        btn.classList.add('playing');
                    }
                }
            },

            // History management
            addToPlayHistory: function (item) {
                let history = this.getPlayHistory();
                history = history.filter(h => h.videoId !== item.videoId);
                history.unshift(item);

                if (history.length > 50) history = history.slice(0, 50);
                localStorage.setItem('youtubeMusicHistory', JSON.stringify(history));
            },

            getPlayHistory: function () {
                try {
                    return JSON.parse(localStorage.getItem('youtubeMusicHistory')) || [];
                } catch {
                    return [];
                }
            },

            formatTimeAgo: function (timestamp) {
                const now = new Date();
                const time = new Date(timestamp);
                const diff = now - time;

                const minutes = Math.floor(diff / 60000);
                const hours = Math.floor(diff / 3600000);
                const days = Math.floor(diff / 86400000);

                if (minutes < 60) return `il y a ${minutes} min`;
                if (hours < 24) return `il y a ${hours} h`;
                return `il y a ${days} j`;
            },

            // Simple player controls
            attachPlayerControls: function () {
                // These would be connected to YouTube IFrame Player API in production
                document.getElementById('btnPlay')?.addEventListener('click', () => this.togglePlayPause());
                document.getElementById('btnPrev')?.addEventListener('click', () => showToast('Précédent', 'info'));
                document.getElementById('btnNext')?.addEventListener('click', () => showToast('Suivant', 'info'));
                document.getElementById('volumeControl')?.addEventListener('input', (e) => {
                    console.log('Volume:', e.target.value);
                });
                document.getElementById('btnVolumeToggle')?.addEventListener('click', () => {
                    const btn = document.getElementById('btnVolumeToggle');
                    const isMuted = btn.classList.contains('muted');
                    btn.innerHTML = isMuted ? '<i class="bi bi-volume-up"></i>' : '<i class="bi bi-volume-mute"></i>';
                    btn.classList.toggle('muted');
                });
            }
        };


    </script>
    <ul id="aiContextMenu" class="ai-context-menu" style="display: none;"></ul>
    <script src="https://accounts.google.com/gsi/client" async defer></script>
    <script src="https://www.youtube.com/iframe_api"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
</body>

</html>
